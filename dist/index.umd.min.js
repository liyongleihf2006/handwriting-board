!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).HandwritingBoard={})}(this,(function(t){"use strict";class e{undoStack=[];redoStack=[];restoreState=()=>{};saveState(t){this.undoStack.push(i(t)),this.redoStack.length=0}undo(){if(this.undoStack.length>0){const t=this.undoStack.pop();this.redoStack.push(t);const e=this.undoStack[this.undoStack.length-1]||{worldOffsetX:0,worldOffsetY:0,pointGroup:[]};this.doRestoreState(e)}}redo(){if(this.redoStack.length>0){const t=this.redoStack.pop();this.undoStack.push(t),this.doRestoreState(t)}}doRestoreState(t){this.restoreState(i(t))}}function i(t,e=new WeakMap){if(Object(t)!==t)return t;if(e.has(t))return e.get(t);const s=Array.isArray(t)?[]:{};return e.set(t,s),Object.keys(t).forEach((r=>{t[r]&&"object"==typeof t[r]?s[r]=i(t[r],e):s[r]=t[r]})),s}const s="rgb(250,250,250)",r="rgba(0,0,0,0.5)",o="rgb(0,0,0)",h="#333",n={grid:true,gridGap:100,gridFillStyle:s,rule:true,ruleGap:10,ruleUnitLen:5,ruleStrokeStyle:r,voice:1,color:o,stack:true,cleanR:20,moveCountTotal:20,writeLocked:false,dragLocked:false,showBorder:true,borderStyle:h,borderWidth:2};class a{canvas;width;height;ctx;worldOffsetX=0;worldOffsetY=0;scrolling=!1;d=1;maxD=2;pointsGroup=[];cleanState=!1;cleanX;cleanY;cleanPress=!1;stackObj;minX;minY;maxX;maxY;moveT=!1;grid;gridGap;gridPattern;gridFillStyle;rule;ruleGap;ruleUnitLen;ruleStrokeStyle;voice;color;cleanR;stack;moveCountTotal;writeLocked;dragLocked;showBorder;borderStyle;borderWidth;containerOffset;constructor(t,i=n){this.canvas=t,this.grid=i.grid??true,this.gridGap=i.gridGap??100,this.gridFillStyle=i.gridFillStyle??s,this.rule=i.rule??true,this.ruleGap=i.ruleGap??10,this.ruleUnitLen=i.ruleUnitLen??5,this.ruleStrokeStyle=i.ruleStrokeStyle??r,this.voice=i.voice??1,this.color=i.color??o,this.stack=i.stack??true,this.cleanR=i.cleanR??20,this.moveCountTotal=i.moveCountTotal??20,this.writeLocked=i.writeLocked??false,this.dragLocked=i.dragLocked??false,this.showBorder=i.showBorder??true,this.borderStyle=i.borderStyle??h,this.borderWidth=i.borderWidth??2,this.containerOffset=i.containerOffset??(()=>{const t=document.scrollingElement,e=this.canvas.getBoundingClientRect();return{x:e.x+t.scrollLeft,y:e.y+t.scrollTop}}),this.stack&&(this.stackObj=new e,this.stackObj.restoreState=t=>{const e=this.worldOffsetX,i=this.worldOffsetY,s=t.worldOffsetX-e,r=t.worldOffsetY-i;if(s||r){const e=s/this.moveCountTotal,i=r/this.moveCountTotal;this.pointsGroup=t.pointGroup,this.moveT=!0,this.doMove(e,i)}else this.worldOffsetX=t.worldOffsetX,this.worldOffsetY=t.worldOffsetY,this.pointsGroup=t.pointGroup,this.draw()});const a=t.getBoundingClientRect();this.width=a.width,this.height=a.height,t.width=this.width,t.height=this.height,this.ctx=this.canvas.getContext("2d"),this.gridPattern=this.generateGridPattern(),this.loadEvent(),this.draw()}setVoice(t=1){this.voice=t,this.d=t,this.maxD=2*t}showGrid(){this.grid=!0,this.draw()}hideGrid(){this.grid=!1,this.draw()}showRule(){this.rule=!0,this.draw()}hideRule(){this.rule=!1,this.draw()}doMove(t,e,i=0){this.worldOffsetX+=t,this.worldOffsetY+=e,this.draw(),self.requestAnimationFrame((()=>{this.moveT&&i<this.moveCountTotal?this.doMove(t,e,++i):this.moveT=!1}))}scrollBy(t=0,e=0){if(!this.dragLocked){const i=t/this.moveCountTotal,s=e/this.moveCountTotal;this.moveT=!0,this.doMove(i,s)}}clear(){this.worldOffsetX=0,this.worldOffsetY=0,this.pointsGroup=[],this.draw(),this.stackObj.saveState({worldOffsetX:this.worldOffsetX,worldOffsetY:this.worldOffsetY,pointGroup:this.pointsGroup})}exportAsCanvas(){const t=document.createElement("canvas");if(void 0!==this.minX){t.width=this.maxX-this.minX,t.height=this.maxY-this.minY;const e=t.getContext("2d");this.pointsGroup?.forEach((({corners:t,fillStyle:i})=>{t.forEach((([[t,s],[r,o],[h,n],[a,l]])=>{const d=t-this.minX,c=s-this.minY,f=r-this.minX,u=o-this.minY,g=h-this.minX,p=n-this.minY,w=a-this.minX,m=l-this.minY;e.save(),e.fillStyle=i,e.beginPath(),e.moveTo(d,c),e.lineTo(f,u),e.lineTo(w,m),e.lineTo(g,p),e.fill(),e.restore()}))}))}else t.width=0,t.height=0;return t}undo(){this.stackObj.undo()}redo(){this.stackObj.redo()}clean(){this.cleanState=!0}unclean(){this.cleanState=!1}draw(){this.ctx.clearRect(0,0,this.width,this.height),this.loadGrid(),this.doWriting(),this.drawEraser(),this.loadRule(),this.loadBorder()}loadEvent(){let t=!1,e=!1,i=0,s=0,r=0,o=0,h=0,n=0,a=!1,l=!1,d=0,c=0,f=0,u=0,g=0,p=0;const w=e=>{t=!1,l=!0,a=!0,u=e.pageX,g=e.pageY,p=performance.now(),this.cleanState&&(this.cleanX=u,this.cleanY=g,this.cleanPress=!0,this.draw())},m=t=>{this.moveT=!1,this.scrolling=!1;const i=t.touches;if(2===i.length){if(e=!0,this.dragLocked)return;const t=G(i);o=t.pageX,h=t.pageY,n=performance.now(),this.cleanState&&(this.cleanPress=!1,this.draw())}else if(1===i.length&&!this.writeLocked){const t=G(i);w(t)}},v=t=>{if(!this.writeLocked){const{pageX:e,pageY:i}=t,s=G([{pageX:e,pageY:i}]);w(s)}},S=e=>{t=!0,d=u,c=g,f=p,u=e.pageX,g=e.pageY,p=performance.now(),this.cleanState?(this.cleanX=u,this.cleanY=g,this.doClean(u,g)):(a&&(this.pointsGroup.push({corners:[],fillStyle:this.color}),a=!1),this.pushPoints(d,c,u,g,f,p)),this.draw()},O=t=>{if(l){const{pageX:e,pageY:i}=t,s=G([{pageX:e,pageY:i}]);S(s)}},x=t=>{const a=t.touches;if(e){if(this.dragLocked)return;i=o,s=h,r=n;const t=G(a);o=t.pageX,h=t.pageY,n=performance.now();const e=o-i,l=h-s;this.worldOffsetX-=e,this.worldOffsetY-=l,this.draw()}else if(l){const t=G(a);S(t)}},X=(t,e)=>{this.scrolling=!0;let i=0;const s=(t,e)=>{if(Math.abs(t)>.1||Math.abs(e)>.1){this.worldOffsetX-=t,this.worldOffsetY-=e,this.draw();const r=Math.max(99-.01*i++,50)/100;t*=r,e*=r,self.requestAnimationFrame((()=>{this.scrolling&&s(t,e)}))}else this.scrolling=!1};s(t,e)},k=()=>{if(e){if(this.dragLocked)return;const t=n-r;X((o-i)/t,(h-s)/t)}else l&&this.stack&&t&&this.stackObj.saveState({worldOffsetX:this.worldOffsetX,worldOffsetY:this.worldOffsetY,pointGroup:this.pointsGroup});this.cleanState&&(this.cleanPress=!1,this.draw()),e=!1,l=!1},Y=this.canvas;"ontouchstart"in self?(Y.addEventListener("touchstart",m,{passive:!0}),Y.addEventListener("touchmove",x,{passive:!0}),Y.addEventListener("touchend",k,{passive:!0})):(Y.addEventListener("mousedown",v,{passive:!0}),self.addEventListener("mousemove",O,{passive:!0}),self.addEventListener("mouseup",k,{passive:!0}));const G=t=>{const{x:e,y:i}=this.containerOffset(),s=t.length;let r=0,o=0;for(let h=0;h<s;h++){const s=t[h];r+=s.pageX-e,o+=s.pageY-i}return r/=s,o/=s,{pageX:r,pageY:o}}}drawEraser(){this.cleanState&&this.cleanPress&&(this.ctx.save(),this.ctx.beginPath(),this.ctx.fillStyle="rgba(0,0,0,.1)",this.ctx.strokeStyle="rgba(0,0,0,.15)",this.ctx.arc(this.cleanX,this.cleanY,this.cleanR,0,2*Math.PI),this.ctx.fill(),this.ctx.stroke(),this.ctx.restore(),this.ctx.beginPath())}doClean(t,e){const i=t+this.worldOffsetX,s=e+this.worldOffsetY;this.pointsGroup.forEach((t=>{const e=t.corners;for(let t=e.length-1;t>=0;t--){const[[r,o],[h,n],[a,l],[d,c]]=e[t];this.isCircleIntersectRect(i,s,this.cleanR,r,o,h,n,d,c,a,l)&&e.splice(t,1)}}))}isCircleIntersectRect(t,e,i,s,r,o,h,n,a,l,d){if(t>=s&&t<=n&&e>=r&&e<=a)return!0;const c=(i,s)=>Math.sqrt((i-t)**2+(s-e)**2),f=[[s,r,o,h],[o,h,l,d],[l,d,n,a],[n,a,s,r]];for(let s=0;s<f.length;s++){const[r,o,h,n]=f[s],a=c(r,o),l=c(h,n);if(a<=i||l<=i)return!0;const d=h-r,u=n-o,g=((t-r)*d+(e-o)*u)/(d**2+u**2);if(g<0||g>1)continue;if(c(r+g*d,o+g*u)<=i)return!0}return!1}getCornerCoordinate(t,e,i,s,r,o){return[[r-e*s/Math.sqrt(t**2+e**2),o+t*s/Math.sqrt(t**2+e**2)],[r+e*s/Math.sqrt(t**2+e**2),o-t*s/Math.sqrt(t**2+e**2)]]}getCornersCoordinate(t,e,i,s,r){const o=i-t,h=s-e,n=o*t+h*e+r*Math.sqrt(o**2+h**2),[[a,l],[d,c]]=this.getCornerCoordinate(o,h,n,r,t,e),[[f,u],[g,p]]=this.getCornerCoordinate(o,h,n,r,i,s);return[[a,l],[d,c],[f,u],[g,p]]}pushPoints(t,e,i,s,r,o){const h=t+this.worldOffsetX,n=e+this.worldOffsetY,a=i+this.worldOffsetX,l=s+this.worldOffsetY,d=(o-r)/((l-n)**2+(a-h)**2)**.5*this.voice;if(!isNaN(d)){d>1.2*this.d?this.d*=1.2:d<this.d/1.2?this.d/=1.2:this.d=d,this.d>this.maxD&&(this.d=this.maxD);const t=this.getCornersCoordinate(h,n,a,l,this.d);if(!t.flat().some((t=>isNaN(t)))){const e=this.pointsGroup[this.pointsGroup.length-1].corners;if(e.length){const i=e[e.length-1];t[0]=i[2],t[1]=i[3]}e.push(t)}}}doWriting(){this.pointsGroup.forEach((({corners:t,fillStyle:e},i)=>{this.ctx.save(),this.ctx.fillStyle=e,this.ctx.beginPath(),t.forEach((([[t,e],[s,r],[o,h],[n,a]],l)=>{const d=t-this.worldOffsetX,c=e-this.worldOffsetY,f=s-this.worldOffsetX,u=r-this.worldOffsetY,g=o-this.worldOffsetX,p=h-this.worldOffsetY,w=n-this.worldOffsetX,m=a-this.worldOffsetY;this.ctx.moveTo(d,c),this.ctx.lineTo(f,u),this.ctx.lineTo(w,m),this.ctx.lineTo(g,p),i||l?(this.minX=Math.min(this.minX,t,s,o,n),this.minY=Math.min(this.minY,e,r,h,a),this.maxX=Math.max(this.maxX,t,s,o,n),this.maxY=Math.max(this.maxY,e,r,h,a)):(this.minX=Math.min(t,s,o,n),this.minY=Math.min(e,r,h,a),this.maxX=Math.max(t,s,o,n),this.maxY=Math.max(e,r,h,a))})),this.ctx.fill(),this.ctx.restore()}))}generateGridPattern(){const t=this.gridGap,e=new OffscreenCanvas(2*t,2*t),i=e.getContext("2d");i.fillStyle=this.gridFillStyle,i.fillRect(0,0,t,t),i.fillRect(t,t,t,t);return i.createPattern(e,"repeat")}loadGrid(){if(this.grid){const t=-this.negativeRemainder(this.worldOffsetX,2*this.gridGap),e=-this.negativeRemainder(this.worldOffsetY,2*this.gridGap),i=this.ctx;i.save(),i.translate(t,e),i.fillStyle=this.gridPattern,i.fillRect(0,0,this.width+2*this.gridGap,this.height+2*this.gridGap),i.restore()}}negativeRemainder(t,e){return(t%e+e)%e}loadBorder(){if(this.showBorder){const t=this.ctx;t.beginPath(),t.save(),t.strokeStyle=this.borderStyle,t.lineWidth=this.borderWidth,t.strokeRect(0,0,this.width,this.height),t.restore()}}loadRule(){if(this.rule){const t=this.ctx;t.beginPath(),t.save(),t.strokeStyle=this.ruleStrokeStyle,t.font="12px Arial",t.textAlign="center",t.fillStyle=this.ruleStrokeStyle;const e=this.negativeRemainder(this.worldOffsetX,10*this.ruleGap),i=this.negativeRemainder(this.worldOffsetY,10*this.ruleGap),s=(this.worldOffsetX-this.worldOffsetX%(10*this.ruleGap))/(10*this.ruleGap)*10,r=(this.worldOffsetY-this.worldOffsetY%(10*this.ruleGap))/(10*this.ruleGap)*10;let o=0,h=0,n=-e,a=-i;const l=3;for(;n<=this.width;){let e=this.ruleUnitLen;o%10?o%5||(e=1.5*this.ruleUnitLen):e=2.5*this.ruleUnitLen,t.moveTo(n,0),t.lineTo(n,e),t.moveTo(n,this.height),t.lineTo(n,this.height-e),o%10||(t.textBaseline="top",t.fillText(String(o+s),n,e+l),t.textBaseline="bottom",t.fillText(String(o+s),n,this.height-e-l)),n+=this.ruleGap,o++}for(t.textBaseline="middle";a<=this.height;){let e=this.ruleUnitLen;h%10?h%5||(e=1.5*this.ruleUnitLen):e=2.5*this.ruleUnitLen,t.moveTo(0,a),t.lineTo(e,a),t.moveTo(this.width,a),t.lineTo(this.width-e,a),h%10||(t.textAlign="left",t.fillText(String(h+r),e+l,a),t.textAlign="right",t.fillText(String(h+r),this.width-e-l,a)),a+=this.ruleGap,h++}t.stroke(),t.restore()}}}t.Board=a,t.default=a,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.min.js.map
