{"version":3,"file":"index.umd.min.js","sources":["../src/stack.ts","../src/enum.ts","../src/utils.ts","../src/component/shape/Ruler.ts","../src/component/shape/Compass360.ts","../src/component/shape/Triangle.ts","../src/component/ToolShape.ts","../src/component/shape/Compass.ts","../src/component/Background.ts","../src/component/RuleAuxiliary.ts","../src/component/Border.ts","../src/component/Writing.ts","../src/component/Eraser.ts","../src/index.ts"],"sourcesContent":["export class Stack {\n    width;\n    height;\n    undoStack = [];\n    redoStack = [];\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    restoreState = () => undefined;\n    saveState(store) {\n        this.undoStack.push([...store]);\n        this.redoStack.length = 0;\n    }\n    undo() {\n        if (this.undoStack.length > 0) {\n            const lastState = this.undoStack.pop();\n            this.redoStack.push(lastState);\n            let previousState = this.undoStack[this.undoStack.length - 1];\n            if (!previousState) {\n                const data = new Uint8ClampedArray(this.width * 4 * this.height);\n                const imageData = new ImageData(data, this.width, this.height);\n                previousState = [{ worldOffsetX: 0, worldOffsetY: 0, imageData }];\n            }\n            this.doRestoreState(previousState);\n        }\n    }\n    redo() {\n        if (this.redoStack.length > 0) {\n            const nextState = this.redoStack.pop();\n            this.undoStack.push(nextState);\n            this.doRestoreState(nextState);\n        }\n    }\n    doRestoreState(store) {\n        this.restoreState([...store]);\n    }\n}\n//# sourceMappingURL=stack.js.map","export var WriteModel;\n(function (WriteModel) {\n    WriteModel[\"WRITE\"] = \"write\";\n    WriteModel[\"DRAW\"] = \"draw\";\n})(WriteModel || (WriteModel = {}));\nexport var BGPattern;\n(function (BGPattern) {\n    BGPattern[\"GRID\"] = \"grid\";\n    BGPattern[\"GRID_PAPER\"] = \"gridPaper\";\n    BGPattern[\"QUADRILLE_PAPER\"] = \"quadrillePaper\";\n})(BGPattern || (BGPattern = {}));\nexport var ScrollDirection;\n(function (ScrollDirection) {\n    ScrollDirection[\"ALL\"] = \"all\";\n    ScrollDirection[\"X\"] = \"x\";\n    ScrollDirection[\"Y\"] = \"y\";\n})(ScrollDirection || (ScrollDirection = {}));\nexport var ShapeType;\n(function (ShapeType) {\n    ShapeType[\"RULER\"] = \"ruler\";\n    ShapeType[\"COMPASS\"] = \"compass\";\n    ShapeType[\"COMPASS360\"] = \"compass360\";\n    ShapeType[\"RIGHT_ANGLE_TRIANGLE\"] = \"rightAngleTriangle\";\n    ShapeType[\"SOSCELESL_TRIANGLE\"] = \"isoscelesTriangle\";\n})(ShapeType || (ShapeType = {}));\n//# sourceMappingURL=enum.js.map","export function debounce(func, delay) {\n    let timer;\n    return function (...args) {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            func.apply(this, args);\n        }, delay);\n    };\n}\nexport function RotateCoordinates(angle, x0, y0) {\n    const angleInRadians = angle * Math.PI / 180;\n    const cosAngle = Math.cos(angleInRadians);\n    const sinAngle = Math.sin(angleInRadians);\n    return function (x, y) {\n        const x1 = x - x0;\n        const y1 = y - y0;\n        const targetX = x1 * cosAngle - y1 * sinAngle + x0;\n        const targetY = x1 * sinAngle + y1 * cosAngle + y0;\n        return [targetX, targetY];\n    };\n}\nexport function rotateAngle(angle, angle0) {\n    // 将角度转换为弧度\n    const radian = (angle + angle0) * (Math.PI / 180);\n    return radian;\n}\nexport function calculateRotatedPoint(rx, ry, r, angle, _angle) {\n    const angleRad = angle * (Math.PI / 180); // 将角度转换为弧度\n    const _angleRad = _angle * (Math.PI / 180); // 将旋转角度转换为弧度\n    const x = rx + r * Math.cos(angleRad + _angleRad); // 计算点的 x 坐标\n    const y = ry + r * Math.sin(angleRad + _angleRad); // 计算点的 y 坐标\n    return [x, y];\n}\nexport function getTripleTouchAngleAndCenter(event) {\n    const touch1 = event.touches[0];\n    const touch2 = event.touches[1];\n    const x1 = touch1.pageX;\n    const y1 = touch1.pageY;\n    const x2 = touch2.pageX;\n    const y2 = touch2.pageY;\n    const deltaX = x2 - x1;\n    const deltaY = y2 - y1;\n    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n    const centerX = (x1 + x2) / 2;\n    const centerY = (y1 + y2) / 2;\n    return { angle, center: [centerX, centerY] };\n}\nexport function rotateCoordinate(x0, y0, angle, originX, originY) {\n    const radians = angle * (Math.PI / 180);\n    const deltaX = originX - x0;\n    const deltaY = originY - y0;\n    const newX = Math.cos(radians) * deltaX - Math.sin(radians) * deltaY;\n    const newY = Math.sin(radians) * deltaX + Math.cos(radians) * deltaY;\n    const rotatedX = newX + x0;\n    const rotatedY = newY + y0;\n    return [rotatedX, rotatedY];\n}\nexport function negativeRemainder(a, b) {\n    return ((a % b) + b) % b;\n}\nexport function generateCanvas(width, height) {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    Object.assign(canvas.style, {\n        left: '0',\n        top: '0',\n        position: 'absolute',\n        'pointer-events': 'none'\n    });\n    return canvas;\n}\n//# sourceMappingURL=utils.js.map","import { RotateCoordinates } from '../../utils';\nexport default class Ruler {\n    ctx;\n    cm;\n    mm;\n    path;\n    width = 0;\n    height = 0;\n    marginH = 0;\n    degreeNumber = 20;\n    constructor(ctx, cm, mm) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.marginH = this.mm * 5;\n        this.width = this.cm * this.degreeNumber + this.marginH * 2;\n        this.height = this.cm * 2;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const width = this.width + voice;\n        const height = this.height + voice;\n        const x = _cx - voice / 2 - width / 2;\n        const y = _cy - voice / 2 - height / 2;\n        const angle = _angle;\n        const cm = this.cm;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        let pathStr = '';\n        pathStr += `M${rotateCoordinates(x, y).join(',')}`;\n        pathStr += `L${rotateCoordinates(x + width, y).join(',')}`;\n        pathStr += `L${rotateCoordinates(x + width, y + height).join(',')}`;\n        const offestX = 1.5 * cm + this.marginH + voice / 2;\n        const beginWaveX = x + width - offestX;\n        const beginWaveY = y + height;\n        const endWaveX = x + offestX;\n        const waveUnit = cm * 2 / 3;\n        const waveUnitY = waveUnit / 4;\n        const waveY = beginWaveY - waveUnitY;\n        pathStr += `L${rotateCoordinates(beginWaveX, beginWaveY).join(',')}`;\n        let currentWaveUnit = beginWaveX - waveUnit;\n        while (currentWaveUnit > endWaveX) {\n            pathStr += `C${[...rotateCoordinates(currentWaveUnit + waveUnit / 3, waveY - waveUnitY), ...rotateCoordinates(currentWaveUnit + waveUnit * 2 / 3, waveY + waveUnitY), ...rotateCoordinates(currentWaveUnit, beginWaveY)].join(',')}`;\n            currentWaveUnit -= waveUnit;\n        }\n        pathStr += `L${rotateCoordinates(x, beginWaveY).join(',')}`;\n        pathStr += 'z';\n        const path = new Path2D(pathStr);\n        this.path = path;\n        return path;\n    }\n    draw(cx, cy, angle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const marginH = this.marginH;\n        const cm = this.cm;\n        const mm = this.mm;\n        const degreeNumber = this.degreeNumber;\n        const width = this.width;\n        const height = this.height;\n        const rotateCoordinates = RotateCoordinates(angle, cx, cy);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path);\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = 'black';\n        ctx.font = \"3mm serif\";\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n        ctx.beginPath();\n        const cmLen = 0.5 * cm;\n        const x = cx - width / 2;\n        const y = cy - height / 2;\n        const textPos = y + cmLen + mm;\n        const mmLen = cmLen * 0.6;\n        const halfCmLen = cmLen * 0.8;\n        for (let i = 0; i <= degreeNumber; i++) {\n            const currentX = x + marginH + i * cm;\n            ctx.moveTo(...rotateCoordinates(currentX, y));\n            ctx.lineTo(...rotateCoordinates(currentX, y + cmLen));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(currentX, textPos));\n            ctx.rotate(angle * Math.PI / 180);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumber) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmX = currentX + j * mm;\n                    ctx.moveTo(...rotateCoordinates(currentMmX, y));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + halfCmLen));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + mmLen));\n                    }\n                }\n            }\n        }\n        ctx.stroke();\n        ctx.restore();\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Ruler.js.map","import { rotateAngle, RotateCoordinates } from '../../utils';\nfunction isTouchDevice() {\n    return 'ontouchstart' in self;\n}\nexport default class Compass {\n    ctx;\n    cm;\n    mm;\n    container;\n    getPageCoords;\n    toolShape;\n    path;\n    outsideR;\n    insideR;\n    pointerW;\n    startAngle = 0;\n    endAngle = 360;\n    firstPointerAngle = 0;\n    secondPointerAngle = 30;\n    pointer1;\n    pointer2;\n    cx;\n    cy;\n    angle;\n    constructor(ctx, cm, mm, container, getPageCoords, toolShape) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.container = container;\n        this.getPageCoords = getPageCoords;\n        this.toolShape = toolShape;\n        this.outsideR = cm * 6;\n        this.insideR = cm * 4.5;\n        this.pointerW = cm * 1;\n        this.loadEvent();\n    }\n    calculateRotationAngle(cx, cy, dragStartX, dragStartY, dragEndX, dragEndY) {\n        // 计算向量a的x和y分量\n        const aX = dragStartX - cx;\n        const aY = dragStartY - cy;\n        // 计算向量b的x和y分量\n        const bX = dragEndX - cx;\n        const bY = dragEndY - cy;\n        // 计算向量a和向量b的夹角\n        const dotProduct = aX * bX + aY * bY; // 向量的点乘\n        const aLength = Math.sqrt(aX * aX + aY * aY); // 向量a的长度\n        const bLength = Math.sqrt(bX * bX + bY * bY); // 向量b的长度\n        const cosTheta = dotProduct / (aLength * bLength); // 夹角的余弦值\n        const theta = Math.acos(cosTheta); // 夹角的弧度值\n        // 判断旋转方向，如果向量a和向量b形成逆时针方向，则旋转角度为正值，否则为负值\n        const crossProduct = aX * bY - aY * bX; // 向量的叉乘\n        const rotationAngle = crossProduct >= 0 ? theta : -theta;\n        // 将弧度转换为角度\n        const rotationAngleInDegrees = rotationAngle * 180 / Math.PI;\n        return rotationAngleInDegrees;\n    }\n    loadEvent() {\n        const container = this.container;\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragEndX = 0;\n        let dragEndY = 0;\n        let doTurn = false;\n        let movePointer1 = false;\n        let movePointer2 = false;\n        const turnPoinerStart = (coords, event) => {\n            const ctx = this.ctx;\n            const pointer1 = this.pointer1;\n            const pointer2 = this.pointer2;\n            dragEndX = coords.pageX;\n            dragEndY = coords.pageY;\n            if (ctx.isPointInPath(pointer2, coords.pageX, coords.pageY)) {\n                event.stopImmediatePropagation();\n                movePointer2 = true;\n                doTurn = true;\n            }\n            else if (ctx.isPointInPath(pointer1, coords.pageX, coords.pageY)) {\n                event.stopImmediatePropagation();\n                movePointer1 = true;\n                doTurn = true;\n            }\n        };\n        const handleTouchStart = (event) => {\n            const touches = event.touches;\n            const coords = this.getPageCoords(touches);\n            if (touches.length === 1) {\n                turnPoinerStart(coords, event);\n            }\n            else {\n                doTurn = false;\n            }\n        };\n        const handleMouseStart = (event) => {\n            event.preventDefault();\n            const { pageX, pageY } = event;\n            const coords = this.getPageCoords([{ pageX, pageY }]);\n            turnPoinerStart(coords, event);\n        };\n        const turnPointerMove = (coords) => {\n            dragStartX = dragEndX;\n            dragStartY = dragEndY;\n            dragEndX = coords.pageX;\n            dragEndY = coords.pageY;\n            const deltaAngle = this.calculateRotationAngle(this.cx, this.cy, dragStartX, dragStartY, dragEndX, dragEndY);\n            if (movePointer1) {\n                this.firstPointerAngle += deltaAngle;\n            }\n            else if (movePointer2) {\n                this.secondPointerAngle += deltaAngle;\n            }\n            this.draw(this.cx, this.cy, this.angle);\n            this.toolShape.reset();\n        };\n        const handleMouseMove = (event) => {\n            if (doTurn) {\n                event.stopImmediatePropagation();\n                const { pageX, pageY } = event;\n                const coords = this.getPageCoords([{ pageX, pageY }]);\n                turnPointerMove(coords);\n            }\n        };\n        const handleTouchMove = (event) => {\n            if (doTurn) {\n                event.stopImmediatePropagation();\n                const touches = event.touches;\n                const coords = this.getPageCoords(touches);\n                turnPointerMove(coords);\n            }\n        };\n        const turnPointerEnd = () => {\n            doTurn = false;\n            movePointer1 = false;\n            movePointer2 = false;\n        };\n        const handleTouchEnd = () => {\n            turnPointerEnd();\n        };\n        const handleMouseEnd = (event) => {\n            turnPointerEnd();\n        };\n        if (isTouchDevice()) {\n            container.addEventListener(\"touchstart\", handleTouchStart, { passive: true });\n            container.addEventListener(\"touchmove\", handleTouchMove, { passive: true });\n            container.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\n        }\n        else {\n            container.addEventListener(\"mousedown\", handleMouseStart);\n            self.addEventListener(\"mousemove\", handleMouseMove, { passive: true });\n            self.addEventListener(\"mouseup\", handleMouseEnd, { passive: true });\n        }\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const cx = _x;\n        const cy = _y;\n        const angle = _angle;\n        this.drawBorder(c, cx, cy, angle, 0, 'rgba(0,0,0,1)');\n        this.drawPointer(c, cx, cy, angle, this.firstPointerAngle, 0, 'rgba(0,0,0,1)');\n        this.drawPointer(c, cx, cy, angle, this.secondPointerAngle, 0, 'rgba(0,0,0,1)');\n        c.globalCompositeOperation = 'source-out';\n        const offscreen1 = new OffscreenCanvas(width, height);\n        const c2 = offscreen1.getContext('2d');\n        this.drawBorder(c2, cx, cy, angle, outlineVoice, 'rgba(0,0,0,1)');\n        this.drawPointer(c2, cx, cy, angle, this.firstPointerAngle, outlineVoice, 'rgba(0,0,0,1)');\n        this.drawPointer(c2, cx, cy, angle, this.secondPointerAngle, outlineVoice, 'rgba(0,0,0,1)');\n        c.drawImage(offscreen1, 0, 0);\n        c.globalCompositeOperation = 'source-in';\n        c.fillStyle = strokeStyle;\n        c.fillRect(0, 0, width, height);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle) {\n        const startAngle = this.startAngle;\n        const endAngle = this.endAngle;\n        const outsideR = this.outsideR;\n        const insideR = this.insideR;\n        const r = (outsideR + insideR) / 2;\n        const cx = _cx;\n        const cy = _cy;\n        const path = new Path2D();\n        path.arc(cx, cy, r, rotateAngle(startAngle, _angle), rotateAngle(endAngle, _angle));\n        this.path = path;\n        return path;\n    }\n    generatorPointer(_cx, _cy, _angle, pointerAngle, outlineVoice) {\n        const outsideR = this.outsideR;\n        const pointerW = this.pointerW;\n        const cx = _cx;\n        const cy = _cy;\n        const r = pointerW / 2 + outlineVoice;\n        let angle = _angle;\n        angle += pointerAngle;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        let pathStr = '';\n        pathStr += `M${rotateCoordinates(cx, cy - r).join(',')}`;\n        pathStr += `A${r},${r},1,1,1,${rotateCoordinates(cx, cy + r).join(',')}`;\n        pathStr += `L${rotateCoordinates(cx - outsideR, cy + r).join(',')}`;\n        pathStr += `A${r},${r},1,1,1,${rotateCoordinates(cx - outsideR, cy - r).join(',')}`;\n        pathStr += 'z';\n        const path = new Path2D(pathStr);\n        return path;\n    }\n    drawDegree(cx, cy, r, smallUnitL, unitL, bigUnitL, ruleFontSize, fontGap, showText, showSmall, showMiddle, showBig, textOnInner, _angle, reverse) {\n        const ctx = this.ctx;\n        // 刻度设置\n        const total = 360; // 总刻度数\n        const unitS = 2 * Math.PI / total; // 刻度线间隔角度\n        const unitBigInterval = 10;\n        const unitInterval = unitBigInterval;\n        const ruleLoose = 5;\n        // 绘制刻度和刻度的数值\n        let angle = (180 + _angle) * Math.PI / 180;\n        ctx.save();\n        ctx.textAlign = 'center'; // 设置文本对齐方式\n        ctx.textBaseline = 'middle';\n        ctx.font = `${ruleFontSize}px Arial`; // 文本字体\n        if (!textOnInner) {\n            r += bigUnitL;\n            ctx.textBaseline = 'bottom';\n        }\n        for (let i = 0; i <= total; i++) {\n            if (i % unitBigInterval === 0) { // 大刻度\n                const startX = cx + Math.cos(angle) * (r - bigUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - bigUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                if (showBig) {\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n                if (i !== total && showText && i % unitInterval === 0) {\n                    const textX = cx + Math.cos(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置横坐标\n                    const textY = cy + Math.sin(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置纵坐标\n                    ctx.save();\n                    ctx.textAlign = 'center';\n                    ctx.translate(textX, textY);\n                    ctx.rotate(angle + Math.PI / 2);\n                    ctx.fillText((reverse ? total - i : i).toString(), 0, 0);\n                    ctx.restore();\n                }\n            }\n            else if (!(i % ruleLoose)) { // 中刻度\n                if (showMiddle) {\n                    const startX = cx + Math.cos(angle) * (r - unitL); // 刻度线起始点横坐标\n                    const startY = cy + Math.sin(angle) * (r - unitL); // 刻度线起始点纵坐标\n                    const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                    const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n            }\n            else if (showSmall) {\n                const startX = cx + Math.cos(angle) * (r - smallUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - smallUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n            }\n            angle += unitS; // 更新角度\n        }\n        ctx.restore();\n    }\n    drawContent(_cx, _cy, _angle) {\n        const outsideR = this.outsideR;\n        const cx = _cx;\n        const cy = _cy;\n        const ctx = this.ctx;\n        ctx.save();\n        this.drawDegree(cx, cy, outsideR, 10, 15, 20, 8, 10, true, true, true, true, true, _angle, false);\n        this.drawDegree(cx, cy, outsideR, 10, 15, 20, 8, 25, true, false, false, false, true, _angle, true);\n        ctx.restore();\n    }\n    drawBorder(ctx, cx, cy, angle, outlineVoice, strokeStyle) {\n        const outsideR = this.outsideR;\n        const insideR = this.insideR;\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = outsideR - insideR + 2 * outlineVoice;\n        ctx.strokeStyle = strokeStyle;\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.stroke(path);\n        ctx.restore();\n    }\n    drawPointer(ctx, cx, cy, angle, pointerAngle, outlineVoice, fillStyle) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = fillStyle;\n        const path = this.generatorPointer(cx, cy, angle, pointerAngle, outlineVoice);\n        ctx.fill(path);\n        ctx.restore();\n        return path;\n    }\n    drawFixedPoint(cx, cy, angle) {\n        const ctx = this.ctx;\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        ctx.arc(cx, cy, this.pointerW / 4, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n    }\n    draw(cx, cy, angle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        this.drawBorder(ctx, cx, cy, angle, 0, 'rgba(0,0,0,.08)');\n        this.drawContent(cx, cy, angle);\n        this.pointer1 = this.drawPointer(ctx, cx, cy, angle, this.firstPointerAngle, 0, 'rgba(0,0,0,.08)');\n        this.pointer2 = this.drawPointer(ctx, cx, cy, angle, this.secondPointerAngle, 0, 'rgba(0,0,0,.08)');\n        this.drawFixedPoint(cx, cy, angle);\n        this.cx = cx;\n        this.cy = cy;\n        this.angle = angle;\n    }\n    isPointInPath(x, y, fillRule) {\n        const ctx = this.ctx;\n        if (fillRule === 'evenodd') {\n            let isPointInStroke = false;\n            ctx.save();\n            ctx.lineWidth = this.outsideR - this.insideR;\n            isPointInStroke = ctx.isPointInStroke(this.path, x, y);\n            ctx.restore();\n            return isPointInStroke;\n        }\n        else {\n            return ctx.isPointInPath(this.path, x, y);\n        }\n    }\n}\n//# sourceMappingURL=Compass360.js.map","import { RotateCoordinates } from '../../utils';\nexport default class Triangle {\n    ctx;\n    cm;\n    mm;\n    degreeNumberH;\n    degreeNumberV;\n    marginH;\n    marginV;\n    path;\n    width = 0;\n    height = 0;\n    marginC = 0;\n    gap = 0;\n    constructor(ctx, cm, mm, degreeNumberH, degreeNumberV, marginH, marginV) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.degreeNumberH = degreeNumberH;\n        this.degreeNumberV = degreeNumberV;\n        this.marginH = marginH;\n        this.marginV = marginV;\n        this.marginC = this.cm;\n        this.width = this.cm * this.degreeNumberH + this.marginH + this.marginC;\n        this.height = this.cm * this.degreeNumberV + this.marginV + this.marginC;\n        this.gap = this.cm * 1.5;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const width = this.width + voice;\n        const height = this.height + voice;\n        const x = _cx - voice / 2 - width / 2;\n        const y = _cy - voice / 2 - height / 2;\n        const angle = _angle;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        const path = new Path2D();\n        path.moveTo(...rotateCoordinates(x + width, y));\n        path.lineTo(...rotateCoordinates(x, y));\n        path.lineTo(...rotateCoordinates(x, y + height));\n        path.closePath();\n        const gap = this.gap;\n        const smallX = x + gap;\n        const smallY = y + gap;\n        const smallWidth = width / 2;\n        const smallHeight = height / 2;\n        path.moveTo(...rotateCoordinates(smallX + smallWidth, smallY));\n        path.lineTo(...rotateCoordinates(smallX, smallY));\n        path.lineTo(...rotateCoordinates(smallX, smallY + smallHeight));\n        path.closePath();\n        this.path = path;\n        return path;\n    }\n    draw(cx, cy, angle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const marginC = this.marginC;\n        const cm = this.cm;\n        const mm = this.mm;\n        const degreeNumberH = this.degreeNumberH;\n        const degreeNumberV = this.degreeNumberV;\n        const width = this.width;\n        const height = this.height;\n        const rotateCoordinates = RotateCoordinates(angle, cx, cy);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path, 'evenodd');\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = 'black';\n        ctx.font = \"3mm serif\";\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n        ctx.beginPath();\n        const cmLen = 0.5 * cm;\n        const x = cx - width / 2;\n        const y = cy - height / 2;\n        const mmLen = cmLen * 0.6;\n        const halfCmLen = cmLen * 0.8;\n        for (let i = 0; i <= degreeNumberH; i++) {\n            const currentX = x + marginC + i * cm;\n            ctx.moveTo(...rotateCoordinates(currentX, y));\n            ctx.lineTo(...rotateCoordinates(currentX, y + cmLen));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(currentX, y + cmLen + mm));\n            ctx.rotate(angle * Math.PI / 180);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumberH) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmX = currentX + j * mm;\n                    ctx.moveTo(...rotateCoordinates(currentMmX, y));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + halfCmLen));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + mmLen));\n                    }\n                }\n            }\n        }\n        for (let i = 0; i <= degreeNumberV; i++) {\n            const currentY = y + marginC + i * cm;\n            ctx.moveTo(...rotateCoordinates(x, currentY));\n            ctx.lineTo(...rotateCoordinates(x + cmLen, currentY));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(x + cmLen + mm, currentY));\n            ctx.rotate(angle * Math.PI / 180 - Math.PI / 2);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumberV) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmY = currentY + j * mm;\n                    ctx.moveTo(...rotateCoordinates(x, currentMmY));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(x + halfCmLen, currentMmY));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(x + mmLen, currentMmY));\n                    }\n                }\n            }\n        }\n        ctx.stroke();\n        ctx.restore();\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Triangle.js.map","import { ShapeType } from '../enum';\nimport { generateCanvas } from '../utils';\nimport Ruler from './shape/Ruler';\nimport Compass from './shape/Compass';\nimport Compass360 from './shape/Compass360';\nimport Triangle from './shape/Triangle';\nexport default class ToolShape {\n    w;\n    h;\n    voice;\n    canvas;\n    ctx;\n    getNearestDistanceAndPointVoice;\n    outlineCtx;\n    outlineImageData;\n    outline;\n    outlineMap;\n    longestDistance = 30;\n    // 像素点采集宽度\n    gatherAreaWidth = 10;\n    prevPoint = null;\n    _x;\n    _y;\n    _angle;\n    _toolShapeType;\n    strokeStyle;\n    cm = 0;\n    mm = 0;\n    width = 0;\n    height = 0;\n    marginH = 0;\n    degreeNumber = 20;\n    ruler;\n    compass;\n    compass360;\n    rightAngleTriangle;\n    isoscelesTriangle;\n    constructor(w, h, voice, container, getPageCoords) {\n        this.w = w;\n        this.h = h;\n        this.voice = voice;\n        this.canvas = generateCanvas(w, h);\n        this.ctx = this.canvas.getContext('2d');\n        this.cm = 96 / 2.54;\n        this.mm = this.cm / 10;\n        this.getNearestDistanceAndPointVoice = voice;\n        this.ruler = new Ruler(this.ctx, this.cm, this.mm);\n        this.compass = new Compass(this.ctx, this.cm, this.mm);\n        this.compass360 = new Compass360(this.ctx, this.cm, this.mm, container, getPageCoords, this);\n        this.rightAngleTriangle = new Triangle(this.ctx, this.cm, this.mm, 9, 5, this.cm * 3, this.cm * 1);\n        this.isoscelesTriangle = new Triangle(this.ctx, this.cm, this.mm, 6, 6, this.cm * 2, this.cm * 2);\n    }\n    set x(x) {\n        this._x = x;\n        this.reset();\n    }\n    get x() {\n        return this._x;\n    }\n    set y(y) {\n        this._y = y;\n        this.reset();\n    }\n    get y() {\n        return this._y;\n    }\n    set angle(angle) {\n        this._angle = angle;\n        this.reset();\n    }\n    get angle() {\n        return this._angle;\n    }\n    set toolShapeType(toolShapeType) {\n        this._toolShapeType = toolShapeType;\n        this.reset();\n    }\n    get toolShapeType() {\n        return this._toolShapeType;\n    }\n    get shape() {\n        let shape;\n        switch (this.toolShapeType) {\n            case ShapeType.RULER:\n                shape = this.ruler;\n                break;\n            case ShapeType.COMPASS:\n                shape = this.compass;\n                break;\n            case ShapeType.COMPASS360:\n                shape = this.compass360;\n                break;\n            case ShapeType.RIGHT_ANGLE_TRIANGLE:\n                shape = this.rightAngleTriangle;\n                break;\n            case ShapeType.SOSCELESL_TRIANGLE:\n                shape = this.isoscelesTriangle;\n                break;\n            default: shape = this.ruler;\n        }\n        return shape;\n    }\n    reset() {\n        this.outline = null;\n        this.prevPoint = null;\n    }\n    getGathers(x1, y1, x2, y2, gatherAreaWidth) {\n        const topLeftX = Math.min(x1, x2) - gatherAreaWidth / 2;\n        const topLeftY = Math.min(y1, y2) - gatherAreaWidth / 2;\n        const bottomRightX = Math.max(x1, x2) + gatherAreaWidth / 2;\n        const bottomRightY = Math.max(y1, y2) + gatherAreaWidth / 2;\n        const gathers = [];\n        for (let x = topLeftX; x <= bottomRightX; x++) {\n            for (let y = topLeftY; y <= bottomRightY; y++) {\n                gathers.push([x, y]);\n            }\n        }\n        return gathers;\n    }\n    getNearestDistanceAndPoint(x, y, getNearestDistanceAndPointVoice, strokeStyle) {\n        if (!this.outline || getNearestDistanceAndPointVoice !== this.getNearestDistanceAndPointVoice || this.strokeStyle !== strokeStyle) {\n            this.getNearestDistanceAndPointVoice = getNearestDistanceAndPointVoice;\n            this.strokeStyle = strokeStyle;\n            this.outlineCtx = this.getOutlineCtx(this.getNearestDistanceAndPointVoice, strokeStyle);\n            this.outlineImageData = this.outlineCtx.getImageData(0, 0, this.w, this.h);\n            this.outline = this.getOutline(this.outlineImageData);\n            this.outlineMap = this.getOutlineMap(this.outline);\n        }\n        const outline = this.outline;\n        const len = outline.length;\n        let prevPoint = this.prevPoint;\n        const gatherAreaWidth = this.gatherAreaWidth;\n        if (!prevPoint) {\n            let nearestDistance = Number.MAX_SAFE_INTEGER;\n            for (let i = 0; i < len; i++) {\n                const [x0, y0] = outline[i];\n                const distance = ((x - x0) ** 2 + (y - y0) ** 2) ** 0.5;\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    prevPoint = [x0, y0];\n                }\n            }\n            this.prevPoint = prevPoint;\n            return { conformingToDistance: nearestDistance <= this.longestDistance, drawPoints: [] };\n        }\n        else {\n            const innerAreaPoints = [];\n            for (let i = 0; i < len; i++) {\n                const [x0, y0] = outline[i];\n                const gatherDistance = ((prevPoint[0] - x0) ** 2 + (prevPoint[1] - y0) ** 2) ** 0.5;\n                if (gatherDistance <= gatherAreaWidth) {\n                    innerAreaPoints.push(outline[i]);\n                }\n            }\n            let nearestDistance = Number.MAX_SAFE_INTEGER;\n            let gatherPoint = null;\n            for (let i = 0; i < innerAreaPoints.length; i++) {\n                const [x0, y0] = innerAreaPoints[i];\n                const distance = ((x - x0) ** 2 + (y - y0) ** 2) ** 0.5;\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    gatherPoint = [x0, y0];\n                }\n            }\n            let gathers = [];\n            if (gatherPoint) {\n                gathers = this.getGathers(prevPoint[0], prevPoint[1], gatherPoint[0], gatherPoint[1], gatherAreaWidth);\n            }\n            const drawPoints = [];\n            const gathersLen = gathers.length;\n            for (let i = 0; i < gathersLen; i++) {\n                const p = gathers[i];\n                const imageData = this.outlineMap?.[p[0]]?.[p[1]];\n                if (imageData) {\n                    const data = imageData;\n                    drawPoints.push({ x: p[0], y: p[1], fillStyle: `rgba(${data[0]},${data[1]},${data[2]},${data[3] / 255})` });\n                }\n            }\n            this.prevPoint = gatherPoint;\n            return { conformingToDistance: true, drawPoints };\n        }\n    }\n    getOutlineCtx(outlineVoice, strokeStyle) {\n        return this.shape.getOutlineCtx(this._x, this._y, this._angle, outlineVoice, strokeStyle);\n    }\n    getOutline(imageData) {\n        const data = imageData.data;\n        const len = data.length;\n        const outline = [];\n        let row = 0;\n        let column = -1;\n        for (let i = 0; i < len; i += 4) {\n            column++;\n            if (data[i + 3]) {\n                outline.push([column, row, data.slice(i, i + 4)]);\n            }\n            if (column === this.w - 1) {\n                row++;\n                column = -1;\n            }\n        }\n        return outline;\n    }\n    getOutlineMap(outline) {\n        const map = {};\n        const len = outline.length;\n        for (let i = 0; i < len; i++) {\n            const [x, y, uints] = outline[i];\n            if (!map[x]) {\n                map[x] = {};\n            }\n            map[x][y] = uints;\n        }\n        return map;\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.shape.isPointInPath(x, y, fillRule);\n    }\n    draw(x, y, angle, toolShapeType) {\n        if (this.x !== x || this.y !== y || this.angle !== angle || this.toolShapeType !== toolShapeType) {\n            this.x = x;\n            this.y = y;\n            this.angle = angle;\n            this.toolShapeType = toolShapeType;\n            const ctx = this.ctx;\n            ctx.clearRect(0, 0, this.w, this.h);\n            this.shape.draw(this._x, this._y, this._angle);\n        }\n    }\n}\n//# sourceMappingURL=ToolShape.js.map","import { rotateAngle, calculateRotatedPoint } from '../../utils';\nexport default class Compass {\n    ctx;\n    cm;\n    mm;\n    path;\n    r;\n    middleR;\n    smallR;\n    middleGap;\n    startAngle = 170;\n    endAngle = 370;\n    innerStartAngle = 180;\n    innerEndAngle = 360;\n    constructor(ctx, cm, mm) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.r = cm * 6;\n        this.middleR = cm * 3.5;\n        this.middleGap = cm * 1;\n        this.smallR = cm * 2.2;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const startAngle = this.startAngle;\n        const endAngle = this.endAngle;\n        const innerStartAngle = this.innerStartAngle;\n        const innerEndAngle = this.innerEndAngle;\n        const r = this.r + voice;\n        const middleInsideR = this.middleR + voice;\n        const middleOutsideR = middleInsideR + this.middleGap - voice;\n        const smallR = this.smallR - voice;\n        const cx = _cx;\n        const cy = _cy;\n        const innerCx = _cx;\n        const innerCy = _cy - voice;\n        const path = new Path2D();\n        path.arc(cx, cy, r, rotateAngle(startAngle, _angle), rotateAngle(endAngle, _angle));\n        path.closePath();\n        path.moveTo(...calculateRotatedPoint(innerCx, innerCy, middleOutsideR, innerStartAngle, _angle));\n        path.arc(innerCx, innerCy, middleOutsideR, rotateAngle(innerStartAngle, _angle), rotateAngle(innerEndAngle, _angle));\n        path.lineTo(...calculateRotatedPoint(innerCx, innerCy, middleInsideR, innerEndAngle, _angle));\n        path.arc(innerCx, innerCy, middleInsideR, rotateAngle(innerEndAngle, _angle), rotateAngle(innerStartAngle, _angle), true);\n        path.lineTo(...calculateRotatedPoint(innerCx, innerCy, middleOutsideR, innerStartAngle, _angle));\n        path.moveTo(...calculateRotatedPoint(innerCx, innerCy, smallR, innerStartAngle, _angle));\n        path.arc(innerCx, innerCy, smallR, rotateAngle(innerStartAngle, _angle), rotateAngle(innerEndAngle, _angle));\n        path.closePath();\n        this.path = path;\n        return path;\n    }\n    drawDegree(cx, cy, r, smallUnitL, unitL, bigUnitL, ruleFontSize, fontGap, showText, showSmall, showMiddle, textOnInner, _angle, reverse = false) {\n        const ctx = this.ctx;\n        // 刻度设置\n        const total = 180; // 总刻度数\n        const unitS = Math.PI / total; // 刻度线间隔角度\n        const unitBigInterval = 10;\n        const unitInterval = unitBigInterval;\n        const ruleLoose = 5;\n        // 绘制刻度和刻度的数值\n        let angle = (180 + _angle) * Math.PI / 180;\n        ctx.save();\n        ctx.textAlign = 'center'; // 设置文本对齐方式\n        ctx.textBaseline = 'middle';\n        ctx.font = `${ruleFontSize}px Arial`; // 文本字体\n        if (!textOnInner) {\n            r += bigUnitL;\n            ctx.textBaseline = 'bottom';\n        }\n        for (let i = 0; i <= total; i++) {\n            if (i % unitBigInterval === 0) { // 大刻度\n                const startX = cx + Math.cos(angle) * (r - bigUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - bigUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n                if (showText && i % unitInterval === 0) {\n                    const textX = cx + Math.cos(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置横坐标\n                    const textY = cy + Math.sin(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置纵坐标\n                    ctx.save();\n                    ctx.textAlign = 'center';\n                    ctx.translate(textX, textY);\n                    ctx.rotate(angle + Math.PI / 2);\n                    ctx.fillText((reverse ? total - i : i).toString(), 0, 0);\n                    ctx.restore();\n                }\n            }\n            else if (!(i % ruleLoose)) { // 中刻度\n                if (showMiddle) {\n                    const startX = cx + Math.cos(angle) * (r - unitL); // 刻度线起始点横坐标\n                    const startY = cy + Math.sin(angle) * (r - unitL); // 刻度线起始点纵坐标\n                    const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                    const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n            }\n            else if (showSmall) {\n                const startX = cx + Math.cos(angle) * (r - smallUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - smallUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n            }\n            angle += unitS; // 更新角度\n        }\n        ctx.restore();\n    }\n    drawContent(_cx, _cy, _angle) {\n        const r = this.r;\n        const middleR = this.middleR;\n        const smallR = this.smallR;\n        const cx = _cx;\n        const cy = _cy;\n        const ctx = this.ctx;\n        ctx.save();\n        this.drawDegree(cx, cy, r, 10, 15, 20, 8, 10, true, true, true, true, _angle);\n        this.drawDegree(cx, cy, middleR, 10, 12, 15, 0, 0, false, true, true, true, _angle);\n        this.drawDegree(cx, cy, smallR, 0, 0, 12, 7, 10, true, false, false, false, _angle, true);\n        ctx.restore();\n    }\n    drawPosition(cx, cy, angle) {\n        const r = 20;\n        const ctx = this.ctx;\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(cx, cy);\n        ctx.lineTo(...calculateRotatedPoint(cx, cy, r, 90, angle));\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.arc(cx, cy, r, rotateAngle(0, angle), rotateAngle(180, angle));\n        ctx.stroke();\n        ctx.restore();\n    }\n    draw(cx, cy, angle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path, 'evenodd');\n        ctx.restore();\n        this.drawContent(cx, cy, angle);\n        this.drawPosition(cx, cy, angle);\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Compass.js.map","import { BGPattern } from \"../enum\";\nimport { generateCanvas } from '../utils';\nexport default class Background {\n    width;\n    height;\n    gridGap;\n    gridFillStyle;\n    gridPaperGap;\n    gridPaperStrokeStyle;\n    quadrillePaperVerticalMargin;\n    quadrillePaperGap;\n    quadrillePaperStrokeStyles;\n    gridPattern;\n    gridPaperPattern;\n    quadrillePaperPattern;\n    bgPattern;\n    canvas;\n    ctx;\n    coordX;\n    coordY;\n    constructor(width, height, gridGap, gridFillStyle, gridPaperGap, gridPaperStrokeStyle, quadrillePaperVerticalMargin, quadrillePaperGap, quadrillePaperStrokeStyles) {\n        this.width = width;\n        this.height = height;\n        this.gridGap = gridGap;\n        this.gridFillStyle = gridFillStyle;\n        this.gridPaperGap = gridPaperGap;\n        this.gridPaperStrokeStyle = gridPaperStrokeStyle;\n        this.quadrillePaperVerticalMargin = quadrillePaperVerticalMargin;\n        this.quadrillePaperGap = quadrillePaperGap;\n        this.quadrillePaperStrokeStyles = quadrillePaperStrokeStyles;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n        this.gridPattern = this.generateGridPattern();\n        this.gridPaperPattern = this.generateGridPaperPattern();\n        this.quadrillePaperPattern = this.generateQuadrillePaperPattern();\n    }\n    draw(coordX, coordY, bgPattern) {\n        if (coordX !== this.coordX || coordY !== this.coordY || bgPattern !== this.bgPattern) {\n            this.coordX = coordX;\n            this.coordY = coordY;\n            this.bgPattern = bgPattern;\n            const ctx = this.ctx;\n            ctx.clearRect(0, 0, this.width + this.gridGap * 2, this.height + this.gridGap * 2);\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(coordX, coordY);\n            if (this.bgPattern === BGPattern.GRID) {\n                ctx.fillStyle = this.gridPattern;\n            }\n            else if (this.bgPattern === BGPattern.GRID_PAPER) {\n                ctx.fillStyle = this.gridPaperPattern;\n            }\n            else if (this.bgPattern === BGPattern.QUADRILLE_PAPER) {\n                ctx.fillStyle = this.quadrillePaperPattern;\n            }\n            ctx.fillRect(0, 0, this.width + this.gridGap * 2, this.height + this.gridGap * 2);\n            ctx.restore();\n        }\n    }\n    generateGridPattern() {\n        const gap = this.gridGap;\n        const bgOffscreen = new OffscreenCanvas(gap * 2, gap * 2);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        ctx.fillStyle = this.gridFillStyle;\n        ctx.fillRect(0, 0, gap, gap);\n        ctx.fillRect(gap, gap, gap, gap);\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n    generateGridPaperPattern() {\n        const gap = this.gridPaperGap;\n        const bgOffscreen = new OffscreenCanvas(gap, gap);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        ctx.strokeStyle = this.gridPaperStrokeStyle;\n        ctx.strokeRect(0, 0, gap, gap);\n        ctx.setLineDash([2, 2]);\n        ctx.beginPath();\n        ctx.moveTo(gap / 2, 0);\n        ctx.lineTo(gap / 2, gap);\n        ctx.moveTo(0, gap / 2);\n        ctx.lineTo(gap, gap / 2);\n        ctx.stroke();\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n    generateQuadrillePaperPattern() {\n        const quadrillePaperVerticalMargin = this.quadrillePaperVerticalMargin;\n        const gap = this.quadrillePaperGap;\n        const quadrillePaperStrokeStyles = this.quadrillePaperStrokeStyles;\n        const height = quadrillePaperVerticalMargin * 2 + gap * 3;\n        const bgOffscreen = new OffscreenCanvas(this.width, height);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        for (let i = 0; i < quadrillePaperStrokeStyles.length; i++) {\n            ctx.strokeStyle = quadrillePaperStrokeStyles[i];\n            ctx.beginPath();\n            ctx.moveTo(0, quadrillePaperVerticalMargin + gap * i);\n            ctx.lineTo(this.width, quadrillePaperVerticalMargin + gap * i);\n            ctx.stroke();\n        }\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n}\n//# sourceMappingURL=Background.js.map","import { negativeRemainder } from \"../utils\";\nimport { generateCanvas } from '../utils';\nexport default class RuleAuxiliary {\n    width;\n    height;\n    ruleStrokeStyle;\n    ruleGap;\n    ruleUnitLen;\n    canvas;\n    ctx;\n    worldOffsetX;\n    worldOffsetY;\n    constructor(width, height, ruleStrokeStyle, ruleGap, ruleUnitLen) {\n        this.width = width;\n        this.height = height;\n        this.ruleStrokeStyle = ruleStrokeStyle;\n        this.ruleGap = ruleGap;\n        this.ruleUnitLen = ruleUnitLen;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n    }\n    draw(worldOffsetX, worldOffsetY) {\n        if (worldOffsetX !== this.worldOffsetX || worldOffsetY !== this.worldOffsetY) {\n            this.worldOffsetX = worldOffsetX;\n            this.worldOffsetY = worldOffsetY;\n            const ctx = this.ctx;\n            ctx.beginPath();\n            ctx.clearRect(0, 0, this.width, this.height);\n            ctx.strokeStyle = this.ruleStrokeStyle;\n            ctx.font = \"12px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = this.ruleStrokeStyle;\n            const offsetX = negativeRemainder(this.worldOffsetX, (this.ruleGap * 10));\n            const offsetY = negativeRemainder(this.worldOffsetY, (this.ruleGap * 10));\n            const offsetXRule = (this.worldOffsetX - this.worldOffsetX % (this.ruleGap * 10)) / (this.ruleGap * 10) * 10;\n            const offsetYRule = (this.worldOffsetY - this.worldOffsetY % (this.ruleGap * 10)) / (this.ruleGap * 10) * 10;\n            let i = 0;\n            let j = 0;\n            let coordX = -offsetX;\n            let coordY = -offsetY;\n            const fontGap = 3;\n            while (coordX <= this.width) {\n                let len = this.ruleUnitLen;\n                if (!(i % 10)) {\n                    len = this.ruleUnitLen * 2.5;\n                }\n                else if (!(i % 5)) {\n                    len = this.ruleUnitLen * 1.5;\n                }\n                ctx.moveTo(coordX, 0);\n                ctx.lineTo(coordX, len);\n                ctx.moveTo(coordX, this.height);\n                ctx.lineTo(coordX, this.height - len);\n                if (!(i % 10)) {\n                    ctx.textBaseline = \"top\";\n                    ctx.fillText(String(i + offsetXRule), coordX, len + fontGap);\n                    ctx.textBaseline = \"bottom\";\n                    ctx.fillText(String(i + offsetXRule), coordX, this.height - len - fontGap);\n                }\n                coordX += this.ruleGap;\n                i++;\n            }\n            ctx.textBaseline = \"middle\";\n            while (coordY <= this.height) {\n                let len = this.ruleUnitLen;\n                if (!(j % 10)) {\n                    len = this.ruleUnitLen * 2.5;\n                }\n                else if (!(j % 5)) {\n                    len = this.ruleUnitLen * 1.5;\n                }\n                ctx.moveTo(0, coordY);\n                ctx.lineTo(len, coordY);\n                ctx.moveTo(this.width, coordY);\n                ctx.lineTo(this.width - len, coordY);\n                if (!(j % 10)) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(String(j + offsetYRule), len + fontGap, coordY);\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(String(j + offsetYRule), this.width - len - fontGap, coordY);\n                }\n                coordY += this.ruleGap;\n                j++;\n            }\n            ctx.stroke();\n        }\n    }\n}\n//# sourceMappingURL=RuleAuxiliary.js.map","import { generateCanvas } from '../utils';\nexport default class Border {\n    width;\n    height;\n    borderStyle;\n    borderWidth;\n    canvas;\n    ctx;\n    constructor(width, height, borderStyle, borderWidth) {\n        this.width = width;\n        this.height = height;\n        this.borderStyle = borderStyle;\n        this.borderWidth = borderWidth;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n        this.draw();\n    }\n    draw() {\n        const ctx = this.ctx;\n        ctx.strokeStyle = this.borderStyle;\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeRect(0, 0, this.width, this.height);\n    }\n}\n//# sourceMappingURL=Border.js.map","import { generateCanvas } from '../utils';\nexport default class Writing {\n    width;\n    height;\n    store = [];\n    canvas;\n    ctx;\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\n    }\n    refresh(worldOffsetX, worldOffsetY) {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        this.putImageData(worldOffsetX, worldOffsetY);\n    }\n    singlePointsWriting(points) {\n        const ctx = this.ctx;\n        const len = points.length;\n        for (let i = 0; i < len; i++) {\n            ctx.save();\n            ctx.beginPath();\n            const { x, y, fillStyle } = points[i];\n            ctx.fillStyle = fillStyle;\n            ctx.fillRect(x, y, 1, 1);\n            ctx.restore();\n        }\n    }\n    writing(points, color) {\n        this.ctx.save();\n        this.ctx.fillStyle = color;\n        this.ctx.beginPath();\n        const [[wx11, wy11], [wx12, wy12], [wx21, wy21], [wx22, wy22]] = points;\n        const x11 = wx11;\n        const y11 = wy11;\n        const x12 = wx12;\n        const y12 = wy12;\n        const x21 = wx21;\n        const y21 = wy21;\n        const x22 = wx22;\n        const y22 = wy22;\n        this.ctx.moveTo(x11, y11);\n        this.ctx.lineTo(x12, y12);\n        this.ctx.lineTo(x22, y22);\n        this.ctx.lineTo(x21, y21);\n        this.ctx.fill();\n        this.ctx.restore();\n    }\n    clear() {\n        this.store.length = 0;\n        this.doClean(0, 0, this.width, this.height);\n        this.pushImageData(0, 0);\n    }\n    doClean(x, y, width, height, determineIfThereHasContent = false) {\n        let hasContent = false;\n        if (determineIfThereHasContent) {\n            const imageData = this.ctx.getImageData(x, y, width, height);\n            const data = imageData.data;\n            const len = data.length;\n            for (let i = 0; i < len; i += 4) {\n                if (data[i + 3]) {\n                    hasContent = true;\n                    break;\n                }\n            }\n        }\n        this.ctx.clearRect(x, y, width, height);\n        return hasContent;\n    }\n    pushImageData(worldOffsetX, worldOffsetY) {\n        const imageData = this.ctx.getImageData(0, 0, this.width, this.height);\n        const store = this.store;\n        const len = store.length;\n        for (let i = len - 1; i >= 0; i--) {\n            const storeItem = store[i];\n            if (storeItem.worldOffsetX === worldOffsetX && storeItem.worldOffsetY === worldOffsetY) {\n                store.splice(i, 1);\n            }\n        }\n        store.push({\n            worldOffsetX,\n            worldOffsetY,\n            imageData\n        });\n    }\n    putImageData(worldOffsetX, worldOffsetY) {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        const displayData = new Uint8ClampedArray(total);\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            if (Math.abs(storeItemWorldOffsetX - worldOffsetX) >= width || Math.abs(storeItemWorldOffsetY - worldOffsetY) >= height) {\n                continue;\n            }\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - worldOffsetX + storeItemWorldOffsetX;\n                const displayRow = currentRow - worldOffsetY + storeItemWorldOffsetY;\n                if (displayCol >= 0\n                    &&\n                        displayRow >= 0\n                    &&\n                        displayCol < width\n                    &&\n                        displayRow < height) {\n                    const r = storeItemData[j];\n                    const g = storeItemData[j + 1];\n                    const b = storeItemData[j + 2];\n                    const a = storeItemData[j + 3];\n                    const displayJ = (displayCol + displayRow * width) * 4;\n                    displayData[displayJ] = r;\n                    displayData[displayJ + 1] = g;\n                    displayData[displayJ + 2] = b;\n                    displayData[displayJ + 3] = a;\n                }\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const displayImageData = new ImageData(displayData, width, height);\n        this.ctx.putImageData(displayImageData, 0, 0);\n    }\n    getWholeCanvas() {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        let minX;\n        let minY;\n        let maxX;\n        let maxY;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            if (minX === undefined || minX > storeItemWorldOffsetX) {\n                minX = storeItemWorldOffsetX;\n            }\n            if (minY === undefined || minY > storeItemWorldOffsetY) {\n                minY = storeItemWorldOffsetY;\n            }\n            if (maxX === undefined || maxX < storeItemWorldOffsetX) {\n                maxX = storeItemWorldOffsetX;\n            }\n            if (maxY === undefined || maxY < storeItemWorldOffsetY) {\n                maxY = storeItemWorldOffsetY;\n            }\n        }\n        const canvas = document.createElement('canvas');\n        if (minX === undefined || minY === undefined || maxX === undefined || maxY === undefined) {\n            canvas.width = 0;\n            canvas.height = 0;\n            return canvas;\n        }\n        maxX += width;\n        maxY += height;\n        const wholeWidth = (maxX - minX);\n        const wholeHeight = (maxY - minY);\n        const wholeTotal = wholeWidth * 4 * wholeHeight;\n        const displayData = new Uint8ClampedArray(wholeTotal);\n        let minPixelX = wholeWidth;\n        let minPixelY = wholeHeight;\n        let maxPixelX = 0;\n        let maxPixelY = 0;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - minX + storeItemWorldOffsetX;\n                const displayRow = currentRow - minY + storeItemWorldOffsetY;\n                const r = storeItemData[j];\n                const g = storeItemData[j + 1];\n                const b = storeItemData[j + 2];\n                const a = storeItemData[j + 3];\n                if (a !== 0) {\n                    if (displayCol < minPixelX) {\n                        minPixelX = displayCol;\n                    }\n                    if (displayRow < minPixelY) {\n                        minPixelY = displayRow;\n                    }\n                    if (displayCol > maxPixelX) {\n                        maxPixelX = displayCol;\n                    }\n                    if (displayRow > maxPixelY) {\n                        maxPixelY = displayRow;\n                    }\n                }\n                const displayJ = (displayCol + displayRow * wholeWidth) * 4;\n                displayData[displayJ] = r;\n                displayData[displayJ + 1] = g;\n                displayData[displayJ + 2] = b;\n                displayData[displayJ + 3] = a;\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const displayImageData = new ImageData(displayData, wholeWidth, wholeHeight);\n        const targetWidth = maxPixelX - minPixelX;\n        const targetHeight = maxPixelY - minPixelY;\n        canvas.width = targetWidth;\n        canvas.height = targetHeight;\n        const ctx = canvas.getContext('2d');\n        ctx.putImageData(displayImageData, -minPixelX, -minPixelY);\n        return canvas;\n    }\n    getPaperCanvas() {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        const minX = 0;\n        const minY = 0;\n        const maxX = width;\n        let maxY = 0;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            if (maxY === undefined || maxY < storeItemWorldOffsetY) {\n                maxY = storeItemWorldOffsetY;\n            }\n        }\n        maxY += height;\n        let maxPixelY = 0;\n        const canvas = document.createElement('canvas');\n        const wholeWidth = (maxX - minX);\n        const wholeHeight = (maxY - minY);\n        const wholeTotal = wholeWidth * 4 * wholeHeight;\n        const displayData = new Uint8ClampedArray(wholeTotal);\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - minX + storeItemWorldOffsetX;\n                const displayRow = currentRow - minY + storeItemWorldOffsetY;\n                if (displayCol >= minX\n                    &&\n                        displayRow >= minY\n                    &&\n                        displayCol < maxX\n                    &&\n                        displayRow < maxY) {\n                    const r = storeItemData[j];\n                    const g = storeItemData[j + 1];\n                    const b = storeItemData[j + 2];\n                    const a = storeItemData[j + 3];\n                    if (a !== 0) {\n                        if (displayRow > maxPixelY) {\n                            maxPixelY = displayRow;\n                        }\n                    }\n                    const displayJ = (displayCol + displayRow * wholeWidth) * 4;\n                    displayData[displayJ] = r;\n                    displayData[displayJ + 1] = g;\n                    displayData[displayJ + 2] = b;\n                    displayData[displayJ + 3] = a;\n                }\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const targetHeight = (Math.floor(maxPixelY / height) + 1) * height;\n        const displayImageData = new ImageData(displayData, maxX, maxY);\n        canvas.width = maxX;\n        canvas.height = targetHeight;\n        const ctx = canvas.getContext('2d');\n        ctx.putImageData(displayImageData, 0, 0);\n        return canvas;\n    }\n}\n//# sourceMappingURL=Writing.js.map","import { generateCanvas } from '../utils';\nexport default class Eraser {\n    width;\n    height;\n    canvas;\n    ctx;\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n    }\n    draw(cleanX, cleanY, cleanWidth, cleanHeight) {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.fillStyle = 'rgba(0,0,0,.1)';\n        this.ctx.strokeStyle = 'rgba(0,0,0,.15)';\n        this.ctx.rect(cleanX - cleanWidth / 2, cleanY - cleanHeight / 2, cleanWidth, cleanHeight);\n        this.ctx.fill();\n        this.ctx.stroke();\n        this.ctx.restore();\n        this.ctx.beginPath();\n    }\n}\n//# sourceMappingURL=Eraser.js.map","import { Stack } from './stack';\nimport { WriteModel, BGPattern, ScrollDirection, ShapeType } from './enum';\nimport { debounce, getTripleTouchAngleAndCenter, rotateCoordinate, negativeRemainder } from './utils';\nimport ToolShape from './component/ToolShape';\nimport Background from './component/Background';\nimport RuleAuxiliary from './component/RuleAuxiliary';\nimport Border from './component/Border';\nimport Writing from './component/Writing';\nimport Eraser from './component/Eraser';\nexport { WriteModel, BGPattern, ScrollDirection, ShapeType };\nfunction isTouchDevice() {\n    return 'ontouchstart' in self;\n}\n/**\n * 滚动范围\n */\nconst defaultScrollRange = [[null, null], [null, null]];\n/**\n * 滚动方向\n */\nconst defaultScrollDirection = ScrollDirection.ALL;\n/**\n * 背景格式\n */\nconst defaultBGPattern = BGPattern.GRID;\n/**\n * 是否启用全览模式\n */\n// const defaultEnableEagleEyeMode = false;\n/**\n * 绘画模式 书写模式 绘画模式\n */\nconst defaultWriteModel = WriteModel.WRITE;\n/**\n * 是否使用背景\n */\nconst defaultEnableBG = true;\n/**\n * 棋盘格子的间距\n */\nconst defaultGridGap = 100;\n/**\n * 田字格的尺寸\n */\nconst defaultGridPaperGap = 100;\n/**\n * 四线格纵向空白\n */\nconst defaultQuadrillePaperVerticalMargin = 40;\n/**\n * 四线格线的间距\n */\nconst defaultQuadrillePaperGap = 30;\n/**\n * 棋盘格子的填充色\n */\nconst defaultGridFillStyle = 'rgb(250,250,250)';\n/**\n * 田字格边框颜色\n */\nconst defaultGridPaperStrokeStyle = 'green';\n/**\n * 四线格四条线的颜色\n */\nconst defaultQuadrillePaperStrokeStyles = ['rgba(0,0,255,.5)', 'rgba(255,0,0,.5)', 'rgba(0,0,255,1)', 'rgba(0,0,255,.5)'];\n/**\n * 是否使用标尺\n */\nconst defaultRule = true;\n/**\n * 标尺的间距\n */\nconst defaultRuleGap = 10;\n/**\n * 标尺刻度的长度\n */\nconst defaultRuleUnitLen = 5;\n/**\n * 标尺的颜色\n */\nconst defaultRuleStrokeStyle = 'rgba(0,0,0,0.5)';\n/**\n * 笔尖的粗细\n */\nconst defaultVoice = 1;\n/**\n * 墨水颜色\n */\nconst defaultColor = 'rgb(0,0,0)';\n/**\n * 是否启用操作历史\n */\nconst defaultStack = true;\n/**\n * 橡皮擦除的宽度\n */\nconst defaultCleanWidth = 20;\n/**\n * 橡皮擦除的高度\n */\nconst defaultCleanHeight = 20;\n/**\n * 滚动的时候执行的次数\n */\nconst defaultMoveCountTotal = 20;\n/**\n * 是否锁定书写\n */\nconst defaultWriteLocked = false;\n/**\n * 是否锁定拖拽\n */\nconst defaultDragLocked = false;\n/**\n * 是否显示边框\n */\nconst defaultShowBorder = true;\n/**\n * 边框的颜色\n */\nconst defaultBorderStyle = '#333';\n/**\n * 边框的宽度\n */\nconst defaultBorderWidth = 2;\n/**\n * 是否使用尺子等工具\n */\nconst defaultUseShapeType = false;\nconst defaultOptions = {\n    scrollRange: defaultScrollRange,\n    scrollDirection: defaultScrollDirection,\n    bgPattern: defaultBGPattern,\n    writeModel: defaultWriteModel,\n    enableBG: defaultEnableBG,\n    gridGap: defaultGridGap,\n    gridPaperGap: defaultGridPaperGap,\n    quadrillePaperVerticalMargin: defaultQuadrillePaperVerticalMargin,\n    quadrillePaperGap: defaultQuadrillePaperGap,\n    gridFillStyle: defaultGridFillStyle,\n    gridPaperStrokeStyle: defaultGridPaperStrokeStyle,\n    quadrillePaperStrokeStyles: defaultQuadrillePaperStrokeStyles,\n    rule: defaultRule,\n    ruleGap: defaultRuleGap,\n    ruleUnitLen: defaultRuleUnitLen,\n    ruleStrokeStyle: defaultRuleStrokeStyle,\n    voice: defaultVoice,\n    color: defaultColor,\n    stack: defaultStack,\n    cleanWidth: defaultCleanWidth,\n    cleanHeight: defaultCleanHeight,\n    moveCountTotal: defaultMoveCountTotal,\n    writeLocked: defaultWriteLocked,\n    dragLocked: defaultDragLocked,\n    showBorder: defaultShowBorder,\n    borderStyle: defaultBorderStyle,\n    borderWidth: defaultBorderWidth,\n    useShapeType: defaultUseShapeType\n};\nexport default class Board {\n    container;\n    width;\n    height;\n    worldOffsetX = 0;\n    worldOffsetY = 0;\n    scrolling = false;\n    d = 1;\n    maxD = 2;\n    pointsGroup = [];\n    cleanState = false;\n    cleanX;\n    cleanY;\n    cleanPress = false;\n    stackObj;\n    minX;\n    minY;\n    moveT = false;\n    debounceBindOnChange;\n    prevPoints;\n    toolShape;\n    activateToolShape = false;\n    toolShapeCenterX;\n    toolShapeCenterY;\n    toolShapeAngle;\n    background;\n    ruleAuxiliary;\n    border;\n    writing;\n    eraser;\n    eraserHasContent = false;\n    toolShapeType = ShapeType.RULER;\n    scrollRange;\n    scrollDirection;\n    bgPattern;\n    writeModel;\n    enableBG;\n    gridGap;\n    gridPaperGap;\n    quadrillePaperVerticalMargin;\n    quadrillePaperGap;\n    gridFillStyle;\n    gridPaperStrokeStyle;\n    quadrillePaperStrokeStyles;\n    rule;\n    ruleGap;\n    ruleUnitLen;\n    ruleStrokeStyle;\n    voice;\n    color;\n    cleanWidth;\n    cleanHeight;\n    stack;\n    moveCountTotal;\n    writeLocked;\n    dragLocked;\n    showBorder;\n    borderStyle;\n    borderWidth;\n    useShapeType;\n    containerOffset;\n    onChange;\n    constructor(container, options = defaultOptions) {\n        this.container = container;\n        this.scrollRange = options.scrollRange ?? defaultScrollRange;\n        this.scrollDirection = options.scrollDirection ?? defaultScrollDirection;\n        this.bgPattern = options.bgPattern ?? defaultBGPattern;\n        this.writeModel = options.writeModel ?? defaultWriteModel;\n        this.enableBG = options.enableBG ?? defaultEnableBG;\n        this.gridGap = options.gridGap ?? defaultGridGap;\n        this.gridPaperGap = options.gridPaperGap ?? defaultGridPaperGap;\n        this.quadrillePaperVerticalMargin = options.quadrillePaperVerticalMargin ?? defaultQuadrillePaperVerticalMargin;\n        this.quadrillePaperGap = options.quadrillePaperGap ?? defaultQuadrillePaperGap;\n        this.gridFillStyle = options.gridFillStyle ?? defaultGridFillStyle;\n        this.gridPaperStrokeStyle = options.gridPaperStrokeStyle ?? defaultGridPaperStrokeStyle;\n        this.quadrillePaperStrokeStyles = options.quadrillePaperStrokeStyles ?? defaultQuadrillePaperStrokeStyles;\n        this.rule = options.rule ?? defaultRule;\n        this.ruleGap = options.ruleGap ?? defaultRuleGap;\n        this.ruleUnitLen = options.ruleUnitLen ?? defaultRuleUnitLen;\n        this.ruleStrokeStyle = options.ruleStrokeStyle ?? defaultRuleStrokeStyle;\n        this.voice = options.voice ?? defaultVoice;\n        this.color = options.color ?? defaultColor;\n        this.stack = options.stack ?? defaultStack;\n        this.cleanWidth = options.cleanWidth ?? defaultCleanWidth;\n        this.cleanHeight = options.cleanHeight ?? defaultCleanHeight;\n        this.moveCountTotal = options.moveCountTotal ?? defaultMoveCountTotal;\n        this.writeLocked = options.writeLocked ?? defaultWriteLocked;\n        this.dragLocked = options.dragLocked ?? defaultDragLocked;\n        this.showBorder = options.showBorder ?? defaultShowBorder;\n        this.borderStyle = options.borderStyle ?? defaultBorderStyle;\n        this.borderWidth = options.borderWidth ?? defaultBorderWidth;\n        this.useShapeType = options.useShapeType ?? defaultUseShapeType;\n        this.containerOffset = options.containerOffset ?? (() => {\n            const scrollingElement = document.scrollingElement;\n            const rect = this.container.getBoundingClientRect();\n            return {\n                x: rect.x + scrollingElement.scrollLeft,\n                y: rect.y + scrollingElement.scrollTop\n            };\n        });\n        this.onChange = options.onChange;\n        this.debounceBindOnChange = debounce(this.triggerOnChange, 500);\n        const rect = container.getBoundingClientRect();\n        this.width = rect.width;\n        this.height = rect.height;\n        if (this.stack) {\n            this.stackObj = new Stack(this.width, this.height);\n            this.stackObj.restoreState = (store) => {\n                const storeLen = store.length;\n                const lastStoreItem = store[storeLen - 1];\n                const prevWorldOffsetX = this.worldOffsetX;\n                const prevWorldOffsetY = this.worldOffsetY;\n                const targetWorldOffsetX = lastStoreItem.worldOffsetX;\n                const targetWorldOffsetY = lastStoreItem.worldOffsetY;\n                const offsetX = targetWorldOffsetX - prevWorldOffsetX;\n                const offsetY = targetWorldOffsetY - prevWorldOffsetY;\n                if (!offsetX && !offsetY) {\n                    this.worldOffsetX = lastStoreItem.worldOffsetX;\n                    this.worldOffsetY = lastStoreItem.worldOffsetY;\n                    this.writing.store = store;\n                    this.draw();\n                }\n                else {\n                    const preOffsetX = offsetX / this.moveCountTotal;\n                    const preOffsetY = offsetY / this.moveCountTotal;\n                    this.writing.store = store;\n                    this.moveT = true;\n                    this.doMove(preOffsetX, preOffsetY);\n                }\n            };\n        }\n        this.background = new Background(this.width, this.height, this.gridGap, this.gridFillStyle, this.gridPaperGap, this.gridPaperStrokeStyle, this.quadrillePaperVerticalMargin, this.quadrillePaperGap, this.quadrillePaperStrokeStyles);\n        this.container.append(this.background.canvas);\n        this.ruleAuxiliary = new RuleAuxiliary(this.width, this.height, this.ruleStrokeStyle, this.ruleGap, this.ruleUnitLen);\n        this.container.append(this.ruleAuxiliary.canvas);\n        this.border = new Border(this.width, this.height, this.borderStyle, this.borderWidth);\n        this.container.append(this.border.canvas);\n        this.writing = new Writing(this.width, this.height);\n        this.container.append(this.writing.canvas);\n        this.toolShape = new ToolShape(this.width, this.height, this.voice, container, this.getPageCoords);\n        this.container.append(this.toolShape.canvas);\n        this.toolShapeCenterX = 500;\n        this.toolShapeCenterY = 300;\n        this.toolShapeAngle = 10;\n        this.eraser = new Eraser(this.width, this.height);\n        this.container.append(this.eraser.canvas);\n        this.loadEvent();\n        this.draw();\n    }\n    setVoice(voice = 1) {\n        this.voice = voice;\n        this.d = voice;\n        this.maxD = voice * 2;\n    }\n    showBG() {\n        this.enableBG = true;\n        this.draw();\n    }\n    hideBG() {\n        this.enableBG = false;\n        this.draw();\n    }\n    showRule() {\n        this.rule = true;\n        this.draw();\n    }\n    hideRule() {\n        this.rule = false;\n        this.draw();\n    }\n    showToolShape() {\n        this.useShapeType = true;\n        this.draw();\n    }\n    hideToolShape() {\n        this.useShapeType = false;\n        this.draw();\n    }\n    setToolShapeType(shapeType) {\n        this.toolShapeType = shapeType;\n        this.draw();\n    }\n    adjustOffset() {\n        const [[minX, maxX], [minY, maxY]] = this.scrollRange;\n        if (typeof minX === 'number') {\n            this.worldOffsetX = Math.max(minX, this.worldOffsetX);\n        }\n        if (typeof maxX === 'number') {\n            this.worldOffsetX = Math.min(maxX, this.worldOffsetX);\n        }\n        if (typeof minY === 'number') {\n            this.worldOffsetY = Math.max(minY, this.worldOffsetY);\n        }\n        if (typeof maxY === 'number') {\n            this.worldOffsetY = Math.min(maxY, this.worldOffsetY);\n        }\n        this.worldOffsetX = Math.round(this.worldOffsetX);\n        this.worldOffsetY = Math.round(this.worldOffsetY);\n    }\n    doMove(preOffsetX, preOffsetY, i = 0) {\n        if (this.scrollDirection === ScrollDirection.ALL) {\n            this.worldOffsetX += preOffsetX;\n            this.worldOffsetY += preOffsetY;\n        }\n        else if (this.scrollDirection === ScrollDirection.X) {\n            this.worldOffsetX += preOffsetX;\n        }\n        else if (this.scrollDirection === ScrollDirection.Y) {\n            this.worldOffsetY += preOffsetY;\n        }\n        this.adjustOffset();\n        this.draw();\n        self.requestAnimationFrame(() => {\n            if (this.moveT && i < this.moveCountTotal) {\n                this.doMove(preOffsetX, preOffsetY, ++i);\n            }\n            else {\n                this.moveT = false;\n            }\n        });\n    }\n    scrollBy(x = 0, y = 0) {\n        if (!this.dragLocked) {\n            const preOffsetX = x / this.moveCountTotal;\n            const preOffsetY = y / this.moveCountTotal;\n            this.moveT = true;\n            this.doMove(preOffsetX, preOffsetY);\n        }\n    }\n    clear() {\n        this.worldOffsetX = 0;\n        this.worldOffsetY = 0;\n        this.writing.clear();\n        this.draw();\n        this.stackObj.saveState([...this.writing.store]);\n    }\n    triggerOnChange() {\n        window.requestIdleCallback(() => {\n            if (this.onChange) {\n                const canvas = this.exportAsCanvas();\n                this.onChange(canvas);\n            }\n        });\n    }\n    drawPureCanvas(ctx, crop = true) {\n        this.pointsGroup?.forEach(({ corners, fillStyle }) => {\n            corners.forEach(([[wx11, wy11], [wx12, wy12], [wx21, wy21], [wx22, wy22]]) => {\n                let x11 = wx11;\n                let y11 = wy11;\n                let x12 = wx12;\n                let y12 = wy12;\n                let x21 = wx21;\n                let y21 = wy21;\n                let x22 = wx22;\n                let y22 = wy22;\n                if (crop) {\n                    x11 = wx11 - this.minX;\n                    y11 = wy11 - this.minY;\n                    x12 = wx12 - this.minX;\n                    y12 = wy12 - this.minY;\n                    x21 = wx21 - this.minX;\n                    y21 = wy21 - this.minY;\n                    x22 = wx22 - this.minX;\n                    y22 = wy22 - this.minY;\n                }\n                ctx.save();\n                ctx.fillStyle = fillStyle;\n                ctx.beginPath();\n                ctx.moveTo(x11, y11);\n                ctx.lineTo(x12, y12);\n                ctx.lineTo(x22, y22);\n                ctx.lineTo(x21, y21);\n                ctx.fill();\n                ctx.restore();\n            });\n        });\n    }\n    exportAsCanvas() {\n        return this.writing.getWholeCanvas();\n    }\n    exportAsPaperCanvas() {\n        const imageCanvas = this.writing.getPaperCanvas();\n        const canvas = document.createElement('canvas');\n        canvas.width = imageCanvas.width;\n        canvas.height = imageCanvas.height;\n        const ctx = canvas.getContext('2d');\n        if (this.enableBG) {\n            this.loadBackground(ctx);\n        }\n        ctx.drawImage(imageCanvas, 0, 0);\n        return canvas;\n    }\n    undo() {\n        this.stackObj.undo();\n    }\n    redo() {\n        this.stackObj.redo();\n    }\n    clean() {\n        this.cleanState = true;\n    }\n    unclean() {\n        this.cleanState = false;\n    }\n    draw() {\n        this.loadBackground();\n        this.loadRule();\n        this.writing.refresh(this.worldOffsetX, this.worldOffsetY);\n        this.drawEraser();\n        this.drawToolShape();\n        this.debounceBindOnChange();\n    }\n    loadEvent() {\n        let hasMoved = false;\n        let hasWrited = false;\n        let isDoubleTouch = false;\n        let isToolShapeDoubleTouch = false;\n        let rotationCenter;\n        let turnStartAngle = 0;\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragStartTime = 0;\n        let dragEndX = 0;\n        let dragEndY = 0;\n        let dragEndTime = 0;\n        let needPushPoints = false;\n        let isSingleTouch = false;\n        let writeStartX = 0;\n        let writeStartY = 0;\n        let writeStartTime = 0;\n        let writeEndX = 0;\n        let writeEndY = 0;\n        let writeEndTime = 0;\n        const handleWriteStart = (coords) => {\n            hasMoved = false;\n            hasWrited = false;\n            isSingleTouch = true;\n            needPushPoints = true;\n            let conformingToDistance = false;\n            if (this.useShapeType) {\n                const distanceAndPoint = this.toolShape.getNearestDistanceAndPoint(coords.pageX, coords.pageY, this.voice, this.color);\n                conformingToDistance = distanceAndPoint.conformingToDistance;\n            }\n            if (!this.cleanState && conformingToDistance) {\n                this.activateToolShape = true;\n            }\n            else {\n                if (!this.cleanState && this.useShapeType && this.toolShape.isPointInPath(coords.pageX, coords.pageY, 'evenodd')) {\n                    isSingleTouch = false;\n                }\n                this.activateToolShape = false;\n                writeEndX = coords.pageX;\n                writeEndY = coords.pageY;\n            }\n            writeEndTime = performance.now();\n            if (this.cleanState) {\n                this.cleanX = writeEndX;\n                this.cleanY = writeEndY;\n                this.cleanPress = true;\n                this.drawEraser();\n            }\n        };\n        const handleTouchStart = (event) => {\n            this.moveT = false;\n            this.scrolling = false;\n            const touches = event.touches;\n            const coords = this.getPageCoords(touches);\n            if (touches.length === 2) {\n                isDoubleTouch = true;\n                isSingleTouch = false;\n                if (this.dragLocked) {\n                    return;\n                }\n                dragEndX = coords.pageX;\n                dragEndY = coords.pageY;\n                dragEndTime = performance.now();\n                if (this.cleanState) {\n                    this.cleanPress = false;\n                    this.draw();\n                }\n                let isPointInPath = false;\n                if (this.useShapeType && this.toolShape.isPointInPath(coords.pageX, coords.pageY, 'nonzero')) {\n                    isPointInPath = true;\n                }\n                if (isPointInPath) {\n                    isToolShapeDoubleTouch = true;\n                    rotationCenter = { x: coords.pageX, y: coords.pageY };\n                }\n                else {\n                    isToolShapeDoubleTouch = false;\n                }\n            }\n            else if (touches.length === 1) {\n                if (!this.writeLocked) {\n                    handleWriteStart(coords);\n                }\n            }\n        };\n        const handleMouseStart = (event) => {\n            event.preventDefault();\n            if (!this.writeLocked) {\n                const { pageX, pageY } = event;\n                const coords = this.getPageCoords([{ pageX, pageY }]);\n                handleWriteStart(coords);\n            }\n        };\n        const doInsertPointByToolShape = (nearestPoints) => {\n            this.writing.singlePointsWriting(nearestPoints);\n        };\n        const doInsertPoint = (writeStartX, writeStartY, writeEndX, writeEndY) => {\n            if (needPushPoints) {\n                this.prevPoints = null;\n                needPushPoints = false;\n            }\n            const points = this.pushPoints(writeStartX, writeStartY, writeEndX, writeEndY, writeStartTime, writeEndTime);\n            if (points) {\n                this.prevPoints = points;\n                this.doWriting(points);\n                this.debounceBindOnChange();\n            }\n        };\n        const handleWriteMove = (coords) => {\n            hasMoved = true;\n            hasWrited = true;\n            writeStartX = writeEndX;\n            writeStartY = writeEndY;\n            writeStartTime = writeEndTime;\n            writeEndX = coords.pageX;\n            writeEndY = coords.pageY;\n            writeEndTime = performance.now();\n            if (this.cleanState) {\n                this.cleanX = writeEndX;\n                this.cleanY = writeEndY;\n                this.doClean(writeEndX, writeEndY);\n                this.drawEraser();\n            }\n            else {\n                if (this.useShapeType && this.activateToolShape) {\n                    const lineWidth = this.voice;\n                    const { drawPoints } = this.toolShape.getNearestDistanceAndPoint(coords.pageX, coords.pageY, lineWidth, this.color);\n                    doInsertPointByToolShape(drawPoints);\n                }\n                else {\n                    doInsertPoint(writeStartX, writeStartY, writeEndX, writeEndY);\n                }\n            }\n        };\n        const handleMouseMove = (event) => {\n            if (isSingleTouch) {\n                const { pageX, pageY } = event;\n                const coords = this.getPageCoords([{ pageX, pageY }]);\n                handleWriteMove(coords);\n            }\n        };\n        const handleTouchMove = (event) => {\n            const touches = event.touches;\n            if (isDoubleTouch) {\n                if (this.dragLocked) {\n                    return;\n                }\n                dragStartX = dragEndX;\n                dragStartY = dragEndY;\n                dragStartTime = dragEndTime;\n                const coords = this.getPageCoords(touches);\n                dragEndX = coords.pageX;\n                dragEndY = coords.pageY;\n                dragEndTime = performance.now();\n                if (this.useShapeType && isToolShapeDoubleTouch) {\n                    const deltaX = dragEndX - dragStartX;\n                    const deltaY = dragEndY - dragStartY;\n                    this.toolShapeCenterX += deltaX;\n                    this.toolShapeCenterY += deltaY;\n                    if (event.touches.length === 2) {\n                        const { angle } = getTripleTouchAngleAndCenter(event);\n                        let deltaAngle = angle - turnStartAngle;\n                        deltaAngle %= 30;\n                        turnStartAngle = angle;\n                        const [newX, newY] = rotateCoordinate(rotationCenter.x, rotationCenter.y, deltaAngle, this.toolShapeCenterX, this.toolShapeCenterY);\n                        this.toolShapeCenterX = newX;\n                        this.toolShapeCenterY = newY;\n                        this.toolShapeAngle += deltaAngle;\n                        this.draw();\n                    }\n                }\n                else {\n                    let deltaX = 0;\n                    let deltaY = 0;\n                    if (this.scrollDirection === ScrollDirection.ALL) {\n                        deltaX = dragEndX - dragStartX;\n                        deltaY = dragEndY - dragStartY;\n                    }\n                    else if (this.scrollDirection === ScrollDirection.X) {\n                        deltaX = dragEndX - dragStartX;\n                    }\n                    else if (this.scrollDirection === ScrollDirection.Y) {\n                        deltaY = dragEndY - dragStartY;\n                    }\n                    this.worldOffsetX -= deltaX;\n                    this.worldOffsetY -= deltaY;\n                    this.adjustOffset();\n                    this.draw();\n                }\n            }\n            else if (isSingleTouch) {\n                const coords = this.getPageCoords(touches);\n                handleWriteMove(coords);\n            }\n        };\n        const scrollDecay = (speedX, speedY) => {\n            this.scrolling = true;\n            const minSpeed = 0.1;\n            let t = 0;\n            const _scrollDecay = (speedX, speedY) => {\n                if (Math.abs(speedX) > minSpeed || Math.abs(speedY) > minSpeed) {\n                    this.worldOffsetX -= speedX;\n                    this.worldOffsetY -= speedY;\n                    this.adjustOffset();\n                    this.draw();\n                    const ratio = Math.max((99 - 0.01 * t++), 50) / 100;\n                    speedX = ratio * speedX;\n                    speedY = ratio * speedY;\n                    self.requestAnimationFrame(() => {\n                        if (this.scrolling) {\n                            _scrollDecay(speedX, speedY);\n                        }\n                    });\n                }\n                else {\n                    this.scrolling = false;\n                }\n            };\n            _scrollDecay(speedX, speedY);\n        };\n        const handleWriteEnd = (coords) => {\n            if (isDoubleTouch) {\n                if (this.dragLocked) {\n                    return;\n                }\n                const deltaX = dragEndX - dragStartX;\n                const deltaY = dragEndY - dragStartY;\n                const deltaTime = dragEndTime - dragStartTime;\n                let speedX = 0;\n                let speedY = 0;\n                if (this.scrollDirection === ScrollDirection.ALL) {\n                    speedX = deltaX / deltaTime;\n                    speedY = deltaY / deltaTime;\n                }\n                else if (this.scrollDirection === ScrollDirection.X) {\n                    speedX = deltaX / deltaTime;\n                }\n                else if (this.scrollDirection === ScrollDirection.Y) {\n                    speedY = deltaY / deltaTime;\n                }\n                if (!isToolShapeDoubleTouch) {\n                    scrollDecay(speedX, speedY);\n                }\n            }\n            else if (isSingleTouch) {\n                if (!hasMoved) {\n                    handleWriteMove(coords);\n                }\n                if (!this.cleanState || this.eraserHasContent) {\n                    this.eraserHasContent = false;\n                    this.writing.pushImageData(this.worldOffsetX, this.worldOffsetY);\n                    if (this.stack && hasWrited) {\n                        this.stackObj.saveState(this.writing.store);\n                    }\n                }\n            }\n            if (this.cleanState) {\n                this.cleanPress = false;\n                this.draw();\n            }\n            isDoubleTouch = false;\n            isSingleTouch = false;\n            this.toolShape.prevPoint = null;\n        };\n        const handleTouchEnd = (event) => {\n            const touches = event.changedTouches;\n            const coords = this.getPageCoords(touches);\n            handleWriteEnd(coords);\n        };\n        const handleMouseEnd = (event) => {\n            const { pageX, pageY } = event;\n            const coords = this.getPageCoords([{ pageX, pageY }]);\n            handleWriteEnd(coords);\n        };\n        const container = this.container;\n        if (isTouchDevice()) {\n            container.addEventListener(\"touchstart\", handleTouchStart, { passive: true });\n            container.addEventListener(\"touchmove\", handleTouchMove, { passive: true });\n            container.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\n        }\n        else {\n            container.addEventListener(\"mousedown\", handleMouseStart);\n            self.addEventListener(\"mousemove\", handleMouseMove, { passive: true });\n            self.addEventListener(\"mouseup\", handleMouseEnd, { passive: true });\n        }\n    }\n    getPageCoords = (touches) => {\n        const { x: containerX, y: containerY } = this.containerOffset();\n        const length = touches.length;\n        let totalX = 0;\n        let totalY = 0;\n        for (let i = 0; i < length; i++) {\n            const touch = touches[i];\n            totalX += touch.pageX - containerX;\n            totalY += touch.pageY - containerY;\n        }\n        totalX /= length;\n        totalY /= length;\n        return { pageX: totalX, pageY: totalY };\n    };\n    drawEraser() {\n        if (this.cleanState && this.cleanPress) {\n            this.eraser.draw(this.cleanX, this.cleanY, this.cleanWidth, this.cleanHeight);\n        }\n        this.eraser.canvas.style.opacity = (this.cleanState && this.cleanPress) ? '1' : '0';\n    }\n    doClean(writeEndX, writeEndY) {\n        const hasContent = this.writing.doClean(writeEndX - this.cleanWidth / 2, writeEndY - this.cleanHeight / 2, this.cleanWidth, this.cleanHeight, true);\n        if (hasContent) {\n            this.eraserHasContent = true;\n        }\n    }\n    getCornerCoordinate(a, b, c, d, x, y) {\n        return [\n            [x - b * d / Math.sqrt(a ** 2 + b ** 2), y + a * d / Math.sqrt(a ** 2 + b ** 2)],\n            [x + b * d / Math.sqrt(a ** 2 + b ** 2), y - a * d / Math.sqrt(a ** 2 + b ** 2)]\n        ];\n    }\n    getCornersCoordinate(x1, y1, x2, y2, d) {\n        const a = x2 - x1;\n        const b = y2 - y1;\n        const c = a * x1 + b * y1 + d * Math.sqrt(a ** 2 + b ** 2);\n        const [[x11, y11], [x12, y12]] = this.getCornerCoordinate(a, b, c, d, x1, y1);\n        const [[x21, y21], [x22, y22]] = this.getCornerCoordinate(a, b, c, d, x2, y2);\n        return [[x11, y11], [x12, y12], [x21, y21], [x22, y22]];\n    }\n    pushPoints(writeStartX, writeStartY, writeEndX, writeEndY, writeStartTime, writeEndTime) {\n        const x1 = writeStartX;\n        const y1 = writeStartY;\n        const x2 = writeEndX;\n        const y2 = writeEndY;\n        const distance = ((y2 - y1) ** 2 + (x2 - x1) ** 2) ** 0.5;\n        const originD = (writeEndTime - writeStartTime) / distance * this.voice;\n        if (!isNaN(originD)) {\n            if (this.writeModel === WriteModel.WRITE) {\n                if (originD > this.d * 1.2) {\n                    this.d *= 1.2;\n                }\n                else if (originD < this.d / 1.2) {\n                    this.d /= 1.2;\n                }\n                else {\n                    this.d = originD;\n                }\n                if (this.d > this.maxD) {\n                    this.d = this.maxD;\n                }\n            }\n            else if (this.writeModel === WriteModel.DRAW) {\n                this.d = this.voice;\n            }\n            const points = this.getCornersCoordinate(x1, y1, x2, y2, this.d);\n            const hasNaN = points.flat().some(xy => {\n                return isNaN(xy);\n            });\n            if (!hasNaN) {\n                if (this.prevPoints) {\n                    points[0] = this.prevPoints[2];\n                    points[1] = this.prevPoints[3];\n                }\n                return points;\n            }\n            else if (!distance) {\n                let d = this.voice;\n                if (this.writeModel === WriteModel.WRITE) {\n                    let rate = (writeEndTime - writeStartTime) / 250;\n                    if (rate > 2) {\n                        rate = 2;\n                    }\n                    else if (rate < 1) {\n                        rate = 1;\n                    }\n                    d = this.voice * rate;\n                }\n                const points = [\n                    [x1 - d, y1 - d],\n                    [x1 - d, y1 + d],\n                    [x1 + d, y1 - d],\n                    [x1 + d, y1 + d]\n                ];\n                return points;\n            }\n        }\n    }\n    doWriting(points) {\n        this.writing.writing(points, this.color);\n    }\n    loadBackground(ctx = null) {\n        let coordX = 0;\n        let coordY = 0;\n        let background;\n        if (!ctx) {\n            const offsetX = negativeRemainder(this.worldOffsetX, this.gridGap * 2);\n            const offsetY = negativeRemainder(this.worldOffsetY, this.gridGap * 2);\n            coordX = -offsetX;\n            coordY = -offsetY;\n            background = this.background;\n        }\n        else {\n            const canvas = ctx.canvas;\n            const { width, height } = canvas;\n            background = new Background(width, height, this.gridGap, this.gridFillStyle, this.gridPaperGap, this.gridPaperStrokeStyle, this.quadrillePaperVerticalMargin, this.quadrillePaperGap, this.quadrillePaperStrokeStyles);\n        }\n        if (this.enableBG) {\n            background.draw(coordX, coordY, this.bgPattern);\n            if (ctx) {\n                ctx.drawImage(background.canvas, 0, 0);\n            }\n        }\n        background.canvas.style.opacity = this.enableBG ? '1' : '0';\n    }\n    loadRule() {\n        if (this.rule) {\n            this.ruleAuxiliary.draw(this.worldOffsetX, this.worldOffsetY);\n        }\n        this.ruleAuxiliary.canvas.style.opacity = this.rule ? '1' : '0';\n    }\n    drawToolShape() {\n        if (this.useShapeType) {\n            this.toolShape.draw(this.toolShapeCenterX, this.toolShapeCenterY, this.toolShapeAngle, this.toolShapeType);\n        }\n        this.toolShape.canvas.style.opacity = this.useShapeType ? '1' : '0';\n    }\n}\nexport { Board };\n//# sourceMappingURL=index.js.map"],"names":["Stack","width","height","undoStack","redoStack","constructor","this","restoreState","saveState","store","push","length","undo","lastState","pop","previousState","data","Uint8ClampedArray","worldOffsetX","worldOffsetY","imageData","ImageData","doRestoreState","redo","nextState","WriteModel","BGPattern","ScrollDirection","ShapeType","RotateCoordinates","angle","x0","y0","angleInRadians","Math","PI","cosAngle","cos","sinAngle","sin","x","y","x1","y1","rotateAngle","angle0","calculateRotatedPoint","rx","ry","r","_angle","angleRad","_angleRad","negativeRemainder","a","b","generateCanvas","canvas","document","createElement","Object","assign","style","left","top","position","exports","Ruler","ctx","cm","mm","path","marginH","degreeNumber","getOutlineCtx","_x","_y","outlineVoice","strokeStyle","c","OffscreenCanvas","getContext","generatorOuterBorder","lineWidth","stroke","_cx","_cy","voice","rotateCoordinates","pathStr","join","offestX","beginWaveX","beginWaveY","endWaveX","waveUnit","waveUnitY","waveY","currentWaveUnit","Path2D","draw","cx","cy","clearRect","save","beginPath","fillStyle","fill","restore","font","textAlign","textBaseline","cmLen","textPos","mmLen","halfCmLen","i","currentX","moveTo","lineTo","translate","rotate","fillText","String","j","currentMmX","isPointInPath","fillRule","Compass","container","getPageCoords","toolShape","outsideR","insideR","pointerW","startAngle","endAngle","firstPointerAngle","secondPointerAngle","pointer1","pointer2","loadEvent","calculateRotationAngle","dragStartX","dragStartY","dragEndX","dragEndY","aX","aY","bX","bY","cosTheta","sqrt","theta","acos","doTurn","movePointer1","movePointer2","turnPoinerStart","coords","event","pageX","pageY","stopImmediatePropagation","handleTouchStart","touches","handleMouseStart","preventDefault","turnPointerMove","deltaAngle","reset","handleMouseMove","handleTouchMove","turnPointerEnd","handleTouchEnd","handleMouseEnd","self","addEventListener","passive","drawBorder","drawPointer","globalCompositeOperation","offscreen1","c2","drawImage","fillRect","arc","generatorPointer","pointerAngle","drawDegree","smallUnitL","unitL","bigUnitL","ruleFontSize","fontGap","showText","showSmall","showMiddle","showBig","textOnInner","reverse","total","unitS","startX","startY","endX","endY","textX","Number","textY","toString","drawContent","drawFixedPoint","isPointInStroke","Triangle","degreeNumberH","degreeNumberV","marginV","marginC","gap","closePath","smallX","smallY","smallWidth","smallHeight","currentY","currentMmY","ToolShape","w","h","getNearestDistanceAndPointVoice","outlineCtx","outlineImageData","outline","outlineMap","longestDistance","gatherAreaWidth","prevPoint","_toolShapeType","ruler","compass","compass360","rightAngleTriangle","isoscelesTriangle","middleR","smallR","middleGap","innerStartAngle","innerEndAngle","middleInsideR","middleOutsideR","innerCx","innerCy","drawPosition","Compass360","toolShapeType","shape","RULER","COMPASS","COMPASS360","RIGHT_ANGLE_TRIANGLE","SOSCELESL_TRIANGLE","getGathers","x2","y2","topLeftX","min","topLeftY","bottomRightX","max","bottomRightY","gathers","getNearestDistanceAndPoint","getImageData","getOutline","getOutlineMap","len","innerAreaPoints","nearestDistance","MAX_SAFE_INTEGER","gatherPoint","distance","drawPoints","gathersLen","p","conformingToDistance","row","column","slice","map","uints","Background","gridGap","gridFillStyle","gridPaperGap","gridPaperStrokeStyle","quadrillePaperVerticalMargin","quadrillePaperGap","quadrillePaperStrokeStyles","gridPattern","gridPaperPattern","quadrillePaperPattern","bgPattern","coordX","coordY","generateGridPattern","generateGridPaperPattern","generateQuadrillePaperPattern","GRID","GRID_PAPER","QUADRILLE_PAPER","bgOffscreen","createPattern","strokeRect","setLineDash","RuleAuxiliary","ruleStrokeStyle","ruleGap","ruleUnitLen","offsetX","offsetY","offsetXRule","offsetYRule","Border","borderStyle","borderWidth","Writing","willReadFrequently","refresh","putImageData","singlePointsWriting","points","writing","color","wx11","wy11","wx12","wy12","wx21","wy21","wx22","wy22","x11","y11","x12","y12","x21","y21","x22","y22","clear","doClean","pushImageData","determineIfThereHasContent","hasContent","storeItem","splice","colLen","storeLen","displayData","storeItemWorldOffsetX","storeItemWorldOffsetY","storeItemData","abs","currentCol","currentRow","displayCol","displayRow","g","displayJ","displayImageData","getWholeCanvas","minX","minY","maxX","maxY","undefined","wholeWidth","wholeHeight","minPixelX","minPixelY","maxPixelX","maxPixelY","targetWidth","targetHeight","getPaperCanvas","floor","Eraser","cleanX","cleanY","cleanWidth","cleanHeight","rect","defaultScrollRange","defaultScrollDirection","ALL","defaultBGPattern","defaultWriteModel","WRITE","defaultGridFillStyle","defaultGridPaperStrokeStyle","defaultQuadrillePaperStrokeStyles","defaultRuleStrokeStyle","defaultColor","defaultBorderStyle","defaultOptions","scrollRange","scrollDirection","writeModel","enableBG","rule","stack","moveCountTotal","writeLocked","dragLocked","showBorder","useShapeType","Board","scrolling","d","maxD","pointsGroup","cleanState","cleanPress","stackObj","moveT","debounceBindOnChange","prevPoints","activateToolShape","toolShapeCenterX","toolShapeCenterY","toolShapeAngle","background","ruleAuxiliary","border","eraser","eraserHasContent","containerOffset","onChange","options","scrollingElement","getBoundingClientRect","scrollLeft","scrollTop","func","delay","timer","args","clearTimeout","setTimeout","apply","debounce","triggerOnChange","lastStoreItem","prevWorldOffsetX","prevWorldOffsetY","preOffsetX","preOffsetY","doMove","append","setVoice","showBG","hideBG","showRule","hideRule","showToolShape","hideToolShape","setToolShapeType","shapeType","adjustOffset","round","X","Y","requestAnimationFrame","scrollBy","window","requestIdleCallback","exportAsCanvas","drawPureCanvas","crop","forEach","corners","exportAsPaperCanvas","imageCanvas","loadBackground","clean","unclean","loadRule","drawEraser","drawToolShape","rotationCenter","hasMoved","hasWrited","isDoubleTouch","isToolShapeDoubleTouch","turnStartAngle","dragStartTime","dragEndTime","needPushPoints","isSingleTouch","writeStartX","writeStartY","writeStartTime","writeEndX","writeEndY","writeEndTime","handleWriteStart","performance","now","doInsertPointByToolShape","nearestPoints","doInsertPoint","pushPoints","doWriting","handleWriteMove","deltaX","deltaY","touch1","touch2","atan2","center","getTripleTouchAngleAndCenter","newX","newY","originX","originY","radians","rotateCoordinate","scrollDecay","speedX","speedY","t","_scrollDecay","ratio","handleWriteEnd","deltaTime","changedTouches","containerX","containerY","totalX","totalY","touch","opacity","getCornerCoordinate","getCornersCoordinate","originD","isNaN","DRAW","flat","some","xy","rate"],"mappings":"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"}