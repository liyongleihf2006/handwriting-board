{"version":3,"file":"index.umd.min.js","sources":["../src/stack.ts","../src/enum.ts","../src/utils.ts","../src/component/shape/Ruler.ts","../src/component/shape/Compass.ts","../src/component/shape/Compass360.ts","../src/component/shape/Triangle.ts","../src/component/ToolShape.ts","../src/component/Background.ts","../src/component/RuleAuxiliary.ts","../src/component/Border.ts","../src/component/Writing.ts","../src/component/Eraser.ts","../src/component/BrushDrawing.ts","../src/index.ts"],"sourcesContent":["export class Stack {\n    width;\n    height;\n    undoStack = [];\n    redoStack = [];\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    restoreState = () => undefined;\n    saveState(store) {\n        this.undoStack.push([...store]);\n        this.redoStack.length = 0;\n    }\n    undo() {\n        if (this.undoStack.length > 0) {\n            const lastState = this.undoStack.pop();\n            this.redoStack.push(lastState);\n            let previousState = this.undoStack[this.undoStack.length - 1];\n            if (!previousState) {\n                const data = new Uint8ClampedArray(this.width * 4 * this.height);\n                const imageData = new ImageData(data, this.width, this.height);\n                previousState = [{ worldOffsetX: 0, worldOffsetY: 0, imageData }];\n            }\n            this.doRestoreState(previousState);\n        }\n    }\n    redo() {\n        if (this.redoStack.length > 0) {\n            const nextState = this.redoStack.pop();\n            this.undoStack.push(nextState);\n            this.doRestoreState(nextState);\n        }\n    }\n    doRestoreState(store) {\n        this.restoreState([...store]);\n    }\n}\n//# sourceMappingURL=stack.js.map","export var WriteModel;\n(function (WriteModel) {\n    WriteModel[\"WRITE\"] = \"write\";\n    WriteModel[\"DRAW\"] = \"draw\";\n})(WriteModel || (WriteModel = {}));\nexport var BGPattern;\n(function (BGPattern) {\n    BGPattern[\"GRID\"] = \"grid\";\n    BGPattern[\"GRID_PAPER\"] = \"gridPaper\";\n    BGPattern[\"QUADRILLE_PAPER\"] = \"quadrillePaper\";\n})(BGPattern || (BGPattern = {}));\nexport var ScrollDirection;\n(function (ScrollDirection) {\n    ScrollDirection[\"ALL\"] = \"all\";\n    ScrollDirection[\"X\"] = \"x\";\n    ScrollDirection[\"Y\"] = \"y\";\n})(ScrollDirection || (ScrollDirection = {}));\nexport var ShapeType;\n(function (ShapeType) {\n    ShapeType[\"RULER\"] = \"ruler\";\n    ShapeType[\"COMPASS\"] = \"compass\";\n    ShapeType[\"COMPASS360\"] = \"compass360\";\n    ShapeType[\"RIGHT_ANGLE_TRIANGLE\"] = \"rightAngleTriangle\";\n    ShapeType[\"SOSCELESL_TRIANGLE\"] = \"isoscelesTriangle\";\n})(ShapeType || (ShapeType = {}));\n//# sourceMappingURL=enum.js.map","export function debounce(func, delay) {\n    let timer;\n    return function (...args) {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            func.apply(this, args);\n        }, delay);\n    };\n}\nexport function RotateCoordinates(angle, x0, y0) {\n    const angleInRadians = angle * Math.PI / 180;\n    const cosAngle = Math.cos(angleInRadians);\n    const sinAngle = Math.sin(angleInRadians);\n    return function (x, y) {\n        const x1 = x - x0;\n        const y1 = y - y0;\n        const targetX = x1 * cosAngle - y1 * sinAngle + x0;\n        const targetY = x1 * sinAngle + y1 * cosAngle + y0;\n        return [targetX, targetY];\n    };\n}\nexport function rotateAngle(angle, angle0) {\n    // 将角度转换为弧度\n    const radian = (angle + angle0) * (Math.PI / 180);\n    return radian;\n}\nexport function calculateRotatedPoint(rx, ry, r, angle, _angle) {\n    const angleRad = angle * (Math.PI / 180); // 将角度转换为弧度\n    const _angleRad = _angle * (Math.PI / 180); // 将旋转角度转换为弧度\n    const x = rx + r * Math.cos(angleRad + _angleRad); // 计算点的 x 坐标\n    const y = ry + r * Math.sin(angleRad + _angleRad); // 计算点的 y 坐标\n    return [x, y];\n}\nexport function getTripleTouchAngleAndCenter(event) {\n    const touch1 = event.touches[0];\n    const touch2 = event.touches[1];\n    const x1 = touch1.pageX;\n    const y1 = touch1.pageY;\n    const x2 = touch2.pageX;\n    const y2 = touch2.pageY;\n    const deltaX = x2 - x1;\n    const deltaY = y2 - y1;\n    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n    const centerX = (x1 + x2) / 2;\n    const centerY = (y1 + y2) / 2;\n    return { angle, center: [centerX, centerY] };\n}\nexport function rotateCoordinate(x0, y0, angle, originX, originY) {\n    const radians = angle * (Math.PI / 180);\n    const deltaX = originX - x0;\n    const deltaY = originY - y0;\n    const newX = Math.cos(radians) * deltaX - Math.sin(radians) * deltaY;\n    const newY = Math.sin(radians) * deltaX + Math.cos(radians) * deltaY;\n    const rotatedX = newX + x0;\n    const rotatedY = newY + y0;\n    return [rotatedX, rotatedY];\n}\nexport function negativeRemainder(a, b) {\n    return ((a % b) + b) % b;\n}\nexport function generateCanvas(width, height) {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    Object.assign(canvas.style, {\n        left: '0',\n        top: '0',\n        position: 'absolute',\n        'pointer-events': 'none',\n        width: '100%',\n        height: '100%'\n    });\n    return canvas;\n}\n//# sourceMappingURL=utils.js.map","import { RotateCoordinates } from '../../utils';\nexport default class Ruler {\n    ctx;\n    cm;\n    mm;\n    path;\n    width = 0;\n    height = 0;\n    marginH = 0;\n    degreeNumber = 20;\n    constructor(ctx, cm, mm) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.marginH = this.mm * 5;\n        this.width = this.cm * this.degreeNumber + this.marginH * 2;\n        this.height = this.cm * 2;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const width = this.width + voice;\n        const height = this.height + voice;\n        const x = _cx - voice / 2 - width / 2;\n        const y = _cy - voice / 2 - height / 2;\n        const angle = _angle;\n        const cm = this.cm;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        let pathStr = '';\n        pathStr += `M${rotateCoordinates(x, y).join(',')}`;\n        pathStr += `L${rotateCoordinates(x + width, y).join(',')}`;\n        pathStr += `L${rotateCoordinates(x + width, y + height).join(',')}`;\n        const offestX = 1.5 * cm + this.marginH + voice / 2;\n        const beginWaveX = x + width - offestX;\n        const beginWaveY = y + height;\n        const endWaveX = x + offestX;\n        const waveUnit = cm * 2 / 3;\n        const waveUnitY = waveUnit / 4;\n        const waveY = beginWaveY - waveUnitY;\n        pathStr += `L${rotateCoordinates(beginWaveX, beginWaveY).join(',')}`;\n        let currentWaveUnit = beginWaveX - waveUnit;\n        while (currentWaveUnit > endWaveX) {\n            pathStr += `C${[...rotateCoordinates(currentWaveUnit + waveUnit / 3, waveY - waveUnitY), ...rotateCoordinates(currentWaveUnit + waveUnit * 2 / 3, waveY + waveUnitY), ...rotateCoordinates(currentWaveUnit, beginWaveY)].join(',')}`;\n            currentWaveUnit -= waveUnit;\n        }\n        pathStr += `L${rotateCoordinates(x, beginWaveY).join(',')}`;\n        pathStr += 'z';\n        const path = new Path2D(pathStr);\n        this.path = path;\n        return path;\n    }\n    draw(cx, cy, angle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const marginH = this.marginH;\n        const cm = this.cm;\n        const mm = this.mm;\n        const degreeNumber = this.degreeNumber;\n        const width = this.width;\n        const height = this.height;\n        const rotateCoordinates = RotateCoordinates(angle, cx, cy);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path);\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = 'black';\n        ctx.font = \"3mm serif\";\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n        ctx.beginPath();\n        const cmLen = 0.5 * cm;\n        const x = cx - width / 2;\n        const y = cy - height / 2;\n        const textPos = y + cmLen + mm;\n        const mmLen = cmLen * 0.6;\n        const halfCmLen = cmLen * 0.8;\n        for (let i = 0; i <= degreeNumber; i++) {\n            const currentX = x + marginH + i * cm;\n            ctx.moveTo(...rotateCoordinates(currentX, y));\n            ctx.lineTo(...rotateCoordinates(currentX, y + cmLen));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(currentX, textPos));\n            ctx.rotate(angle * Math.PI / 180);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumber) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmX = currentX + j * mm;\n                    ctx.moveTo(...rotateCoordinates(currentMmX, y));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + halfCmLen));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + mmLen));\n                    }\n                }\n            }\n        }\n        ctx.stroke();\n        ctx.restore();\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Ruler.js.map","import { rotateAngle, calculateRotatedPoint } from '../../utils';\nexport default class Compass {\n    ctx;\n    cm;\n    mm;\n    path;\n    r;\n    middleR;\n    smallR;\n    middleGap;\n    startAngle = 170;\n    endAngle = 370;\n    innerStartAngle = 180;\n    innerEndAngle = 360;\n    constructor(ctx, cm, mm) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.r = cm * 6;\n        this.middleR = cm * 3.5;\n        this.middleGap = cm * 1;\n        this.smallR = cm * 2.2;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const startAngle = this.startAngle;\n        const endAngle = this.endAngle;\n        const innerStartAngle = this.innerStartAngle;\n        const innerEndAngle = this.innerEndAngle;\n        const r = this.r + voice;\n        const middleInsideR = this.middleR + voice;\n        const middleOutsideR = middleInsideR + this.middleGap - voice;\n        const smallR = this.smallR - voice;\n        const cx = _cx;\n        const cy = _cy;\n        const innerCx = _cx;\n        const innerCy = _cy - voice;\n        const path = new Path2D();\n        path.arc(cx, cy, r, rotateAngle(startAngle, _angle), rotateAngle(endAngle, _angle));\n        path.closePath();\n        path.moveTo(...calculateRotatedPoint(innerCx, innerCy, middleOutsideR, innerStartAngle, _angle));\n        path.arc(innerCx, innerCy, middleOutsideR, rotateAngle(innerStartAngle, _angle), rotateAngle(innerEndAngle, _angle));\n        path.lineTo(...calculateRotatedPoint(innerCx, innerCy, middleInsideR, innerEndAngle, _angle));\n        path.arc(innerCx, innerCy, middleInsideR, rotateAngle(innerEndAngle, _angle), rotateAngle(innerStartAngle, _angle), true);\n        path.lineTo(...calculateRotatedPoint(innerCx, innerCy, middleOutsideR, innerStartAngle, _angle));\n        path.moveTo(...calculateRotatedPoint(innerCx, innerCy, smallR, innerStartAngle, _angle));\n        path.arc(innerCx, innerCy, smallR, rotateAngle(innerStartAngle, _angle), rotateAngle(innerEndAngle, _angle));\n        path.closePath();\n        this.path = path;\n        return path;\n    }\n    drawDegree(cx, cy, r, smallUnitL, unitL, bigUnitL, ruleFontSize, fontGap, showText, showSmall, showMiddle, textOnInner, _angle, reverse = false) {\n        const ctx = this.ctx;\n        // 刻度设置\n        const total = 180; // 总刻度数\n        const unitS = Math.PI / total; // 刻度线间隔角度\n        const unitBigInterval = 10;\n        const unitInterval = unitBigInterval;\n        const ruleLoose = 5;\n        // 绘制刻度和刻度的数值\n        let angle = (180 + _angle) * Math.PI / 180;\n        ctx.save();\n        ctx.textAlign = 'center'; // 设置文本对齐方式\n        ctx.textBaseline = 'middle';\n        ctx.font = `${ruleFontSize}px Arial`; // 文本字体\n        if (!textOnInner) {\n            r += bigUnitL;\n            ctx.textBaseline = 'bottom';\n        }\n        for (let i = 0; i <= total; i++) {\n            if (i % unitBigInterval === 0) { // 大刻度\n                const startX = cx + Math.cos(angle) * (r - bigUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - bigUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n                if (showText && i % unitInterval === 0) {\n                    const textX = cx + Math.cos(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置横坐标\n                    const textY = cy + Math.sin(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置纵坐标\n                    ctx.save();\n                    ctx.textAlign = 'center';\n                    ctx.translate(textX, textY);\n                    ctx.rotate(angle + Math.PI / 2);\n                    ctx.fillText((reverse ? total - i : i).toString(), 0, 0);\n                    ctx.restore();\n                }\n            }\n            else if (!(i % ruleLoose)) { // 中刻度\n                if (showMiddle) {\n                    const startX = cx + Math.cos(angle) * (r - unitL); // 刻度线起始点横坐标\n                    const startY = cy + Math.sin(angle) * (r - unitL); // 刻度线起始点纵坐标\n                    const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                    const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n            }\n            else if (showSmall) {\n                const startX = cx + Math.cos(angle) * (r - smallUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - smallUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n            }\n            angle += unitS; // 更新角度\n        }\n        ctx.restore();\n    }\n    drawContent(_cx, _cy, _angle) {\n        const r = this.r;\n        const middleR = this.middleR;\n        const smallR = this.smallR;\n        const cx = _cx;\n        const cy = _cy;\n        const ctx = this.ctx;\n        ctx.save();\n        this.drawDegree(cx, cy, r, 10, 15, 20, 8, 10, true, true, true, true, _angle);\n        this.drawDegree(cx, cy, middleR, 10, 12, 15, 0, 0, false, true, true, true, _angle);\n        this.drawDegree(cx, cy, smallR, 0, 0, 12, 7, 10, true, false, false, false, _angle, true);\n        ctx.restore();\n    }\n    drawPosition(cx, cy, angle) {\n        const r = 20;\n        const ctx = this.ctx;\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(cx, cy);\n        ctx.lineTo(...calculateRotatedPoint(cx, cy, r, 90, angle));\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.arc(cx, cy, r, rotateAngle(0, angle), rotateAngle(180, angle));\n        ctx.stroke();\n        ctx.restore();\n    }\n    draw(cx, cy, angle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path, 'evenodd');\n        ctx.restore();\n        this.drawContent(cx, cy, angle);\n        this.drawPosition(cx, cy, angle);\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Compass.js.map","import { rotateAngle, RotateCoordinates } from '../../utils';\nfunction isTouchDevice() {\n    return 'ontouchstart' in self;\n}\nexport default class Compass {\n    ctx;\n    cm;\n    mm;\n    container;\n    getPageCoords;\n    toolShape;\n    path;\n    outsideR;\n    insideR;\n    pointerW;\n    startAngle = 0;\n    endAngle = 360;\n    firstPointerAngle = 0;\n    secondPointerAngle = 30;\n    pointer1;\n    pointer2;\n    cx;\n    cy;\n    angle;\n    constructor(ctx, cm, mm, container, getPageCoords, toolShape) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.container = container;\n        this.getPageCoords = getPageCoords;\n        this.toolShape = toolShape;\n        this.outsideR = cm * 6;\n        this.insideR = cm * 4.5;\n        this.pointerW = cm * 1;\n        this.loadEvent();\n    }\n    calculateRotationAngle(cx, cy, dragStartX, dragStartY, dragEndX, dragEndY) {\n        // 计算向量a的x和y分量\n        const aX = dragStartX - cx;\n        const aY = dragStartY - cy;\n        // 计算向量b的x和y分量\n        const bX = dragEndX - cx;\n        const bY = dragEndY - cy;\n        // 计算向量a和向量b的夹角\n        const dotProduct = aX * bX + aY * bY; // 向量的点乘\n        const aLength = Math.sqrt(aX * aX + aY * aY); // 向量a的长度\n        const bLength = Math.sqrt(bX * bX + bY * bY); // 向量b的长度\n        const cosTheta = dotProduct / (aLength * bLength); // 夹角的余弦值\n        const theta = Math.acos(cosTheta); // 夹角的弧度值\n        // 判断旋转方向，如果向量a和向量b形成逆时针方向，则旋转角度为正值，否则为负值\n        const crossProduct = aX * bY - aY * bX; // 向量的叉乘\n        const rotationAngle = crossProduct >= 0 ? theta : -theta;\n        // 将弧度转换为角度\n        const rotationAngleInDegrees = rotationAngle * 180 / Math.PI;\n        return rotationAngleInDegrees;\n    }\n    loadEvent() {\n        const container = this.container;\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragEndX = 0;\n        let dragEndY = 0;\n        let doTurn = false;\n        let movePointer1 = false;\n        let movePointer2 = false;\n        const turnPoinerStart = (coords, event) => {\n            const ctx = this.ctx;\n            const pointer1 = this.pointer1;\n            const pointer2 = this.pointer2;\n            dragEndX = coords.pageX;\n            dragEndY = coords.pageY;\n            if (pointer2 && ctx.isPointInPath(pointer2, coords.pageX, coords.pageY)) {\n                event.stopImmediatePropagation();\n                movePointer2 = true;\n                doTurn = true;\n            }\n            else if (pointer1 && ctx.isPointInPath(pointer1, coords.pageX, coords.pageY)) {\n                event.stopImmediatePropagation();\n                movePointer1 = true;\n                doTurn = true;\n            }\n        };\n        const handleTouchStart = (event) => {\n            const touches = event.touches;\n            const coords = this.getPageCoords(touches);\n            if (touches.length === 1) {\n                turnPoinerStart(coords, event);\n            }\n            else {\n                doTurn = false;\n            }\n        };\n        const handleMouseStart = (event) => {\n            event.preventDefault();\n            const { pageX, pageY } = event;\n            const coords = this.getPageCoords([{ pageX, pageY }]);\n            turnPoinerStart(coords, event);\n        };\n        const turnPointerMove = (coords) => {\n            dragStartX = dragEndX;\n            dragStartY = dragEndY;\n            dragEndX = coords.pageX;\n            dragEndY = coords.pageY;\n            const deltaAngle = this.calculateRotationAngle(this.cx, this.cy, dragStartX, dragStartY, dragEndX, dragEndY);\n            if (movePointer1) {\n                this.firstPointerAngle += deltaAngle;\n            }\n            else if (movePointer2) {\n                this.secondPointerAngle += deltaAngle;\n            }\n            this.draw(this.cx, this.cy, this.angle);\n            this.toolShape.reset();\n        };\n        const handleMouseMove = (event) => {\n            if (doTurn) {\n                event.stopImmediatePropagation();\n                const { pageX, pageY } = event;\n                const coords = this.getPageCoords([{ pageX, pageY }]);\n                turnPointerMove(coords);\n            }\n        };\n        const handleTouchMove = (event) => {\n            if (doTurn) {\n                event.stopImmediatePropagation();\n                const touches = event.touches;\n                const coords = this.getPageCoords(touches);\n                turnPointerMove(coords);\n            }\n        };\n        const turnPointerEnd = () => {\n            doTurn = false;\n            movePointer1 = false;\n            movePointer2 = false;\n        };\n        const handleTouchEnd = () => {\n            turnPointerEnd();\n        };\n        const handleMouseEnd = (event) => {\n            turnPointerEnd();\n        };\n        if (isTouchDevice()) {\n            container.addEventListener(\"touchstart\", handleTouchStart, { passive: true });\n            container.addEventListener(\"touchmove\", handleTouchMove, { passive: true });\n            container.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\n        }\n        else {\n            container.addEventListener(\"mousedown\", handleMouseStart);\n            self.addEventListener(\"mousemove\", handleMouseMove, { passive: true });\n            self.addEventListener(\"mouseup\", handleMouseEnd, { passive: true });\n        }\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const cx = _x;\n        const cy = _y;\n        const angle = _angle;\n        this.drawBorder(c, cx, cy, angle, 0, 'rgba(0,0,0,1)');\n        this.drawPointer(c, cx, cy, angle, this.firstPointerAngle, 0, 'rgba(0,0,0,1)');\n        this.drawPointer(c, cx, cy, angle, this.secondPointerAngle, 0, 'rgba(0,0,0,1)');\n        c.globalCompositeOperation = 'source-out';\n        const offscreen1 = new OffscreenCanvas(width, height);\n        const c2 = offscreen1.getContext('2d');\n        this.drawBorder(c2, cx, cy, angle, outlineVoice, 'rgba(0,0,0,1)');\n        this.drawPointer(c2, cx, cy, angle, this.firstPointerAngle, outlineVoice, 'rgba(0,0,0,1)');\n        this.drawPointer(c2, cx, cy, angle, this.secondPointerAngle, outlineVoice, 'rgba(0,0,0,1)');\n        c.drawImage(offscreen1, 0, 0);\n        c.globalCompositeOperation = 'source-in';\n        c.fillStyle = strokeStyle;\n        c.fillRect(0, 0, width, height);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle) {\n        const startAngle = this.startAngle;\n        const endAngle = this.endAngle;\n        const outsideR = this.outsideR;\n        const insideR = this.insideR;\n        const r = (outsideR + insideR) / 2;\n        const cx = _cx;\n        const cy = _cy;\n        const path = new Path2D();\n        path.arc(cx, cy, r, rotateAngle(startAngle, _angle), rotateAngle(endAngle, _angle));\n        this.path = path;\n        return path;\n    }\n    generatorPointer(_cx, _cy, _angle, pointerAngle, outlineVoice) {\n        const outsideR = this.outsideR;\n        const pointerW = this.pointerW;\n        const cx = _cx;\n        const cy = _cy;\n        const r = pointerW / 2 + outlineVoice;\n        let angle = _angle;\n        angle += pointerAngle;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        let pathStr = '';\n        pathStr += `M${rotateCoordinates(cx, cy - r).join(',')}`;\n        pathStr += `A${r},${r},1,1,1,${rotateCoordinates(cx, cy + r).join(',')}`;\n        pathStr += `L${rotateCoordinates(cx - outsideR, cy + r).join(',')}`;\n        pathStr += `A${r},${r},1,1,1,${rotateCoordinates(cx - outsideR, cy - r).join(',')}`;\n        pathStr += 'z';\n        const path = new Path2D(pathStr);\n        return path;\n    }\n    drawDegree(cx, cy, r, smallUnitL, unitL, bigUnitL, ruleFontSize, fontGap, showText, showSmall, showMiddle, showBig, textOnInner, _angle, reverse) {\n        const ctx = this.ctx;\n        // 刻度设置\n        const total = 360; // 总刻度数\n        const unitS = 2 * Math.PI / total; // 刻度线间隔角度\n        const unitBigInterval = 10;\n        const unitInterval = unitBigInterval;\n        const ruleLoose = 5;\n        // 绘制刻度和刻度的数值\n        let angle = (180 + _angle) * Math.PI / 180;\n        ctx.save();\n        ctx.textAlign = 'center'; // 设置文本对齐方式\n        ctx.textBaseline = 'middle';\n        ctx.font = `${ruleFontSize}px Arial`; // 文本字体\n        if (!textOnInner) {\n            r += bigUnitL;\n            ctx.textBaseline = 'bottom';\n        }\n        for (let i = 0; i <= total; i++) {\n            if (i % unitBigInterval === 0) { // 大刻度\n                const startX = cx + Math.cos(angle) * (r - bigUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - bigUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                if (showBig) {\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n                if (i !== total && showText && i % unitInterval === 0) {\n                    const textX = cx + Math.cos(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置横坐标\n                    const textY = cy + Math.sin(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置纵坐标\n                    ctx.save();\n                    ctx.textAlign = 'center';\n                    ctx.translate(textX, textY);\n                    ctx.rotate(angle + Math.PI / 2);\n                    ctx.fillText((reverse ? total - i : i).toString(), 0, 0);\n                    ctx.restore();\n                }\n            }\n            else if (!(i % ruleLoose)) { // 中刻度\n                if (showMiddle) {\n                    const startX = cx + Math.cos(angle) * (r - unitL); // 刻度线起始点横坐标\n                    const startY = cy + Math.sin(angle) * (r - unitL); // 刻度线起始点纵坐标\n                    const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                    const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n            }\n            else if (showSmall) {\n                const startX = cx + Math.cos(angle) * (r - smallUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - smallUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n            }\n            angle += unitS; // 更新角度\n        }\n        ctx.restore();\n    }\n    drawContent(_cx, _cy, _angle) {\n        const outsideR = this.outsideR;\n        const cx = _cx;\n        const cy = _cy;\n        const ctx = this.ctx;\n        ctx.save();\n        this.drawDegree(cx, cy, outsideR, 10, 15, 20, 8, 10, true, true, true, true, true, _angle, false);\n        this.drawDegree(cx, cy, outsideR, 10, 15, 20, 8, 25, true, false, false, false, true, _angle, true);\n        ctx.restore();\n    }\n    drawBorder(ctx, cx, cy, angle, outlineVoice, strokeStyle) {\n        const outsideR = this.outsideR;\n        const insideR = this.insideR;\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = outsideR - insideR + 2 * outlineVoice;\n        ctx.strokeStyle = strokeStyle;\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.stroke(path);\n        ctx.restore();\n    }\n    drawPointer(ctx, cx, cy, angle, pointerAngle, outlineVoice, fillStyle) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = fillStyle;\n        const path = this.generatorPointer(cx, cy, angle, pointerAngle, outlineVoice);\n        ctx.fill(path);\n        ctx.restore();\n        return path;\n    }\n    drawFixedPoint(cx, cy, angle) {\n        const ctx = this.ctx;\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        ctx.arc(cx, cy, this.pointerW / 4, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n    }\n    draw(cx, cy, angle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        this.drawBorder(ctx, cx, cy, angle, 0, 'rgba(0,0,0,.08)');\n        this.drawContent(cx, cy, angle);\n        this.pointer1 = this.drawPointer(ctx, cx, cy, angle, this.firstPointerAngle, 0, 'rgba(0,0,0,.08)');\n        this.pointer2 = this.drawPointer(ctx, cx, cy, angle, this.secondPointerAngle, 0, 'rgba(0,0,0,.08)');\n        this.drawFixedPoint(cx, cy, angle);\n        this.cx = cx;\n        this.cy = cy;\n        this.angle = angle;\n    }\n    isPointInPath(x, y, fillRule) {\n        const ctx = this.ctx;\n        if (fillRule === 'evenodd') {\n            let isPointInStroke = false;\n            ctx.save();\n            ctx.lineWidth = this.outsideR - this.insideR;\n            isPointInStroke = ctx.isPointInStroke(this.path, x, y);\n            ctx.restore();\n            return isPointInStroke;\n        }\n        else {\n            return ctx.isPointInPath(this.path, x, y);\n        }\n    }\n}\n//# sourceMappingURL=Compass360.js.map","import { RotateCoordinates } from '../../utils';\nexport default class Triangle {\n    ctx;\n    cm;\n    mm;\n    degreeNumberH;\n    degreeNumberV;\n    marginH;\n    marginV;\n    path;\n    width = 0;\n    height = 0;\n    marginC = 0;\n    gap = 0;\n    constructor(ctx, cm, mm, degreeNumberH, degreeNumberV, marginH, marginV) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.degreeNumberH = degreeNumberH;\n        this.degreeNumberV = degreeNumberV;\n        this.marginH = marginH;\n        this.marginV = marginV;\n        this.marginC = this.cm;\n        this.width = this.cm * this.degreeNumberH + this.marginH + this.marginC;\n        this.height = this.cm * this.degreeNumberV + this.marginV + this.marginC;\n        this.gap = this.cm * 1.5;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const width = this.width + voice;\n        const height = this.height + voice;\n        const x = _cx - voice / 2 - width / 2;\n        const y = _cy - voice / 2 - height / 2;\n        const angle = _angle;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        const path = new Path2D();\n        path.moveTo(...rotateCoordinates(x + width, y));\n        path.lineTo(...rotateCoordinates(x, y));\n        path.lineTo(...rotateCoordinates(x, y + height));\n        path.closePath();\n        const gap = this.gap;\n        const smallX = x + gap;\n        const smallY = y + gap;\n        const smallWidth = width / 2;\n        const smallHeight = height / 2;\n        path.moveTo(...rotateCoordinates(smallX + smallWidth, smallY));\n        path.lineTo(...rotateCoordinates(smallX, smallY));\n        path.lineTo(...rotateCoordinates(smallX, smallY + smallHeight));\n        path.closePath();\n        this.path = path;\n        return path;\n    }\n    draw(cx, cy, angle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const marginC = this.marginC;\n        const cm = this.cm;\n        const mm = this.mm;\n        const degreeNumberH = this.degreeNumberH;\n        const degreeNumberV = this.degreeNumberV;\n        const width = this.width;\n        const height = this.height;\n        const rotateCoordinates = RotateCoordinates(angle, cx, cy);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path, 'evenodd');\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = 'black';\n        ctx.font = \"3mm serif\";\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n        ctx.beginPath();\n        const cmLen = 0.5 * cm;\n        const x = cx - width / 2;\n        const y = cy - height / 2;\n        const mmLen = cmLen * 0.6;\n        const halfCmLen = cmLen * 0.8;\n        for (let i = 0; i <= degreeNumberH; i++) {\n            const currentX = x + marginC + i * cm;\n            ctx.moveTo(...rotateCoordinates(currentX, y));\n            ctx.lineTo(...rotateCoordinates(currentX, y + cmLen));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(currentX, y + cmLen + mm));\n            ctx.rotate(angle * Math.PI / 180);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumberH) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmX = currentX + j * mm;\n                    ctx.moveTo(...rotateCoordinates(currentMmX, y));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + halfCmLen));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + mmLen));\n                    }\n                }\n            }\n        }\n        for (let i = 0; i <= degreeNumberV; i++) {\n            const currentY = y + marginC + i * cm;\n            ctx.moveTo(...rotateCoordinates(x, currentY));\n            ctx.lineTo(...rotateCoordinates(x + cmLen, currentY));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(x + cmLen + mm, currentY));\n            ctx.rotate(angle * Math.PI / 180 - Math.PI / 2);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumberV) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmY = currentY + j * mm;\n                    ctx.moveTo(...rotateCoordinates(x, currentMmY));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(x + halfCmLen, currentMmY));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(x + mmLen, currentMmY));\n                    }\n                }\n            }\n        }\n        ctx.stroke();\n        ctx.restore();\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Triangle.js.map","import { ShapeType } from '../enum';\nimport { generateCanvas } from '../utils';\nimport Ruler from './shape/Ruler';\nimport Compass from './shape/Compass';\nimport Compass360 from './shape/Compass360';\nimport Triangle from './shape/Triangle';\nexport default class ToolShape {\n    w;\n    h;\n    voice;\n    canvas;\n    ctx;\n    getNearestDistanceAndPointVoice;\n    outlineCtx;\n    outlineImageData;\n    outline;\n    outlineMap;\n    longestDistance = 30;\n    // 像素点采集宽度\n    gatherAreaWidth = 10;\n    prevPoint = null;\n    _x;\n    _y;\n    _angle;\n    _toolShapeType;\n    strokeStyle;\n    cm = 0;\n    mm = 0;\n    width = 0;\n    height = 0;\n    marginH = 0;\n    degreeNumber = 20;\n    ruler;\n    compass;\n    compass360;\n    rightAngleTriangle;\n    isoscelesTriangle;\n    constructor(w, h, voice, container, getPageCoords) {\n        this.w = w;\n        this.h = h;\n        this.voice = voice;\n        this.canvas = generateCanvas(w, h);\n        this.ctx = this.canvas.getContext('2d');\n        this.cm = 96 / 2.54;\n        this.mm = this.cm / 10;\n        this.getNearestDistanceAndPointVoice = voice;\n        this.ruler = new Ruler(this.ctx, this.cm, this.mm);\n        this.compass = new Compass(this.ctx, this.cm, this.mm);\n        this.compass360 = new Compass360(this.ctx, this.cm, this.mm, container, getPageCoords, this);\n        this.rightAngleTriangle = new Triangle(this.ctx, this.cm, this.mm, 9, 5, this.cm * 3, this.cm * 1);\n        this.isoscelesTriangle = new Triangle(this.ctx, this.cm, this.mm, 6, 6, this.cm * 2, this.cm * 2);\n    }\n    set x(x) {\n        this._x = x;\n        this.reset();\n    }\n    get x() {\n        return this._x;\n    }\n    set y(y) {\n        this._y = y;\n        this.reset();\n    }\n    get y() {\n        return this._y;\n    }\n    set angle(angle) {\n        this._angle = angle;\n        this.reset();\n    }\n    get angle() {\n        return this._angle;\n    }\n    set toolShapeType(toolShapeType) {\n        this._toolShapeType = toolShapeType;\n        this.reset();\n    }\n    get toolShapeType() {\n        return this._toolShapeType;\n    }\n    get shape() {\n        let shape;\n        switch (this.toolShapeType) {\n            case ShapeType.RULER:\n                shape = this.ruler;\n                break;\n            case ShapeType.COMPASS:\n                shape = this.compass;\n                break;\n            case ShapeType.COMPASS360:\n                shape = this.compass360;\n                break;\n            case ShapeType.RIGHT_ANGLE_TRIANGLE:\n                shape = this.rightAngleTriangle;\n                break;\n            case ShapeType.SOSCELESL_TRIANGLE:\n                shape = this.isoscelesTriangle;\n                break;\n            default: shape = this.ruler;\n        }\n        return shape;\n    }\n    reset() {\n        this.outline = null;\n        this.prevPoint = null;\n    }\n    getGathers(x1, y1, x2, y2, gatherAreaWidth) {\n        const topLeftX = Math.min(x1, x2) - gatherAreaWidth / 2;\n        const topLeftY = Math.min(y1, y2) - gatherAreaWidth / 2;\n        const bottomRightX = Math.max(x1, x2) + gatherAreaWidth / 2;\n        const bottomRightY = Math.max(y1, y2) + gatherAreaWidth / 2;\n        const gathers = [];\n        for (let x = topLeftX; x <= bottomRightX; x++) {\n            for (let y = topLeftY; y <= bottomRightY; y++) {\n                gathers.push([x, y]);\n            }\n        }\n        return gathers;\n    }\n    getNearestDistanceAndPoint(x, y, getNearestDistanceAndPointVoice, strokeStyle) {\n        if (!this.outline || getNearestDistanceAndPointVoice !== this.getNearestDistanceAndPointVoice || this.strokeStyle !== strokeStyle) {\n            this.getNearestDistanceAndPointVoice = getNearestDistanceAndPointVoice;\n            this.strokeStyle = strokeStyle;\n            this.outlineCtx = this.getOutlineCtx(this.getNearestDistanceAndPointVoice, strokeStyle);\n            this.outlineImageData = this.outlineCtx.getImageData(0, 0, this.w, this.h);\n            this.outline = this.getOutline(this.outlineImageData);\n            this.outlineMap = this.getOutlineMap(this.outline);\n        }\n        const outline = this.outline;\n        const len = outline.length;\n        let prevPoint = this.prevPoint;\n        const gatherAreaWidth = this.gatherAreaWidth;\n        if (!prevPoint) {\n            let nearestDistance = Number.MAX_SAFE_INTEGER;\n            for (let i = 0; i < len; i++) {\n                const [x0, y0] = outline[i];\n                const distance = ((x - x0) ** 2 + (y - y0) ** 2) ** 0.5;\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    prevPoint = [x0, y0];\n                }\n            }\n            this.prevPoint = prevPoint;\n            return { conformingToDistance: nearestDistance <= this.longestDistance, drawPoints: [] };\n        }\n        else {\n            const innerAreaPoints = [];\n            for (let i = 0; i < len; i++) {\n                const [x0, y0] = outline[i];\n                const gatherDistance = ((prevPoint[0] - x0) ** 2 + (prevPoint[1] - y0) ** 2) ** 0.5;\n                if (gatherDistance <= gatherAreaWidth) {\n                    innerAreaPoints.push(outline[i]);\n                }\n            }\n            let nearestDistance = Number.MAX_SAFE_INTEGER;\n            let gatherPoint = null;\n            for (let i = 0; i < innerAreaPoints.length; i++) {\n                const [x0, y0] = innerAreaPoints[i];\n                const distance = ((x - x0) ** 2 + (y - y0) ** 2) ** 0.5;\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    gatherPoint = [x0, y0];\n                }\n            }\n            let gathers = [];\n            if (gatherPoint) {\n                gathers = this.getGathers(prevPoint[0], prevPoint[1], gatherPoint[0], gatherPoint[1], gatherAreaWidth);\n            }\n            const drawPoints = [];\n            const gathersLen = gathers.length;\n            for (let i = 0; i < gathersLen; i++) {\n                const p = gathers[i];\n                const imageData = this.outlineMap?.[p[0]]?.[p[1]];\n                if (imageData) {\n                    const data = imageData;\n                    drawPoints.push({ x: p[0], y: p[1], fillStyle: `rgba(${data[0]},${data[1]},${data[2]},${data[3] / 255})` });\n                }\n            }\n            this.prevPoint = gatherPoint;\n            return { conformingToDistance: true, drawPoints };\n        }\n    }\n    getOutlineCtx(outlineVoice, strokeStyle) {\n        return this.shape.getOutlineCtx(this._x, this._y, this._angle, outlineVoice, strokeStyle);\n    }\n    getOutline(imageData) {\n        const data = imageData.data;\n        const len = data.length;\n        const outline = [];\n        let row = 0;\n        let column = -1;\n        for (let i = 0; i < len; i += 4) {\n            column++;\n            if (data[i + 3]) {\n                outline.push([column, row, data.slice(i, i + 4)]);\n            }\n            if (column === this.w - 1) {\n                row++;\n                column = -1;\n            }\n        }\n        return outline;\n    }\n    getOutlineMap(outline) {\n        const map = {};\n        const len = outline.length;\n        for (let i = 0; i < len; i++) {\n            const [x, y, uints] = outline[i];\n            if (!map[x]) {\n                map[x] = {};\n            }\n            map[x][y] = uints;\n        }\n        return map;\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.shape.isPointInPath(x, y, fillRule);\n    }\n    draw(x, y, angle, toolShapeType) {\n        if (this.x !== x || this.y !== y || this.angle !== angle || this.toolShapeType !== toolShapeType) {\n            this.x = x;\n            this.y = y;\n            this.angle = angle;\n            this.toolShapeType = toolShapeType;\n            const ctx = this.ctx;\n            ctx.clearRect(0, 0, this.w, this.h);\n            this.shape.draw(this._x, this._y, this._angle);\n        }\n    }\n}\n//# sourceMappingURL=ToolShape.js.map","import { BGPattern } from \"../enum\";\nimport { generateCanvas } from '../utils';\nexport default class Background {\n    width;\n    height;\n    gridGap;\n    gridFillStyle;\n    gridPaperGap;\n    gridPaperStrokeStyle;\n    quadrillePaperVerticalMargin;\n    quadrillePaperGap;\n    quadrillePaperStrokeStyles;\n    gridPattern;\n    gridPaperPattern;\n    quadrillePaperPattern;\n    bgPattern;\n    canvas;\n    ctx;\n    coordX;\n    coordY;\n    constructor(width, height, gridGap, gridFillStyle, gridPaperGap, gridPaperStrokeStyle, quadrillePaperVerticalMargin, quadrillePaperGap, quadrillePaperStrokeStyles) {\n        this.width = width;\n        this.height = height;\n        this.gridGap = gridGap;\n        this.gridFillStyle = gridFillStyle;\n        this.gridPaperGap = gridPaperGap;\n        this.gridPaperStrokeStyle = gridPaperStrokeStyle;\n        this.quadrillePaperVerticalMargin = quadrillePaperVerticalMargin;\n        this.quadrillePaperGap = quadrillePaperGap;\n        this.quadrillePaperStrokeStyles = quadrillePaperStrokeStyles;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n        this.gridPattern = this.generateGridPattern();\n        this.gridPaperPattern = this.generateGridPaperPattern();\n        this.quadrillePaperPattern = this.generateQuadrillePaperPattern();\n    }\n    draw(coordX, coordY, bgPattern) {\n        if (coordX !== this.coordX || coordY !== this.coordY || bgPattern !== this.bgPattern) {\n            this.coordX = coordX;\n            this.coordY = coordY;\n            this.bgPattern = bgPattern;\n            const ctx = this.ctx;\n            ctx.clearRect(0, 0, this.width + this.gridGap * 2, this.height + this.gridGap * 2);\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(coordX, coordY);\n            if (this.bgPattern === BGPattern.GRID) {\n                ctx.fillStyle = this.gridPattern;\n            }\n            else if (this.bgPattern === BGPattern.GRID_PAPER) {\n                ctx.fillStyle = this.gridPaperPattern;\n            }\n            else if (this.bgPattern === BGPattern.QUADRILLE_PAPER) {\n                ctx.fillStyle = this.quadrillePaperPattern;\n            }\n            ctx.fillRect(0, 0, this.width + this.gridGap * 2, this.height + this.gridGap * 2);\n            ctx.restore();\n        }\n    }\n    generateGridPattern() {\n        const gap = this.gridGap;\n        const bgOffscreen = new OffscreenCanvas(gap * 2, gap * 2);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        ctx.fillStyle = this.gridFillStyle;\n        ctx.fillRect(0, 0, gap, gap);\n        ctx.fillRect(gap, gap, gap, gap);\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n    generateGridPaperPattern() {\n        const gap = this.gridPaperGap;\n        const bgOffscreen = new OffscreenCanvas(gap, gap);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        ctx.strokeStyle = this.gridPaperStrokeStyle;\n        ctx.strokeRect(0, 0, gap, gap);\n        ctx.setLineDash([2, 2]);\n        ctx.beginPath();\n        ctx.moveTo(gap / 2, 0);\n        ctx.lineTo(gap / 2, gap);\n        ctx.moveTo(0, gap / 2);\n        ctx.lineTo(gap, gap / 2);\n        ctx.stroke();\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n    generateQuadrillePaperPattern() {\n        const quadrillePaperVerticalMargin = this.quadrillePaperVerticalMargin;\n        const gap = this.quadrillePaperGap;\n        const quadrillePaperStrokeStyles = this.quadrillePaperStrokeStyles;\n        const height = quadrillePaperVerticalMargin * 2 + gap * 3;\n        const bgOffscreen = new OffscreenCanvas(this.width, height);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        for (let i = 0; i < quadrillePaperStrokeStyles.length; i++) {\n            ctx.strokeStyle = quadrillePaperStrokeStyles[i];\n            ctx.beginPath();\n            ctx.moveTo(0, quadrillePaperVerticalMargin + gap * i);\n            ctx.lineTo(this.width, quadrillePaperVerticalMargin + gap * i);\n            ctx.stroke();\n        }\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n}\n//# sourceMappingURL=Background.js.map","import { negativeRemainder } from \"../utils\";\nimport { generateCanvas } from '../utils';\nexport default class RuleAuxiliary {\n    width;\n    height;\n    ruleStrokeStyle;\n    ruleGap;\n    ruleUnitLen;\n    canvas;\n    ctx;\n    worldOffsetX;\n    worldOffsetY;\n    constructor(width, height, ruleStrokeStyle, ruleGap, ruleUnitLen) {\n        this.width = width;\n        this.height = height;\n        this.ruleStrokeStyle = ruleStrokeStyle;\n        this.ruleGap = ruleGap;\n        this.ruleUnitLen = ruleUnitLen;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n    }\n    draw(worldOffsetX, worldOffsetY) {\n        if (worldOffsetX !== this.worldOffsetX || worldOffsetY !== this.worldOffsetY) {\n            this.worldOffsetX = worldOffsetX;\n            this.worldOffsetY = worldOffsetY;\n            const ctx = this.ctx;\n            ctx.beginPath();\n            ctx.clearRect(0, 0, this.width, this.height);\n            ctx.strokeStyle = this.ruleStrokeStyle;\n            ctx.font = \"12px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = this.ruleStrokeStyle;\n            const offsetX = negativeRemainder(this.worldOffsetX, (this.ruleGap * 10));\n            const offsetY = negativeRemainder(this.worldOffsetY, (this.ruleGap * 10));\n            const offsetXRule = (this.worldOffsetX - this.worldOffsetX % (this.ruleGap * 10)) / (this.ruleGap * 10) * 10;\n            const offsetYRule = (this.worldOffsetY - this.worldOffsetY % (this.ruleGap * 10)) / (this.ruleGap * 10) * 10;\n            let i = 0;\n            let j = 0;\n            let coordX = -offsetX;\n            let coordY = -offsetY;\n            const fontGap = 3;\n            while (coordX <= this.width) {\n                let len = this.ruleUnitLen;\n                if (!(i % 10)) {\n                    len = this.ruleUnitLen * 2.5;\n                }\n                else if (!(i % 5)) {\n                    len = this.ruleUnitLen * 1.5;\n                }\n                ctx.moveTo(coordX, 0);\n                ctx.lineTo(coordX, len);\n                ctx.moveTo(coordX, this.height);\n                ctx.lineTo(coordX, this.height - len);\n                if (!(i % 10)) {\n                    ctx.textBaseline = \"top\";\n                    ctx.fillText(String(i + offsetXRule), coordX, len + fontGap);\n                    ctx.textBaseline = \"bottom\";\n                    ctx.fillText(String(i + offsetXRule), coordX, this.height - len - fontGap);\n                }\n                coordX += this.ruleGap;\n                i++;\n            }\n            ctx.textBaseline = \"middle\";\n            while (coordY <= this.height) {\n                let len = this.ruleUnitLen;\n                if (!(j % 10)) {\n                    len = this.ruleUnitLen * 2.5;\n                }\n                else if (!(j % 5)) {\n                    len = this.ruleUnitLen * 1.5;\n                }\n                ctx.moveTo(0, coordY);\n                ctx.lineTo(len, coordY);\n                ctx.moveTo(this.width, coordY);\n                ctx.lineTo(this.width - len, coordY);\n                if (!(j % 10)) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(String(j + offsetYRule), len + fontGap, coordY);\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(String(j + offsetYRule), this.width - len - fontGap, coordY);\n                }\n                coordY += this.ruleGap;\n                j++;\n            }\n            ctx.stroke();\n        }\n    }\n}\n//# sourceMappingURL=RuleAuxiliary.js.map","import { generateCanvas } from '../utils';\nexport default class Border {\n    width;\n    height;\n    borderStyle;\n    borderWidth;\n    canvas;\n    ctx;\n    constructor(width, height, borderStyle, borderWidth) {\n        this.width = width;\n        this.height = height;\n        this.borderStyle = borderStyle;\n        this.borderWidth = borderWidth;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n        this.draw();\n    }\n    draw() {\n        const ctx = this.ctx;\n        ctx.strokeStyle = this.borderStyle;\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeRect(0, 0, this.width, this.height);\n    }\n}\n//# sourceMappingURL=Border.js.map","import { generateCanvas } from '../utils';\nexport default class Writing {\n    store = [];\n    canvas;\n    ctx;\n    scale = 1;\n    width;\n    height;\n    constructor(width, height) {\n        this.width = width * this.scale;\n        this.height = height * this.scale;\n        this.canvas = generateCanvas(this.width, this.height);\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\n    }\n    refresh(worldOffsetX, worldOffsetY) {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        this.putImageData(worldOffsetX, worldOffsetY);\n    }\n    singlePointsWriting(points) {\n        const ctx = this.ctx;\n        const len = points.length;\n        for (let i = 0; i < len; i++) {\n            ctx.save();\n            ctx.beginPath();\n            const { x, y, fillStyle } = points[i];\n            ctx.fillStyle = fillStyle;\n            ctx.fillRect(x * this.scale, y * this.scale, 1, 1);\n            ctx.restore();\n        }\n    }\n    clear() {\n        this.store.length = 0;\n        this.doClean(0, 0, this.width, this.height);\n        this.pushImageData(0, 0);\n    }\n    doClean(x, y, width, height, determineIfThereHasContent = false) {\n        x = this.scale * x;\n        y = this.scale * y;\n        width = this.scale * width;\n        height = this.scale * height;\n        let hasContent = false;\n        if (determineIfThereHasContent) {\n            const imageData = this.ctx.getImageData(x, y, width, height);\n            const data = imageData.data;\n            const len = data.length;\n            for (let i = 0; i < len; i += 4) {\n                if (data[i + 3]) {\n                    hasContent = true;\n                    break;\n                }\n            }\n        }\n        this.ctx.clearRect(x, y, width, height);\n        return hasContent;\n    }\n    pushImageData(worldOffsetX, worldOffsetY) {\n        const imageData = this.ctx.getImageData(0, 0, this.width, this.height);\n        const store = this.store;\n        const len = store.length;\n        for (let i = len - 1; i >= 0; i--) {\n            const storeItem = store[i];\n            if (storeItem.worldOffsetX === worldOffsetX && storeItem.worldOffsetY === worldOffsetY) {\n                store.splice(i, 1);\n            }\n        }\n        store.push({\n            worldOffsetX,\n            worldOffsetY,\n            imageData\n        });\n    }\n    putImageData(worldOffsetX, worldOffsetY) {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        const displayData = new Uint8ClampedArray(total);\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            if (Math.abs(storeItemWorldOffsetX - worldOffsetX) >= width || Math.abs(storeItemWorldOffsetY - worldOffsetY) >= height) {\n                continue;\n            }\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - worldOffsetX + storeItemWorldOffsetX;\n                const displayRow = currentRow - worldOffsetY + storeItemWorldOffsetY;\n                if (displayCol >= 0\n                    &&\n                        displayRow >= 0\n                    &&\n                        displayCol < width\n                    &&\n                        displayRow < height) {\n                    const r = storeItemData[j];\n                    const g = storeItemData[j + 1];\n                    const b = storeItemData[j + 2];\n                    const a = storeItemData[j + 3];\n                    const displayJ = (displayCol + displayRow * width) * 4;\n                    displayData[displayJ] = r;\n                    displayData[displayJ + 1] = g;\n                    displayData[displayJ + 2] = b;\n                    displayData[displayJ + 3] = a;\n                }\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const displayImageData = new ImageData(displayData, width, height);\n        this.ctx.putImageData(displayImageData, 0, 0);\n    }\n    getWholeCanvas() {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        let minX;\n        let minY;\n        let maxX;\n        let maxY;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            if (minX === undefined || minX > storeItemWorldOffsetX) {\n                minX = storeItemWorldOffsetX;\n            }\n            if (minY === undefined || minY > storeItemWorldOffsetY) {\n                minY = storeItemWorldOffsetY;\n            }\n            if (maxX === undefined || maxX < storeItemWorldOffsetX) {\n                maxX = storeItemWorldOffsetX;\n            }\n            if (maxY === undefined || maxY < storeItemWorldOffsetY) {\n                maxY = storeItemWorldOffsetY;\n            }\n        }\n        const canvas = document.createElement('canvas');\n        if (minX === undefined || minY === undefined || maxX === undefined || maxY === undefined) {\n            canvas.width = 0;\n            canvas.height = 0;\n            return canvas;\n        }\n        maxX += width;\n        maxY += height;\n        const wholeWidth = (maxX - minX);\n        const wholeHeight = (maxY - minY);\n        const wholeTotal = wholeWidth * 4 * wholeHeight;\n        const displayData = new Uint8ClampedArray(wholeTotal);\n        let minPixelX = wholeWidth;\n        let minPixelY = wholeHeight;\n        let maxPixelX = 0;\n        let maxPixelY = 0;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - minX + storeItemWorldOffsetX;\n                const displayRow = currentRow - minY + storeItemWorldOffsetY;\n                const r = storeItemData[j];\n                const g = storeItemData[j + 1];\n                const b = storeItemData[j + 2];\n                const a = storeItemData[j + 3];\n                if (a !== 0) {\n                    if (displayCol < minPixelX) {\n                        minPixelX = displayCol;\n                    }\n                    if (displayRow < minPixelY) {\n                        minPixelY = displayRow;\n                    }\n                    if (displayCol > maxPixelX) {\n                        maxPixelX = displayCol;\n                    }\n                    if (displayRow > maxPixelY) {\n                        maxPixelY = displayRow;\n                    }\n                }\n                const displayJ = (displayCol + displayRow * wholeWidth) * 4;\n                displayData[displayJ] = r;\n                displayData[displayJ + 1] = g;\n                displayData[displayJ + 2] = b;\n                displayData[displayJ + 3] = a;\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const displayImageData = new ImageData(displayData, wholeWidth, wholeHeight);\n        const targetWidth = maxPixelX - minPixelX;\n        const targetHeight = maxPixelY - minPixelY;\n        canvas.width = targetWidth;\n        canvas.height = targetHeight;\n        const ctx = canvas.getContext('2d');\n        ctx.putImageData(displayImageData, -minPixelX, -minPixelY);\n        return canvas;\n    }\n    getPaperCanvas() {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        const minX = 0;\n        const minY = 0;\n        const maxX = width;\n        let maxY = 0;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            if (maxY === undefined || maxY < storeItemWorldOffsetY) {\n                maxY = storeItemWorldOffsetY;\n            }\n        }\n        maxY += height;\n        let maxPixelY = 0;\n        const canvas = document.createElement('canvas');\n        const wholeWidth = (maxX - minX);\n        const wholeHeight = (maxY - minY);\n        const wholeTotal = wholeWidth * 4 * wholeHeight;\n        const displayData = new Uint8ClampedArray(wholeTotal);\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - minX + storeItemWorldOffsetX;\n                const displayRow = currentRow - minY + storeItemWorldOffsetY;\n                if (displayCol >= minX\n                    &&\n                        displayRow >= minY\n                    &&\n                        displayCol < maxX\n                    &&\n                        displayRow < maxY) {\n                    const r = storeItemData[j];\n                    const g = storeItemData[j + 1];\n                    const b = storeItemData[j + 2];\n                    const a = storeItemData[j + 3];\n                    if (a !== 0) {\n                        if (displayRow > maxPixelY) {\n                            maxPixelY = displayRow;\n                        }\n                    }\n                    const displayJ = (displayCol + displayRow * wholeWidth) * 4;\n                    displayData[displayJ] = r;\n                    displayData[displayJ + 1] = g;\n                    displayData[displayJ + 2] = b;\n                    displayData[displayJ + 3] = a;\n                }\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const targetHeight = (Math.floor(maxPixelY / height) + 1) * height;\n        const displayImageData = new ImageData(displayData, maxX, maxY);\n        canvas.width = maxX;\n        canvas.height = targetHeight;\n        const ctx = canvas.getContext('2d');\n        ctx.putImageData(displayImageData, 0, 0);\n        return canvas;\n    }\n}\n//# sourceMappingURL=Writing.js.map","import { generateCanvas } from '../utils';\nexport default class Eraser {\n    width;\n    height;\n    canvas;\n    ctx;\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n    }\n    draw(cleanX, cleanY, cleanWidth, cleanHeight) {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.fillStyle = 'rgba(0,0,0,.1)';\n        this.ctx.strokeStyle = 'rgba(0,0,0,.15)';\n        this.ctx.rect(cleanX - cleanWidth / 2, cleanY - cleanHeight / 2, cleanWidth, cleanHeight);\n        this.ctx.fill();\n        this.ctx.stroke();\n        this.ctx.restore();\n        this.ctx.beginPath();\n    }\n}\n//# sourceMappingURL=Eraser.js.map","import { WriteModel } from '../enum';\nimport { generateCanvas } from '../utils';\nexport default class Eraser {\n    writing;\n    canvas;\n    ctx;\n    svgPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n    writeModel = WriteModel.WRITE;\n    width;\n    height;\n    voice;\n    color;\n    x = null;\n    y = null;\n    d = null;\n    prevX = null;\n    prevY = null;\n    prevD = null;\n    constructor(width, height, voice, writing) {\n        this.writing = writing;\n        this.width = width;\n        this.height = height;\n        this.voice = voice;\n        this.canvas = generateCanvas(this.width, this.height);\n        this.ctx = this.canvas.getContext('2d');\n    }\n    reset(color) {\n        this.color = color;\n    }\n    submit() {\n        this.x = null;\n        this.y = null;\n        this.d = null;\n        this.prevX = null;\n        this.prevY = null;\n        this.prevD = null;\n    }\n    draw(pointerType, { prevX, prevY, prevD, x, y, d }) {\n        const writingCtx = this.writing.ctx;\n        const endX = x;\n        const endY = y;\n        const endD = d;\n        const startX = prevX;\n        const startY = prevY;\n        const startD = prevD;\n        if (startX !== null && startY !== null && startD !== null) {\n            if (startX !== endX && startY !== endY) {\n                const pathStr = `M${startX},${startY}L${endX},${endY}`;\n                if (pointerType === 'pen') {\n                    this.svgPath.setAttribute('d', pathStr);\n                    const totalLength = this.svgPath.getTotalLength();\n                    if (!totalLength) {\n                        return;\n                    }\n                    ;\n                    const ratio = 1 / (window.devicePixelRatio * 2);\n                    let prevD = -1 * this.voice;\n                    const fragments = [];\n                    for (let i = 0; i < totalLength; i += ratio) {\n                        let currentD = startD * (totalLength - i) / totalLength + endD * i / totalLength;\n                        if (!fragments.length) {\n                            fragments.push([i, i]);\n                            prevD = currentD;\n                        }\n                        else {\n                            const lastFragment = fragments[fragments.length - 1];\n                            if (Math.abs(currentD - prevD) < ratio) {\n                                lastFragment[1] = i;\n                            }\n                            else {\n                                fragments.push([lastFragment[1], i]);\n                                prevD = currentD;\n                            }\n                        }\n                    }\n                    fragments[fragments.length - 1][1] = totalLength;\n                    fragments.forEach(fragment => {\n                        const avgI = (fragment[0] + fragment[fragment.length - 1]) / 2;\n                        let avgD = startD * (totalLength - avgI) / totalLength + endD * avgI / totalLength;\n                        fragment[2] = avgD;\n                    });\n                    writingCtx.save();\n                    writingCtx.strokeStyle = this.color;\n                    writingCtx.fillStyle = this.color;\n                    for (let i = 0; i < fragments.length; i++) {\n                        const [start, end, d] = fragments[i];\n                        writingCtx.beginPath();\n                        writingCtx.lineWidth = d;\n                        writingCtx.setLineDash([0, start, end, Number.MAX_SAFE_INTEGER]);\n                        const path = new Path2D(pathStr);\n                        writingCtx.stroke(path);\n                        if (d >= 3) {\n                            const { x, y } = this.svgPath.getPointAtLength(start);\n                            writingCtx.save();\n                            writingCtx.globalAlpha = 1;\n                            writingCtx.fillStyle = this.color;\n                            writingCtx.beginPath();\n                            writingCtx.arc(x, y, d / 2 - 1, 0, Math.PI * 2);\n                            writingCtx.fill();\n                            writingCtx.restore();\n                        }\n                    }\n                    if (startD >= 3) {\n                        writingCtx.save();\n                        writingCtx.globalAlpha = 1;\n                        writingCtx.fillStyle = this.color;\n                        writingCtx.beginPath();\n                        writingCtx.arc(startX, startY, startD / 2 - 1, 0, Math.PI * 2);\n                        writingCtx.fill();\n                        writingCtx.restore();\n                    }\n                    if (endD >= 3) {\n                        writingCtx.save();\n                        writingCtx.globalAlpha = 1;\n                        writingCtx.fillStyle = this.color;\n                        writingCtx.beginPath();\n                        writingCtx.arc(endX, endY, endD / 2 - 1, 0, Math.PI * 2);\n                        writingCtx.fill();\n                        writingCtx.restore();\n                    }\n                    writingCtx.restore();\n                }\n                else {\n                    writingCtx.save();\n                    writingCtx.lineJoin = 'round';\n                    writingCtx.lineCap = 'round';\n                    writingCtx.strokeStyle = this.color;\n                    writingCtx.beginPath();\n                    writingCtx.lineWidth = d;\n                    const path = new Path2D(pathStr);\n                    writingCtx.stroke(path);\n                    console.log(d);\n                }\n            }\n        }\n    }\n    pushPoints({ x, y, pressure, pointerType }) {\n        let prevX = this.prevX;\n        let prevY = this.prevY;\n        const prevD = this.d;\n        if (this.x === null || (x !== this.x && y !== this.y)) {\n            prevX = this.x;\n            prevY = this.y;\n            this.prevX = prevX;\n            this.prevY = prevY;\n        }\n        this.x = x;\n        this.y = y;\n        if (pointerType === 'pen') {\n            const minPressure = 0.2;\n            const maxPressure = 0.5;\n            pressure = Math.min(Math.max(minPressure, pressure), maxPressure);\n            const d = this.voice * (.5 + 1.5 * (pressure - minPressure) / (maxPressure - minPressure));\n            this.d = d;\n            this.draw(pointerType, {\n                prevX,\n                prevY,\n                prevD,\n                x,\n                y,\n                d\n            });\n        }\n        else {\n            this.d = this.voice;\n            this.draw(pointerType, {\n                prevX,\n                prevY,\n                prevD,\n                x,\n                y,\n                d: this.d\n            });\n        }\n    }\n}\n//# sourceMappingURL=BrushDrawing.js.map","import { Stack } from './stack';\nimport { WriteModel, BGPattern, ScrollDirection, ShapeType } from './enum';\nimport { debounce, getTripleTouchAngleAndCenter, rotateCoordinate, negativeRemainder } from './utils';\nimport ToolShape from './component/ToolShape';\nimport Background from './component/Background';\nimport RuleAuxiliary from './component/RuleAuxiliary';\nimport Border from './component/Border';\nimport Writing from './component/Writing';\nimport Eraser from './component/Eraser';\nimport BrushDrawing from './component/BrushDrawing';\nexport { WriteModel, BGPattern, ScrollDirection, ShapeType };\nfunction isTouchDevice() {\n    return 'ontouchstart' in self;\n}\n/**\n * 滚动范围\n */\nconst defaultScrollRange = [[null, null], [null, null]];\n/**\n * 滚动方向\n */\nconst defaultScrollDirection = ScrollDirection.ALL;\n/**\n * 背景格式\n */\nconst defaultBGPattern = BGPattern.GRID;\n/**\n * 是否启用全览模式\n */\n// const defaultEnableEagleEyeMode = false;\n/**\n * 绘画模式 书写模式 绘画模式\n */\nconst defaultWriteModel = WriteModel.WRITE;\n/**\n * 是否使用背景\n */\nconst defaultEnableBG = true;\n/**\n * 棋盘格子的间距\n */\nconst defaultGridGap = 100;\n/**\n * 田字格的尺寸\n */\nconst defaultGridPaperGap = 100;\n/**\n * 四线格纵向空白\n */\nconst defaultQuadrillePaperVerticalMargin = 40;\n/**\n * 四线格线的间距\n */\nconst defaultQuadrillePaperGap = 30;\n/**\n * 棋盘格子的填充色\n */\nconst defaultGridFillStyle = 'rgb(250,250,250)';\n/**\n * 田字格边框颜色\n */\nconst defaultGridPaperStrokeStyle = 'green';\n/**\n * 四线格四条线的颜色\n */\nconst defaultQuadrillePaperStrokeStyles = ['rgba(0,0,255,.5)', 'rgba(255,0,0,.5)', 'rgba(0,0,255,1)', 'rgba(0,0,255,.5)'];\n/**\n * 是否使用标尺\n */\nconst defaultRule = true;\n/**\n * 标尺的间距\n */\nconst defaultRuleGap = 10;\n/**\n * 标尺刻度的长度\n */\nconst defaultRuleUnitLen = 5;\n/**\n * 标尺的颜色\n */\nconst defaultRuleStrokeStyle = 'rgba(0,0,0,0.5)';\n/**\n * 笔尖的粗细\n */\nconst defaultVoice = 1;\n/**\n * 墨水颜色\n */\nconst defaultColor = 'rgb(0,0,0)';\n/**\n * 是否启用操作历史\n */\nconst defaultStack = true;\n/**\n * 橡皮擦除的宽度\n */\nconst defaultCleanWidth = 20;\n/**\n * 橡皮擦除的高度\n */\nconst defaultCleanHeight = 20;\n/**\n * 滚动的时候执行的次数\n */\nconst defaultMoveCountTotal = 20;\n/**\n * 是否锁定书写\n */\nconst defaultWriteLocked = false;\n/**\n * 是否锁定拖拽\n */\nconst defaultDragLocked = false;\n/**\n * 是否显示边框\n */\nconst defaultShowBorder = true;\n/**\n * 边框的颜色\n */\nconst defaultBorderStyle = '#333';\n/**\n * 边框的宽度\n */\nconst defaultBorderWidth = 2;\n/**\n * 是否使用尺子等工具\n */\nconst defaultUseShapeType = false;\nconst defaultOptions = {\n    scrollRange: defaultScrollRange,\n    scrollDirection: defaultScrollDirection,\n    bgPattern: defaultBGPattern,\n    writeModel: defaultWriteModel,\n    enableBG: defaultEnableBG,\n    gridGap: defaultGridGap,\n    gridPaperGap: defaultGridPaperGap,\n    quadrillePaperVerticalMargin: defaultQuadrillePaperVerticalMargin,\n    quadrillePaperGap: defaultQuadrillePaperGap,\n    gridFillStyle: defaultGridFillStyle,\n    gridPaperStrokeStyle: defaultGridPaperStrokeStyle,\n    quadrillePaperStrokeStyles: defaultQuadrillePaperStrokeStyles,\n    rule: defaultRule,\n    ruleGap: defaultRuleGap,\n    ruleUnitLen: defaultRuleUnitLen,\n    ruleStrokeStyle: defaultRuleStrokeStyle,\n    voice: defaultVoice,\n    color: defaultColor,\n    stack: defaultStack,\n    cleanWidth: defaultCleanWidth,\n    cleanHeight: defaultCleanHeight,\n    moveCountTotal: defaultMoveCountTotal,\n    writeLocked: defaultWriteLocked,\n    dragLocked: defaultDragLocked,\n    showBorder: defaultShowBorder,\n    borderStyle: defaultBorderStyle,\n    borderWidth: defaultBorderWidth,\n    useShapeType: defaultUseShapeType\n};\nexport default class Board {\n    container;\n    width;\n    height;\n    worldOffsetX = 0;\n    worldOffsetY = 0;\n    scrolling = false;\n    cleanState = false;\n    cleanX;\n    cleanY;\n    cleanPress = false;\n    stackObj;\n    moveT = false;\n    debounceBindOnChange;\n    toolShape;\n    activateToolShape = false;\n    toolShapeCenterX;\n    toolShapeCenterY;\n    toolShapeAngle;\n    background;\n    ruleAuxiliary;\n    border;\n    writing;\n    eraser;\n    eraserHasContent = false;\n    toolShapeType = ShapeType.RULER;\n    brushDrawing;\n    scrollRange;\n    scrollDirection;\n    bgPattern;\n    writeModel;\n    enableBG;\n    gridGap;\n    gridPaperGap;\n    quadrillePaperVerticalMargin;\n    quadrillePaperGap;\n    gridFillStyle;\n    gridPaperStrokeStyle;\n    quadrillePaperStrokeStyles;\n    rule;\n    ruleGap;\n    ruleUnitLen;\n    ruleStrokeStyle;\n    voice;\n    color;\n    cleanWidth;\n    cleanHeight;\n    stack;\n    moveCountTotal;\n    writeLocked;\n    dragLocked;\n    showBorder;\n    borderStyle;\n    borderWidth;\n    useShapeType;\n    containerOffset;\n    onChange;\n    constructor(container, options = defaultOptions) {\n        this.container = container;\n        this.scrollRange = options.scrollRange ?? defaultScrollRange;\n        this.scrollDirection = options.scrollDirection ?? defaultScrollDirection;\n        this.bgPattern = options.bgPattern ?? defaultBGPattern;\n        this.writeModel = options.writeModel ?? defaultWriteModel;\n        this.enableBG = options.enableBG ?? defaultEnableBG;\n        this.gridGap = options.gridGap ?? defaultGridGap;\n        this.gridPaperGap = options.gridPaperGap ?? defaultGridPaperGap;\n        this.quadrillePaperVerticalMargin = options.quadrillePaperVerticalMargin ?? defaultQuadrillePaperVerticalMargin;\n        this.quadrillePaperGap = options.quadrillePaperGap ?? defaultQuadrillePaperGap;\n        this.gridFillStyle = options.gridFillStyle ?? defaultGridFillStyle;\n        this.gridPaperStrokeStyle = options.gridPaperStrokeStyle ?? defaultGridPaperStrokeStyle;\n        this.quadrillePaperStrokeStyles = options.quadrillePaperStrokeStyles ?? defaultQuadrillePaperStrokeStyles;\n        this.rule = options.rule ?? defaultRule;\n        this.ruleGap = options.ruleGap ?? defaultRuleGap;\n        this.ruleUnitLen = options.ruleUnitLen ?? defaultRuleUnitLen;\n        this.ruleStrokeStyle = options.ruleStrokeStyle ?? defaultRuleStrokeStyle;\n        this.voice = options.voice ?? defaultVoice;\n        this.color = options.color ?? defaultColor;\n        this.stack = options.stack ?? defaultStack;\n        this.cleanWidth = options.cleanWidth ?? defaultCleanWidth;\n        this.cleanHeight = options.cleanHeight ?? defaultCleanHeight;\n        this.moveCountTotal = options.moveCountTotal ?? defaultMoveCountTotal;\n        this.writeLocked = options.writeLocked ?? defaultWriteLocked;\n        this.dragLocked = options.dragLocked ?? defaultDragLocked;\n        this.showBorder = options.showBorder ?? defaultShowBorder;\n        this.borderStyle = options.borderStyle ?? defaultBorderStyle;\n        this.borderWidth = options.borderWidth ?? defaultBorderWidth;\n        this.useShapeType = options.useShapeType ?? defaultUseShapeType;\n        this.containerOffset = options.containerOffset ?? (() => {\n            const scrollingElement = document.scrollingElement;\n            const rect = this.container.getBoundingClientRect();\n            return {\n                x: rect.x + scrollingElement.scrollLeft,\n                y: rect.y + scrollingElement.scrollTop\n            };\n        });\n        this.onChange = options.onChange;\n        this.debounceBindOnChange = debounce(this.triggerOnChange, 500);\n        const rect = container.getBoundingClientRect();\n        this.width = rect.width;\n        this.height = rect.height;\n        if (this.stack) {\n            this.stackObj = new Stack(this.width, this.height);\n            this.stackObj.restoreState = (store) => {\n                const storeLen = store.length;\n                const lastStoreItem = store[storeLen - 1];\n                const prevWorldOffsetX = this.worldOffsetX;\n                const prevWorldOffsetY = this.worldOffsetY;\n                const targetWorldOffsetX = lastStoreItem.worldOffsetX;\n                const targetWorldOffsetY = lastStoreItem.worldOffsetY;\n                const offsetX = targetWorldOffsetX - prevWorldOffsetX;\n                const offsetY = targetWorldOffsetY - prevWorldOffsetY;\n                if (!offsetX && !offsetY) {\n                    this.worldOffsetX = lastStoreItem.worldOffsetX;\n                    this.worldOffsetY = lastStoreItem.worldOffsetY;\n                    this.writing.store = store;\n                    this.draw();\n                }\n                else {\n                    const preOffsetX = offsetX / this.moveCountTotal;\n                    const preOffsetY = offsetY / this.moveCountTotal;\n                    this.writing.store = store;\n                    this.moveT = true;\n                    this.doMove(preOffsetX, preOffsetY);\n                }\n            };\n        }\n        this.background = new Background(this.width, this.height, this.gridGap, this.gridFillStyle, this.gridPaperGap, this.gridPaperStrokeStyle, this.quadrillePaperVerticalMargin, this.quadrillePaperGap, this.quadrillePaperStrokeStyles);\n        this.container.append(this.background.canvas);\n        this.ruleAuxiliary = new RuleAuxiliary(this.width, this.height, this.ruleStrokeStyle, this.ruleGap, this.ruleUnitLen);\n        this.container.append(this.ruleAuxiliary.canvas);\n        this.border = new Border(this.width, this.height, this.borderStyle, this.borderWidth);\n        this.container.append(this.border.canvas);\n        this.writing = new Writing(this.width, this.height);\n        this.container.append(this.writing.canvas);\n        this.toolShape = new ToolShape(this.width, this.height, this.voice, container, this.getPageCoords);\n        this.container.append(this.toolShape.canvas);\n        this.toolShapeCenterX = 500;\n        this.toolShapeCenterY = 300;\n        this.toolShapeAngle = 10;\n        this.eraser = new Eraser(this.width, this.height);\n        this.container.append(this.eraser.canvas);\n        this.brushDrawing = new BrushDrawing(this.width, this.height, this.voice, this.writing);\n        this.container.append(this.brushDrawing.canvas);\n        this.loadEvent();\n        this.draw();\n    }\n    setVoice(voice = 1) {\n        this.voice = voice;\n        this.brushDrawing.voice = voice;\n        this.brushDrawing.d = voice;\n        this.brushDrawing.maxD = voice * 2;\n    }\n    showBG() {\n        this.enableBG = true;\n        this.draw();\n    }\n    hideBG() {\n        this.enableBG = false;\n        this.draw();\n    }\n    showRule() {\n        this.rule = true;\n        this.draw();\n    }\n    hideRule() {\n        this.rule = false;\n        this.draw();\n    }\n    showToolShape() {\n        this.useShapeType = true;\n        this.draw();\n    }\n    hideToolShape() {\n        this.useShapeType = false;\n        this.draw();\n    }\n    setToolShapeType(shapeType) {\n        this.toolShapeType = shapeType;\n        this.draw();\n    }\n    adjustOffset() {\n        const [[minX, maxX], [minY, maxY]] = this.scrollRange;\n        if (typeof minX === 'number') {\n            this.worldOffsetX = Math.max(minX, this.worldOffsetX);\n        }\n        if (typeof maxX === 'number') {\n            this.worldOffsetX = Math.min(maxX, this.worldOffsetX);\n        }\n        if (typeof minY === 'number') {\n            this.worldOffsetY = Math.max(minY, this.worldOffsetY);\n        }\n        if (typeof maxY === 'number') {\n            this.worldOffsetY = Math.min(maxY, this.worldOffsetY);\n        }\n        this.worldOffsetX = Math.round(this.worldOffsetX);\n        this.worldOffsetY = Math.round(this.worldOffsetY);\n    }\n    doMove(preOffsetX, preOffsetY, i = 0) {\n        if (this.scrollDirection === ScrollDirection.ALL) {\n            this.worldOffsetX += preOffsetX;\n            this.worldOffsetY += preOffsetY;\n        }\n        else if (this.scrollDirection === ScrollDirection.X) {\n            this.worldOffsetX += preOffsetX;\n        }\n        else if (this.scrollDirection === ScrollDirection.Y) {\n            this.worldOffsetY += preOffsetY;\n        }\n        this.adjustOffset();\n        this.draw();\n        self.requestAnimationFrame(() => {\n            if (this.moveT && i < this.moveCountTotal) {\n                this.doMove(preOffsetX, preOffsetY, ++i);\n            }\n            else {\n                this.moveT = false;\n            }\n        });\n    }\n    scrollBy(x = 0, y = 0) {\n        if (!this.dragLocked) {\n            const preOffsetX = x / this.moveCountTotal;\n            const preOffsetY = y / this.moveCountTotal;\n            this.moveT = true;\n            this.doMove(preOffsetX, preOffsetY);\n        }\n    }\n    clear() {\n        this.worldOffsetX = 0;\n        this.worldOffsetY = 0;\n        this.writing.clear();\n        this.draw();\n        this.stackObj.saveState([...this.writing.store]);\n    }\n    triggerOnChange() {\n        window.requestIdleCallback(() => {\n            if (this.onChange) {\n                const canvas = this.exportAsCanvas();\n                this.onChange(canvas);\n            }\n        });\n    }\n    exportAsCanvas() {\n        return this.writing.getWholeCanvas();\n    }\n    exportAsPaperCanvas() {\n        const imageCanvas = this.writing.getPaperCanvas();\n        const canvas = document.createElement('canvas');\n        canvas.width = imageCanvas.width;\n        canvas.height = imageCanvas.height;\n        const ctx = canvas.getContext('2d');\n        if (this.enableBG) {\n            this.loadBackground(ctx);\n        }\n        ctx.drawImage(imageCanvas, 0, 0);\n        return canvas;\n    }\n    undo() {\n        this.stackObj.undo();\n    }\n    redo() {\n        this.stackObj.redo();\n    }\n    clean() {\n        this.cleanState = true;\n    }\n    unclean() {\n        this.cleanState = false;\n    }\n    draw() {\n        this.loadBackground();\n        this.loadRule();\n        this.writing.refresh(this.worldOffsetX, this.worldOffsetY);\n        this.drawEraser();\n        this.drawToolShape();\n        this.debounceBindOnChange();\n    }\n    doPushPoints(x, y, event) {\n        if (event.pointerType === 'pen') {\n        }\n        this.brushDrawing.pushPoints({ x, y, pressure: event.pressure, pointerType: event.pointerType });\n    }\n    loadEvent() {\n        let hasMoved = false;\n        let hasWrited = false;\n        let isDoubleTouch = false;\n        let isToolShapeDoubleTouch = false;\n        let rotationCenter;\n        let turnStartAngle = 0;\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragStartTime = 0;\n        let dragEndX = 0;\n        let dragEndY = 0;\n        let dragEndTime = 0;\n        let isSingleTouch = false;\n        const handleWriteStart = (coords, event) => {\n            const x = coords.pageX;\n            const y = coords.pageY;\n            this.brushDrawing.reset(this.color);\n            hasMoved = false;\n            hasWrited = false;\n            let conformingToDistance = false;\n            if (this.useShapeType) {\n                const distanceAndPoint = this.toolShape.getNearestDistanceAndPoint(coords.pageX, coords.pageY, this.voice, this.color);\n                conformingToDistance = distanceAndPoint.conformingToDistance;\n            }\n            if (!this.cleanState && conformingToDistance) {\n                this.activateToolShape = true;\n            }\n            else {\n                if (!this.cleanState && this.useShapeType && this.toolShape.isPointInPath(coords.pageX, coords.pageY, 'evenodd')) {\n                    isSingleTouch = false;\n                }\n                else if (!this.cleanState && !this.useShapeType) {\n                    this.doPushPoints(x, y, event);\n                }\n                this.activateToolShape = false;\n            }\n            if (this.cleanState) {\n                this.cleanX = x;\n                this.cleanY = y;\n                this.cleanPress = true;\n                this.drawEraser();\n            }\n        };\n        const handleTouchStart = (event) => {\n            this.moveT = false;\n            this.scrolling = false;\n            const touches = event.touches;\n            const coords = this.getPageCoords(touches);\n            if (touches.length === 2) {\n                isDoubleTouch = true;\n                isSingleTouch = false;\n                if (this.dragLocked) {\n                    return;\n                }\n                dragEndX = coords.pageX;\n                dragEndY = coords.pageY;\n                dragEndTime = performance.now();\n                if (this.cleanState) {\n                    this.cleanPress = false;\n                    this.draw();\n                }\n                let isPointInPath = false;\n                if (this.useShapeType && this.toolShape.isPointInPath(coords.pageX, coords.pageY, 'nonzero')) {\n                    isPointInPath = true;\n                }\n                if (isPointInPath) {\n                    isToolShapeDoubleTouch = true;\n                    rotationCenter = { x: coords.pageX, y: coords.pageY };\n                }\n                else {\n                    isToolShapeDoubleTouch = false;\n                }\n            }\n            else if (touches.length === 1 && !this.writeLocked) {\n                isSingleTouch = true;\n            }\n            else {\n                isSingleTouch = false;\n            }\n        };\n        const handlePointerdown = (event) => {\n            isSingleTouch = true;\n            event.preventDefault();\n            if (!this.writeLocked) {\n                setTimeout(() => {\n                    if (isSingleTouch) {\n                        const { pageX, pageY } = event;\n                        const coords = this.getPageCoords([{ pageX, pageY }]);\n                        handleWriteStart(coords, event);\n                    }\n                });\n            }\n        };\n        const doInsertPointByToolShape = (nearestPoints) => {\n            this.writing.singlePointsWriting(nearestPoints);\n        };\n        const handleWriteMove = (coords, event) => {\n            const x = coords.pageX;\n            const y = coords.pageY;\n            hasMoved = true;\n            hasWrited = true;\n            if (this.cleanState) {\n                this.cleanX = x;\n                this.cleanY = y;\n                this.doClean(x, y);\n                this.drawEraser();\n            }\n            else {\n                if (this.useShapeType && this.activateToolShape) {\n                    const lineWidth = this.voice;\n                    const { drawPoints } = this.toolShape.getNearestDistanceAndPoint(coords.pageX, coords.pageY, lineWidth, this.color);\n                    doInsertPointByToolShape(drawPoints);\n                }\n                else {\n                    this.doPushPoints(x, y, event);\n                }\n            }\n        };\n        const handlePointermove = (event) => {\n            setTimeout(() => {\n                if (isSingleTouch) {\n                    const { pageX, pageY } = event;\n                    const coords = this.getPageCoords([{ pageX, pageY }]);\n                    handleWriteMove(coords, event);\n                }\n            });\n        };\n        const handleTouchMove = (event) => {\n            const touches = event.touches;\n            if (isDoubleTouch) {\n                if (this.dragLocked) {\n                    return;\n                }\n                dragStartX = dragEndX;\n                dragStartY = dragEndY;\n                dragStartTime = dragEndTime;\n                const coords = this.getPageCoords(touches);\n                dragEndX = coords.pageX;\n                dragEndY = coords.pageY;\n                dragEndTime = performance.now();\n                if (this.useShapeType && isToolShapeDoubleTouch) {\n                    const deltaX = dragEndX - dragStartX;\n                    const deltaY = dragEndY - dragStartY;\n                    this.toolShapeCenterX += deltaX;\n                    this.toolShapeCenterY += deltaY;\n                    if (event.touches.length === 2) {\n                        const { angle } = getTripleTouchAngleAndCenter(event);\n                        let deltaAngle = angle - turnStartAngle;\n                        deltaAngle %= 30;\n                        turnStartAngle = angle;\n                        const [newX, newY] = rotateCoordinate(rotationCenter.x, rotationCenter.y, deltaAngle, this.toolShapeCenterX, this.toolShapeCenterY);\n                        this.toolShapeCenterX = newX;\n                        this.toolShapeCenterY = newY;\n                        this.toolShapeAngle += deltaAngle;\n                        this.draw();\n                    }\n                }\n                else {\n                    let deltaX = 0;\n                    let deltaY = 0;\n                    if (this.scrollDirection === ScrollDirection.ALL) {\n                        deltaX = dragEndX - dragStartX;\n                        deltaY = dragEndY - dragStartY;\n                    }\n                    else if (this.scrollDirection === ScrollDirection.X) {\n                        deltaX = dragEndX - dragStartX;\n                    }\n                    else if (this.scrollDirection === ScrollDirection.Y) {\n                        deltaY = dragEndY - dragStartY;\n                    }\n                    this.worldOffsetX -= deltaX;\n                    this.worldOffsetY -= deltaY;\n                    this.adjustOffset();\n                    this.draw();\n                }\n            }\n        };\n        const scrollDecay = (speedX, speedY) => {\n            this.scrolling = true;\n            const minSpeed = 0.1;\n            let t = 0;\n            const _scrollDecay = (speedX, speedY) => {\n                if (Math.abs(speedX) > minSpeed || Math.abs(speedY) > minSpeed) {\n                    this.worldOffsetX -= speedX;\n                    this.worldOffsetY -= speedY;\n                    this.adjustOffset();\n                    this.draw();\n                    const ratio = Math.max((99 - 0.01 * t++), 50) / 100;\n                    speedX = ratio * speedX;\n                    speedY = ratio * speedY;\n                    self.requestAnimationFrame(() => {\n                        if (this.scrolling) {\n                            _scrollDecay(speedX, speedY);\n                        }\n                    });\n                }\n                else {\n                    this.scrolling = false;\n                }\n            };\n            _scrollDecay(speedX, speedY);\n        };\n        const handleWriteEnd = (coords) => {\n            if (isDoubleTouch) {\n                if (this.dragLocked) {\n                    return;\n                }\n                const deltaX = dragEndX - dragStartX;\n                const deltaY = dragEndY - dragStartY;\n                const deltaTime = dragEndTime - dragStartTime;\n                let speedX = 0;\n                let speedY = 0;\n                if (this.scrollDirection === ScrollDirection.ALL) {\n                    speedX = deltaX / deltaTime;\n                    speedY = deltaY / deltaTime;\n                }\n                else if (this.scrollDirection === ScrollDirection.X) {\n                    speedX = deltaX / deltaTime;\n                }\n                else if (this.scrollDirection === ScrollDirection.Y) {\n                    speedY = deltaY / deltaTime;\n                }\n                if (!isToolShapeDoubleTouch) {\n                    scrollDecay(speedX, speedY);\n                }\n            }\n        };\n        const handleTouchEnd = (event) => {\n            const touches = event.changedTouches;\n            const coords = this.getPageCoords(touches);\n            handleWriteEnd(coords);\n        };\n        const handlePointerup = (event) => {\n            this.brushDrawing.submit();\n            if (isSingleTouch) {\n                if (!this.cleanState || this.eraserHasContent) {\n                    this.eraserHasContent = false;\n                    this.writing.pushImageData(this.worldOffsetX, this.worldOffsetY);\n                    if (this.stack && hasWrited) {\n                        this.stackObj.saveState(this.writing.store);\n                    }\n                }\n            }\n            if (this.cleanState) {\n                this.cleanPress = false;\n                this.draw();\n            }\n            isDoubleTouch = false;\n            isSingleTouch = false;\n            this.toolShape.prevPoint = null;\n        };\n        const container = this.container;\n        if (isTouchDevice()) {\n            container.addEventListener(\"touchstart\", handleTouchStart, { passive: true });\n            container.addEventListener(\"touchmove\", handleTouchMove, { passive: true });\n            container.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\n        }\n        container.addEventListener(\"pointerdown\", handlePointerdown);\n        self.addEventListener(\"pointermove\", handlePointermove);\n        self.addEventListener(\"pointerup\", handlePointerup);\n    }\n    getPageCoords = (touches) => {\n        const { x: containerX, y: containerY } = this.containerOffset();\n        const length = touches.length;\n        let totalX = 0;\n        let totalY = 0;\n        for (let i = 0; i < length; i++) {\n            const touch = touches[i];\n            totalX += touch.pageX - containerX;\n            totalY += touch.pageY - containerY;\n        }\n        totalX /= length;\n        totalY /= length;\n        return { pageX: totalX, pageY: totalY };\n    };\n    drawEraser() {\n        if (this.cleanState && this.cleanPress) {\n            this.eraser.draw(this.cleanX, this.cleanY, this.cleanWidth, this.cleanHeight);\n        }\n        this.eraser.canvas.style.opacity = (this.cleanState && this.cleanPress) ? '1' : '0';\n    }\n    doClean(writeEndX, writeEndY) {\n        const hasContent = this.writing.doClean(writeEndX - this.cleanWidth / 2, writeEndY - this.cleanHeight / 2, this.cleanWidth, this.cleanHeight, true);\n        if (hasContent) {\n            this.eraserHasContent = true;\n        }\n    }\n    loadBackground(ctx = null) {\n        let coordX = 0;\n        let coordY = 0;\n        let background;\n        if (!ctx) {\n            const offsetX = negativeRemainder(this.worldOffsetX, this.gridGap * 2);\n            const offsetY = negativeRemainder(this.worldOffsetY, this.gridGap * 2);\n            coordX = -offsetX;\n            coordY = -offsetY;\n            background = this.background;\n        }\n        else {\n            const canvas = ctx.canvas;\n            const { width, height } = canvas;\n            background = new Background(width, height, this.gridGap, this.gridFillStyle, this.gridPaperGap, this.gridPaperStrokeStyle, this.quadrillePaperVerticalMargin, this.quadrillePaperGap, this.quadrillePaperStrokeStyles);\n        }\n        if (this.enableBG) {\n            background.draw(coordX, coordY, this.bgPattern);\n            if (ctx) {\n                ctx.drawImage(background.canvas, 0, 0);\n            }\n        }\n        background.canvas.style.opacity = this.enableBG ? '1' : '0';\n    }\n    loadRule() {\n        if (this.rule) {\n            this.ruleAuxiliary.draw(this.worldOffsetX, this.worldOffsetY);\n        }\n        this.ruleAuxiliary.canvas.style.opacity = this.rule ? '1' : '0';\n    }\n    drawToolShape() {\n        if (this.useShapeType) {\n            this.toolShape.draw(this.toolShapeCenterX, this.toolShapeCenterY, this.toolShapeAngle, this.toolShapeType);\n        }\n        this.toolShape.canvas.style.opacity = this.useShapeType ? '1' : '0';\n    }\n}\nexport { Board };\n//# sourceMappingURL=index.js.map"],"names":["Stack","width","height","undoStack","redoStack","constructor","this","restoreState","saveState","store","push","length","undo","lastState","pop","previousState","data","Uint8ClampedArray","worldOffsetX","worldOffsetY","imageData","ImageData","doRestoreState","redo","nextState","WriteModel","BGPattern","ScrollDirection","ShapeType","RotateCoordinates","angle","x0","y0","angleInRadians","Math","PI","cosAngle","cos","sinAngle","sin","x","y","x1","y1","rotateAngle","angle0","calculateRotatedPoint","rx","ry","r","_angle","angleRad","_angleRad","negativeRemainder","a","b","generateCanvas","canvas","document","createElement","Object","assign","style","left","top","position","exports","Ruler","ctx","cm","mm","path","marginH","degreeNumber","getOutlineCtx","_x","_y","outlineVoice","strokeStyle","c","OffscreenCanvas","getContext","generatorOuterBorder","lineWidth","stroke","_cx","_cy","voice","rotateCoordinates","pathStr","join","offestX","beginWaveX","beginWaveY","endWaveX","waveUnit","waveUnitY","waveY","currentWaveUnit","Path2D","draw","cx","cy","clearRect","save","beginPath","fillStyle","fill","restore","font","textAlign","textBaseline","cmLen","textPos","mmLen","halfCmLen","i","currentX","moveTo","lineTo","translate","rotate","fillText","String","j","currentMmX","isPointInPath","fillRule","Compass$1","middleR","smallR","middleGap","startAngle","endAngle","innerStartAngle","innerEndAngle","middleInsideR","middleOutsideR","innerCx","innerCy","arc","closePath","drawDegree","smallUnitL","unitL","bigUnitL","ruleFontSize","fontGap","showText","showSmall","showMiddle","textOnInner","reverse","unitS","startX","startY","endX","endY","textX","Number","textY","toString","drawContent","drawPosition","Compass","container","getPageCoords","toolShape","outsideR","insideR","pointerW","firstPointerAngle","secondPointerAngle","pointer1","pointer2","loadEvent","calculateRotationAngle","dragStartX","dragStartY","dragEndX","dragEndY","aX","aY","bX","bY","cosTheta","sqrt","theta","acos","doTurn","movePointer1","movePointer2","turnPoinerStart","coords","event","pageX","pageY","stopImmediatePropagation","handleTouchStart","touches","handleMouseStart","preventDefault","turnPointerMove","deltaAngle","reset","handleMouseMove","handleTouchMove","turnPointerEnd","handleTouchEnd","handleMouseEnd","self","addEventListener","passive","drawBorder","drawPointer","globalCompositeOperation","offscreen1","c2","drawImage","fillRect","generatorPointer","pointerAngle","showBig","total","drawFixedPoint","isPointInStroke","Triangle","degreeNumberH","degreeNumberV","marginV","marginC","gap","smallX","smallY","smallWidth","smallHeight","currentY","currentMmY","ToolShape","w","h","getNearestDistanceAndPointVoice","outlineCtx","outlineImageData","outline","outlineMap","longestDistance","gatherAreaWidth","prevPoint","_toolShapeType","ruler","compass","compass360","rightAngleTriangle","isoscelesTriangle","Compass360","toolShapeType","shape","RULER","COMPASS","COMPASS360","RIGHT_ANGLE_TRIANGLE","SOSCELESL_TRIANGLE","getGathers","x2","y2","topLeftX","min","topLeftY","bottomRightX","max","bottomRightY","gathers","getNearestDistanceAndPoint","getImageData","getOutline","getOutlineMap","len","innerAreaPoints","nearestDistance","MAX_SAFE_INTEGER","gatherPoint","distance","drawPoints","gathersLen","p","conformingToDistance","row","column","slice","map","uints","Background","gridGap","gridFillStyle","gridPaperGap","gridPaperStrokeStyle","quadrillePaperVerticalMargin","quadrillePaperGap","quadrillePaperStrokeStyles","gridPattern","gridPaperPattern","quadrillePaperPattern","bgPattern","coordX","coordY","generateGridPattern","generateGridPaperPattern","generateQuadrillePaperPattern","GRID","GRID_PAPER","QUADRILLE_PAPER","bgOffscreen","createPattern","strokeRect","setLineDash","RuleAuxiliary","ruleStrokeStyle","ruleGap","ruleUnitLen","offsetX","offsetY","offsetXRule","offsetYRule","Border","borderStyle","borderWidth","Writing","scale","willReadFrequently","refresh","putImageData","singlePointsWriting","points","clear","doClean","pushImageData","determineIfThereHasContent","hasContent","storeItem","splice","colLen","storeLen","displayData","storeItemWorldOffsetX","storeItemWorldOffsetY","storeItemData","abs","currentCol","currentRow","displayCol","displayRow","g","displayJ","displayImageData","getWholeCanvas","minX","minY","maxX","maxY","undefined","wholeWidth","wholeHeight","minPixelX","minPixelY","maxPixelX","maxPixelY","targetWidth","targetHeight","getPaperCanvas","floor","Eraser$1","cleanX","cleanY","cleanWidth","cleanHeight","rect","Eraser","writing","svgPath","createElementNS","writeModel","WRITE","color","d","prevX","prevY","prevD","submit","pointerType","writingCtx","endD","startD","setAttribute","totalLength","getTotalLength","ratio","window","devicePixelRatio","fragments","currentD","lastFragment","forEach","fragment","avgI","avgD","start","end","getPointAtLength","globalAlpha","lineJoin","lineCap","console","log","pushPoints","pressure","minPressure","maxPressure","defaultScrollRange","defaultScrollDirection","ALL","defaultBGPattern","defaultWriteModel","defaultGridFillStyle","defaultGridPaperStrokeStyle","defaultQuadrillePaperStrokeStyles","defaultRuleStrokeStyle","defaultColor","defaultBorderStyle","defaultOptions","scrollRange","scrollDirection","enableBG","rule","stack","moveCountTotal","writeLocked","dragLocked","showBorder","useShapeType","Board","scrolling","cleanState","cleanPress","stackObj","moveT","debounceBindOnChange","activateToolShape","toolShapeCenterX","toolShapeCenterY","toolShapeAngle","background","ruleAuxiliary","border","eraser","eraserHasContent","brushDrawing","containerOffset","onChange","options","scrollingElement","getBoundingClientRect","scrollLeft","scrollTop","func","delay","timer","args","clearTimeout","setTimeout","apply","debounce","triggerOnChange","lastStoreItem","prevWorldOffsetX","prevWorldOffsetY","preOffsetX","preOffsetY","doMove","append","BrushDrawing","setVoice","maxD","showBG","hideBG","showRule","hideRule","showToolShape","hideToolShape","setToolShapeType","shapeType","adjustOffset","round","X","Y","requestAnimationFrame","scrollBy","requestIdleCallback","exportAsCanvas","exportAsPaperCanvas","imageCanvas","loadBackground","clean","unclean","loadRule","drawEraser","drawToolShape","doPushPoints","rotationCenter","hasWrited","isDoubleTouch","isToolShapeDoubleTouch","turnStartAngle","dragStartTime","dragEndTime","isSingleTouch","handleWriteStart","performance","now","doInsertPointByToolShape","nearestPoints","handleWriteMove","deltaX","deltaY","touch1","touch2","atan2","center","getTripleTouchAngleAndCenter","newX","newY","originX","originY","radians","rotateCoordinate","scrollDecay","speedX","speedY","t","_scrollDecay","handleWriteEnd","deltaTime","changedTouches","containerX","containerY","totalX","totalY","touch","opacity","writeEndX","writeEndY"],"mappings":"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"}