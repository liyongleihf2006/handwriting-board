{"version":3,"file":"index.umd.min.js","sources":["../src/stack.ts","../src/enum.ts","../src/utils.ts","../src/component/shape/Ruler.ts","../src/component/shape/Compass.ts","../src/component/shape/Compass360.ts","../src/component/shape/Triangle.ts","../src/component/ToolShape.ts","../src/component/Background.ts","../src/component/RuleAuxiliary.ts","../src/component/Border.ts","../src/component/Writing.ts","../src/component/Eraser.ts","../src/component/BrushDrawing.ts","../src/index.ts"],"sourcesContent":["export class Stack {\n    width;\n    height;\n    undoStack = [];\n    redoStack = [];\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    restoreState = () => undefined;\n    saveState(store) {\n        this.undoStack.push([...store]);\n        this.redoStack.length = 0;\n    }\n    undo() {\n        if (this.undoStack.length > 0) {\n            const lastState = this.undoStack.pop();\n            this.redoStack.push(lastState);\n            let previousState = this.undoStack[this.undoStack.length - 1];\n            if (!previousState) {\n                const data = new Uint8ClampedArray(this.width * 4 * this.height);\n                const imageData = new ImageData(data, this.width, this.height);\n                previousState = [{ worldOffsetX: 0, worldOffsetY: 0, imageData }];\n            }\n            this.doRestoreState(previousState);\n        }\n    }\n    redo() {\n        if (this.redoStack.length > 0) {\n            const nextState = this.redoStack.pop();\n            this.undoStack.push(nextState);\n            this.doRestoreState(nextState);\n        }\n    }\n    doRestoreState(store) {\n        this.restoreState([...store]);\n    }\n}\n//# sourceMappingURL=stack.js.map","export var WriteModel;\n(function (WriteModel) {\n    WriteModel[\"WRITE\"] = \"write\";\n    WriteModel[\"DRAW\"] = \"draw\";\n})(WriteModel || (WriteModel = {}));\nexport var BGPattern;\n(function (BGPattern) {\n    BGPattern[\"GRID\"] = \"grid\";\n    BGPattern[\"GRID_PAPER\"] = \"gridPaper\";\n    BGPattern[\"QUADRILLE_PAPER\"] = \"quadrillePaper\";\n})(BGPattern || (BGPattern = {}));\nexport var ScrollDirection;\n(function (ScrollDirection) {\n    ScrollDirection[\"ALL\"] = \"all\";\n    ScrollDirection[\"X\"] = \"x\";\n    ScrollDirection[\"Y\"] = \"y\";\n})(ScrollDirection || (ScrollDirection = {}));\nexport var ShapeType;\n(function (ShapeType) {\n    ShapeType[\"RULER\"] = \"ruler\";\n    ShapeType[\"COMPASS\"] = \"compass\";\n    ShapeType[\"COMPASS360\"] = \"compass360\";\n    ShapeType[\"RIGHT_ANGLE_TRIANGLE\"] = \"rightAngleTriangle\";\n    ShapeType[\"SOSCELESL_TRIANGLE\"] = \"isoscelesTriangle\";\n})(ShapeType || (ShapeType = {}));\n//# sourceMappingURL=enum.js.map","export function debounce(func, delay) {\n    let timer;\n    return function (...args) {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n            func.apply(this, args);\n        }, delay);\n    };\n}\nexport function RotateCoordinates(angle, x0, y0) {\n    const angleInRadians = angle * Math.PI / 180;\n    const cosAngle = Math.cos(angleInRadians);\n    const sinAngle = Math.sin(angleInRadians);\n    return function (x, y) {\n        const x1 = x - x0;\n        const y1 = y - y0;\n        const targetX = x1 * cosAngle - y1 * sinAngle + x0;\n        const targetY = x1 * sinAngle + y1 * cosAngle + y0;\n        return [targetX, targetY];\n    };\n}\nexport function rotateAngle(angle, angle0) {\n    // 将角度转换为弧度\n    const radian = (angle + angle0) * (Math.PI / 180);\n    return radian;\n}\nexport function calculateRotatedPoint(rx, ry, r, angle, _angle) {\n    const angleRad = angle * (Math.PI / 180); // 将角度转换为弧度\n    const _angleRad = _angle * (Math.PI / 180); // 将旋转角度转换为弧度\n    const x = rx + r * Math.cos(angleRad + _angleRad); // 计算点的 x 坐标\n    const y = ry + r * Math.sin(angleRad + _angleRad); // 计算点的 y 坐标\n    return [x, y];\n}\nexport function getTripleTouchAngleAndCenter(event) {\n    const touch1 = event.touches[0];\n    const touch2 = event.touches[1];\n    const x1 = touch1.pageX;\n    const y1 = touch1.pageY;\n    const x2 = touch2.pageX;\n    const y2 = touch2.pageY;\n    const deltaX = x2 - x1;\n    const deltaY = y2 - y1;\n    const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);\n    const centerX = (x1 + x2) / 2;\n    const centerY = (y1 + y2) / 2;\n    return { angle, center: [centerX, centerY] };\n}\nexport function rotateCoordinate(x0, y0, angle, originX, originY) {\n    const radians = angle * (Math.PI / 180);\n    const deltaX = originX - x0;\n    const deltaY = originY - y0;\n    const newX = Math.cos(radians) * deltaX - Math.sin(radians) * deltaY;\n    const newY = Math.sin(radians) * deltaX + Math.cos(radians) * deltaY;\n    const rotatedX = newX + x0;\n    const rotatedY = newY + y0;\n    return [rotatedX, rotatedY];\n}\nexport function negativeRemainder(a, b) {\n    return ((a % b) + b) % b;\n}\nexport function generateCanvas(width, height) {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    Object.assign(canvas.style, {\n        left: '0',\n        top: '0',\n        position: 'absolute',\n        'pointer-events': 'none',\n        width: '100%',\n        height: '100%'\n    });\n    return canvas;\n}\n//# sourceMappingURL=utils.js.map","import { RotateCoordinates } from '../../utils';\nexport default class Ruler {\n    ctx;\n    cm;\n    mm;\n    path;\n    width = 0;\n    height = 0;\n    marginH = 0;\n    degreeNumber = 20;\n    toolShapeCenterX = 500;\n    toolShapeCenterY = 300;\n    angle = 10;\n    constructor(ctx, cm, mm) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.marginH = this.mm * 5;\n        this.width = this.cm * this.degreeNumber + this.marginH * 2;\n        this.height = this.cm * 2;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const width = this.width + voice;\n        const height = this.height + voice;\n        const x = _cx - voice / 2 - width / 2;\n        const y = _cy - voice / 2 - height / 2;\n        const angle = _angle;\n        const cm = this.cm;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        let pathStr = '';\n        pathStr += `M${rotateCoordinates(x, y).join(',')}`;\n        pathStr += `L${rotateCoordinates(x + width, y).join(',')}`;\n        pathStr += `L${rotateCoordinates(x + width, y + height).join(',')}`;\n        const offestX = 1.5 * cm + this.marginH + voice / 2;\n        const beginWaveX = x + width - offestX;\n        const beginWaveY = y + height;\n        const endWaveX = x + offestX;\n        const waveUnit = cm * 2 / 3;\n        const waveUnitY = waveUnit / 4;\n        const waveY = beginWaveY - waveUnitY;\n        pathStr += `L${rotateCoordinates(beginWaveX, beginWaveY).join(',')}`;\n        let currentWaveUnit = beginWaveX - waveUnit;\n        while (currentWaveUnit > endWaveX) {\n            pathStr += `C${[...rotateCoordinates(currentWaveUnit + waveUnit / 3, waveY - waveUnitY), ...rotateCoordinates(currentWaveUnit + waveUnit * 2 / 3, waveY + waveUnitY), ...rotateCoordinates(currentWaveUnit, beginWaveY)].join(',')}`;\n            currentWaveUnit -= waveUnit;\n        }\n        pathStr += `L${rotateCoordinates(x, beginWaveY).join(',')}`;\n        pathStr += 'z';\n        const path = new Path2D(pathStr);\n        this.path = path;\n        return path;\n    }\n    draw() {\n        const angle = this.angle;\n        const cx = this.toolShapeCenterX;\n        const cy = this.toolShapeCenterY;\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const marginH = this.marginH;\n        const cm = this.cm;\n        const mm = this.mm;\n        const degreeNumber = this.degreeNumber;\n        const width = this.width;\n        const height = this.height;\n        const rotateCoordinates = RotateCoordinates(angle, cx, cy);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path);\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = 'black';\n        ctx.font = \"3mm serif\";\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n        ctx.beginPath();\n        const cmLen = 0.5 * cm;\n        const x = cx - width / 2;\n        const y = cy - height / 2;\n        const textPos = y + cmLen + mm;\n        const mmLen = cmLen * 0.6;\n        const halfCmLen = cmLen * 0.8;\n        for (let i = 0; i <= degreeNumber; i++) {\n            const currentX = x + marginH + i * cm;\n            ctx.moveTo(...rotateCoordinates(currentX, y));\n            ctx.lineTo(...rotateCoordinates(currentX, y + cmLen));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(currentX, textPos));\n            ctx.rotate(angle * Math.PI / 180);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumber) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmX = currentX + j * mm;\n                    ctx.moveTo(...rotateCoordinates(currentMmX, y));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + halfCmLen));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + mmLen));\n                    }\n                }\n            }\n        }\n        ctx.stroke();\n        ctx.restore();\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Ruler.js.map","import { rotateAngle, calculateRotatedPoint } from '../../utils';\nexport default class Compass {\n    ctx;\n    cm;\n    mm;\n    path;\n    r;\n    middleR;\n    smallR;\n    middleGap;\n    startAngle = 170;\n    endAngle = 370;\n    innerStartAngle = 180;\n    innerEndAngle = 360;\n    toolShapeCenterX = 500;\n    toolShapeCenterY = 300;\n    angle = 10;\n    constructor(ctx, cm, mm) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.r = cm * 6;\n        this.middleR = cm * 3.5;\n        this.middleGap = cm * 1;\n        this.smallR = cm * 2.2;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const startAngle = this.startAngle;\n        const endAngle = this.endAngle;\n        const innerStartAngle = this.innerStartAngle;\n        const innerEndAngle = this.innerEndAngle;\n        const r = this.r + voice;\n        const middleInsideR = this.middleR + voice;\n        const middleOutsideR = middleInsideR + this.middleGap - voice;\n        const smallR = this.smallR - voice;\n        const cx = _cx;\n        const cy = _cy;\n        const innerCx = _cx;\n        const innerCy = _cy - voice;\n        const path = new Path2D();\n        path.arc(cx, cy, r, rotateAngle(startAngle, _angle), rotateAngle(endAngle, _angle));\n        path.closePath();\n        path.moveTo(...calculateRotatedPoint(innerCx, innerCy, middleOutsideR, innerStartAngle, _angle));\n        path.arc(innerCx, innerCy, middleOutsideR, rotateAngle(innerStartAngle, _angle), rotateAngle(innerEndAngle, _angle));\n        path.lineTo(...calculateRotatedPoint(innerCx, innerCy, middleInsideR, innerEndAngle, _angle));\n        path.arc(innerCx, innerCy, middleInsideR, rotateAngle(innerEndAngle, _angle), rotateAngle(innerStartAngle, _angle), true);\n        path.lineTo(...calculateRotatedPoint(innerCx, innerCy, middleOutsideR, innerStartAngle, _angle));\n        path.moveTo(...calculateRotatedPoint(innerCx, innerCy, smallR, innerStartAngle, _angle));\n        path.arc(innerCx, innerCy, smallR, rotateAngle(innerStartAngle, _angle), rotateAngle(innerEndAngle, _angle));\n        path.closePath();\n        this.path = path;\n        return path;\n    }\n    drawDegree(cx, cy, r, smallUnitL, unitL, bigUnitL, ruleFontSize, fontGap, showText, showSmall, showMiddle, textOnInner, _angle, reverse = false) {\n        const ctx = this.ctx;\n        // 刻度设置\n        const total = 180; // 总刻度数\n        const unitS = Math.PI / total; // 刻度线间隔角度\n        const unitBigInterval = 10;\n        const unitInterval = unitBigInterval;\n        const ruleLoose = 5;\n        // 绘制刻度和刻度的数值\n        let angle = (180 + _angle) * Math.PI / 180;\n        ctx.save();\n        ctx.textAlign = 'center'; // 设置文本对齐方式\n        ctx.textBaseline = 'middle';\n        ctx.font = `${ruleFontSize}px Arial`; // 文本字体\n        if (!textOnInner) {\n            r += bigUnitL;\n            ctx.textBaseline = 'bottom';\n        }\n        for (let i = 0; i <= total; i++) {\n            if (i % unitBigInterval === 0) { // 大刻度\n                const startX = cx + Math.cos(angle) * (r - bigUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - bigUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n                if (showText && i % unitInterval === 0) {\n                    const textX = cx + Math.cos(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置横坐标\n                    const textY = cy + Math.sin(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置纵坐标\n                    ctx.save();\n                    ctx.textAlign = 'center';\n                    ctx.translate(textX, textY);\n                    ctx.rotate(angle + Math.PI / 2);\n                    ctx.fillText((reverse ? total - i : i).toString(), 0, 0);\n                    ctx.restore();\n                }\n            }\n            else if (!(i % ruleLoose)) { // 中刻度\n                if (showMiddle) {\n                    const startX = cx + Math.cos(angle) * (r - unitL); // 刻度线起始点横坐标\n                    const startY = cy + Math.sin(angle) * (r - unitL); // 刻度线起始点纵坐标\n                    const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                    const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n            }\n            else if (showSmall) {\n                const startX = cx + Math.cos(angle) * (r - smallUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - smallUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n            }\n            angle += unitS; // 更新角度\n        }\n        ctx.restore();\n    }\n    drawContent(_cx, _cy, _angle) {\n        const r = this.r;\n        const middleR = this.middleR;\n        const smallR = this.smallR;\n        const cx = _cx;\n        const cy = _cy;\n        const ctx = this.ctx;\n        ctx.save();\n        this.drawDegree(cx, cy, r, 10, 15, 20, 8, 10, true, true, true, true, _angle);\n        this.drawDegree(cx, cy, middleR, 10, 12, 15, 0, 0, false, true, true, true, _angle);\n        this.drawDegree(cx, cy, smallR, 0, 0, 12, 7, 10, true, false, false, false, _angle, true);\n        ctx.restore();\n    }\n    drawPosition(cx, cy, angle) {\n        const r = 20;\n        const ctx = this.ctx;\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(cx, cy);\n        ctx.lineTo(...calculateRotatedPoint(cx, cy, r, 90, angle));\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.arc(cx, cy, r, rotateAngle(0, angle), rotateAngle(180, angle));\n        ctx.stroke();\n        ctx.restore();\n    }\n    draw() {\n        const angle = this.angle;\n        const cx = this.toolShapeCenterX;\n        const cy = this.toolShapeCenterY;\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path, 'evenodd');\n        ctx.restore();\n        this.drawContent(cx, cy, angle);\n        this.drawPosition(cx, cy, angle);\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Compass.js.map","import { rotateAngle, RotateCoordinates } from '../../utils';\nfunction isTouchDevice() {\n    return 'ontouchstart' in self;\n}\nexport default class Compass {\n    ctx;\n    cm;\n    mm;\n    container;\n    getPageCoords;\n    toolShape;\n    path;\n    outsideR;\n    insideR;\n    pointerW;\n    startAngle = 0;\n    endAngle = 360;\n    firstPointerAngle = 0;\n    secondPointerAngle = 30;\n    pointer1;\n    pointer2;\n    toolShapeCenterX = 500;\n    toolShapeCenterY = 300;\n    angle = 10;\n    constructor(ctx, cm, mm, container, getPageCoords, toolShape) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.container = container;\n        this.getPageCoords = getPageCoords;\n        this.toolShape = toolShape;\n        this.outsideR = cm * 6;\n        this.insideR = cm * 4.5;\n        this.pointerW = cm * 1;\n        this.loadEvent();\n    }\n    calculateRotationAngle(dragStartX, dragStartY, dragEndX, dragEndY) {\n        const cx = this.toolShapeCenterX;\n        const cy = this.toolShapeCenterY;\n        // 计算向量a的x和y分量\n        const aX = dragStartX - cx;\n        const aY = dragStartY - cy;\n        // 计算向量b的x和y分量\n        const bX = dragEndX - cx;\n        const bY = dragEndY - cy;\n        // 计算向量a和向量b的夹角\n        const dotProduct = aX * bX + aY * bY; // 向量的点乘\n        const aLength = Math.sqrt(aX * aX + aY * aY); // 向量a的长度\n        const bLength = Math.sqrt(bX * bX + bY * bY); // 向量b的长度\n        const cosTheta = dotProduct / (aLength * bLength); // 夹角的余弦值\n        const theta = Math.acos(cosTheta); // 夹角的弧度值\n        // 判断旋转方向，如果向量a和向量b形成逆时针方向，则旋转角度为正值，否则为负值\n        const crossProduct = aX * bY - aY * bX; // 向量的叉乘\n        const rotationAngle = crossProduct >= 0 ? theta : -theta;\n        // 将弧度转换为角度\n        const rotationAngleInDegrees = rotationAngle * 180 / Math.PI;\n        return rotationAngleInDegrees;\n    }\n    loadEvent() {\n        const container = this.container;\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragEndX = 0;\n        let dragEndY = 0;\n        let doTurn = false;\n        let movePointer1 = false;\n        let movePointer2 = false;\n        const turnPoinerStart = (coords, event) => {\n            const ctx = this.ctx;\n            const pointer1 = this.pointer1;\n            const pointer2 = this.pointer2;\n            dragEndX = coords.pageX;\n            dragEndY = coords.pageY;\n            if (pointer2 && ctx.isPointInPath(pointer2, coords.pageX, coords.pageY)) {\n                event.stopImmediatePropagation();\n                movePointer2 = true;\n                doTurn = true;\n            }\n            else if (pointer1 && ctx.isPointInPath(pointer1, coords.pageX, coords.pageY)) {\n                event.stopImmediatePropagation();\n                movePointer1 = true;\n                doTurn = true;\n            }\n        };\n        const handleMouseStart = (event) => {\n            event.preventDefault();\n            const { pageX, pageY } = event;\n            const coords = this.getPageCoords([{ pageX, pageY }]);\n            turnPoinerStart(coords, event);\n        };\n        const turnPointerMove = (coords) => {\n            dragStartX = dragEndX;\n            dragStartY = dragEndY;\n            dragEndX = coords.pageX;\n            dragEndY = coords.pageY;\n            const deltaAngle = this.calculateRotationAngle(dragStartX, dragStartY, dragEndX, dragEndY);\n            if (!isNaN(deltaAngle)) {\n                if (movePointer1) {\n                    this.firstPointerAngle += deltaAngle;\n                }\n                else if (movePointer2) {\n                    this.secondPointerAngle += deltaAngle;\n                }\n            }\n            this.draw();\n            this.toolShape.reset();\n        };\n        const handleMouseMove = (event) => {\n            if (doTurn) {\n                event.stopImmediatePropagation();\n                const { pageX, pageY } = event;\n                const coords = this.getPageCoords([{ pageX, pageY }]);\n                turnPointerMove(coords);\n            }\n        };\n        const turnPointerEnd = () => {\n            doTurn = false;\n            movePointer1 = false;\n            movePointer2 = false;\n        };\n        const handleMouseEnd = (event) => {\n            turnPointerEnd();\n        };\n        container.addEventListener(\"pointerdown\", handleMouseStart);\n        self.addEventListener(\"pointermove\", handleMouseMove, { passive: true });\n        self.addEventListener(\"pointerup\", handleMouseEnd, { passive: true });\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const cx = _x;\n        const cy = _y;\n        const angle = _angle;\n        this.drawBorder(c, cx, cy, angle, 0, 'rgba(0,0,0,1)');\n        this.drawPointer(c, cx, cy, angle, this.firstPointerAngle, 0, 'rgba(0,0,0,1)');\n        this.drawPointer(c, cx, cy, angle, this.secondPointerAngle, 0, 'rgba(0,0,0,1)');\n        c.globalCompositeOperation = 'source-out';\n        const offscreen1 = new OffscreenCanvas(width, height);\n        const c2 = offscreen1.getContext('2d');\n        this.drawBorder(c2, cx, cy, angle, outlineVoice, 'rgba(0,0,0,1)');\n        this.drawPointer(c2, cx, cy, angle, this.firstPointerAngle, outlineVoice, 'rgba(0,0,0,1)');\n        this.drawPointer(c2, cx, cy, angle, this.secondPointerAngle, outlineVoice, 'rgba(0,0,0,1)');\n        c.drawImage(offscreen1, 0, 0);\n        c.globalCompositeOperation = 'source-in';\n        c.fillStyle = strokeStyle;\n        c.fillRect(0, 0, width, height);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle) {\n        const startAngle = this.startAngle;\n        const endAngle = this.endAngle;\n        const outsideR = this.outsideR;\n        const insideR = this.insideR;\n        const r = (outsideR + insideR) / 2;\n        const cx = _cx;\n        const cy = _cy;\n        const path = new Path2D();\n        path.arc(cx, cy, r, rotateAngle(startAngle, _angle), rotateAngle(endAngle, _angle));\n        this.path = path;\n        return path;\n    }\n    generatorPointer(_cx, _cy, _angle, pointerAngle, outlineVoice) {\n        const outsideR = this.outsideR;\n        const pointerW = this.pointerW;\n        const cx = _cx;\n        const cy = _cy;\n        const r = pointerW / 2 + outlineVoice;\n        let angle = _angle;\n        angle += pointerAngle;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        let pathStr = '';\n        pathStr += `M${rotateCoordinates(cx, cy - r).join(',')}`;\n        pathStr += `A${r},${r},1,1,1,${rotateCoordinates(cx, cy + r).join(',')}`;\n        pathStr += `L${rotateCoordinates(cx - outsideR, cy + r).join(',')}`;\n        pathStr += `A${r},${r},1,1,1,${rotateCoordinates(cx - outsideR, cy - r).join(',')}`;\n        pathStr += 'z';\n        const path = new Path2D(pathStr);\n        return path;\n    }\n    drawDegree(cx, cy, r, smallUnitL, unitL, bigUnitL, ruleFontSize, fontGap, showText, showSmall, showMiddle, showBig, textOnInner, _angle, reverse) {\n        const ctx = this.ctx;\n        // 刻度设置\n        const total = 360; // 总刻度数\n        const unitS = 2 * Math.PI / total; // 刻度线间隔角度\n        const unitBigInterval = 10;\n        const unitInterval = unitBigInterval;\n        const ruleLoose = 5;\n        // 绘制刻度和刻度的数值\n        let angle = (180 + _angle) * Math.PI / 180;\n        ctx.save();\n        ctx.textAlign = 'center'; // 设置文本对齐方式\n        ctx.textBaseline = 'middle';\n        ctx.font = `${ruleFontSize}px Arial`; // 文本字体\n        if (!textOnInner) {\n            r += bigUnitL;\n            ctx.textBaseline = 'bottom';\n        }\n        for (let i = 0; i <= total; i++) {\n            if (i % unitBigInterval === 0) { // 大刻度\n                const startX = cx + Math.cos(angle) * (r - bigUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - bigUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                if (showBig) {\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n                if (i !== total && showText && i % unitInterval === 0) {\n                    const textX = cx + Math.cos(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置横坐标\n                    const textY = cy + Math.sin(angle) * (r - (bigUnitL + fontGap) * Number(textOnInner)); // 刻度文本位置纵坐标\n                    ctx.save();\n                    ctx.textAlign = 'center';\n                    ctx.translate(textX, textY);\n                    ctx.rotate(angle + Math.PI / 2);\n                    ctx.fillText((reverse ? total - i : i).toString(), 0, 0);\n                    ctx.restore();\n                }\n            }\n            else if (!(i % ruleLoose)) { // 中刻度\n                if (showMiddle) {\n                    const startX = cx + Math.cos(angle) * (r - unitL); // 刻度线起始点横坐标\n                    const startY = cy + Math.sin(angle) * (r - unitL); // 刻度线起始点纵坐标\n                    const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                    const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                    ctx.beginPath();\n                    ctx.moveTo(startX, startY);\n                    ctx.lineTo(endX, endY);\n                    ctx.stroke();\n                }\n            }\n            else if (showSmall) {\n                const startX = cx + Math.cos(angle) * (r - smallUnitL); // 刻度线起始点横坐标\n                const startY = cy + Math.sin(angle) * (r - smallUnitL); // 刻度线起始点纵坐标\n                const endX = cx + Math.cos(angle) * r; // 刻度线结束点横坐标\n                const endY = cy + Math.sin(angle) * r; // 刻度线结束点纵坐标\n                ctx.beginPath();\n                ctx.moveTo(startX, startY);\n                ctx.lineTo(endX, endY);\n                ctx.stroke();\n            }\n            angle += unitS; // 更新角度\n        }\n        ctx.restore();\n    }\n    drawContent(_cx, _cy, _angle) {\n        const outsideR = this.outsideR;\n        const cx = _cx;\n        const cy = _cy;\n        const ctx = this.ctx;\n        ctx.save();\n        this.drawDegree(cx, cy, outsideR, 10, 15, 20, 8, 10, true, true, true, true, true, _angle, false);\n        this.drawDegree(cx, cy, outsideR, 10, 15, 20, 8, 25, true, false, false, false, true, _angle, true);\n        ctx.restore();\n    }\n    drawBorder(ctx, cx, cy, angle, outlineVoice, strokeStyle) {\n        const outsideR = this.outsideR;\n        const insideR = this.insideR;\n        ctx.save();\n        ctx.beginPath();\n        ctx.lineWidth = outsideR - insideR + 2 * outlineVoice;\n        ctx.strokeStyle = strokeStyle;\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.stroke(path);\n        ctx.restore();\n    }\n    drawPointer(ctx, cx, cy, angle, pointerAngle, outlineVoice, fillStyle) {\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = fillStyle;\n        const path = this.generatorPointer(cx, cy, angle, pointerAngle, outlineVoice);\n        ctx.fill(path);\n        ctx.restore();\n        return path;\n    }\n    drawFixedPoint(cx, cy, angle) {\n        const ctx = this.ctx;\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        ctx.arc(cx, cy, this.pointerW / 4, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.restore();\n    }\n    draw() {\n        const angle = this.angle;\n        const cx = this.toolShapeCenterX;\n        const cy = this.toolShapeCenterY;\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        this.drawBorder(ctx, cx, cy, angle, 0, 'rgba(0,0,0,.08)');\n        this.drawContent(cx, cy, angle);\n        this.pointer1 = this.drawPointer(ctx, cx, cy, angle, this.firstPointerAngle, 0, 'rgba(0,0,0,.08)');\n        this.pointer2 = this.drawPointer(ctx, cx, cy, angle, this.secondPointerAngle, 0, 'rgba(0,0,0,.08)');\n        this.drawFixedPoint(cx, cy, angle);\n    }\n    isPointInPath(x, y, fillRule) {\n        const ctx = this.ctx;\n        if (fillRule === 'evenodd') {\n            let isPointInStroke = false;\n            ctx.save();\n            ctx.lineWidth = this.outsideR - this.insideR;\n            isPointInStroke = ctx.isPointInStroke(this.path, x, y);\n            ctx.restore();\n            return isPointInStroke;\n        }\n        else {\n            return ctx.isPointInPath(this.path, x, y);\n        }\n    }\n}\n//# sourceMappingURL=Compass360.js.map","import { RotateCoordinates } from '../../utils';\nexport default class Triangle {\n    ctx;\n    cm;\n    mm;\n    degreeNumberH;\n    degreeNumberV;\n    marginH;\n    marginV;\n    path;\n    width = 0;\n    height = 0;\n    marginC = 0;\n    gap = 0;\n    toolShapeCenterX = 500;\n    toolShapeCenterY = 300;\n    angle = 10;\n    constructor(ctx, cm, mm, degreeNumberH, degreeNumberV, marginH, marginV) {\n        this.ctx = ctx;\n        this.cm = cm;\n        this.mm = mm;\n        this.degreeNumberH = degreeNumberH;\n        this.degreeNumberV = degreeNumberV;\n        this.marginH = marginH;\n        this.marginV = marginV;\n        this.marginC = this.cm;\n        this.width = this.cm * this.degreeNumberH + this.marginH + this.marginC;\n        this.height = this.cm * this.degreeNumberV + this.marginV + this.marginC;\n        this.gap = this.cm * 1.5;\n    }\n    getOutlineCtx(_x, _y, _angle, outlineVoice, strokeStyle) {\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const { width, height } = canvas;\n        const offscreen = new OffscreenCanvas(width, height);\n        const c = offscreen.getContext('2d');\n        const path = this.generatorOuterBorder(_x, _y, _angle, outlineVoice);\n        c.strokeStyle = strokeStyle;\n        c.lineWidth = outlineVoice;\n        c.stroke(path);\n        return c;\n    }\n    generatorOuterBorder(_cx, _cy, _angle, voice = 0) {\n        const width = this.width + voice;\n        const height = this.height + voice;\n        const x = _cx - voice / 2 - width / 2;\n        const y = _cy - voice / 2 - height / 2;\n        const angle = _angle;\n        const rotateCoordinates = RotateCoordinates(angle, _cx, _cy);\n        const path = new Path2D();\n        path.moveTo(...rotateCoordinates(x + width, y));\n        path.lineTo(...rotateCoordinates(x, y));\n        path.lineTo(...rotateCoordinates(x, y + height));\n        path.closePath();\n        const gap = this.gap;\n        const smallX = x + gap;\n        const smallY = y + gap;\n        const smallWidth = width / 2;\n        const smallHeight = height / 2;\n        path.moveTo(...rotateCoordinates(smallX + smallWidth, smallY));\n        path.lineTo(...rotateCoordinates(smallX, smallY));\n        path.lineTo(...rotateCoordinates(smallX, smallY + smallHeight));\n        path.closePath();\n        this.path = path;\n        return path;\n    }\n    draw() {\n        const angle = this.angle;\n        const cx = this.toolShapeCenterX;\n        const cy = this.toolShapeCenterY;\n        const ctx = this.ctx;\n        const canvas = ctx.canvas;\n        const marginC = this.marginC;\n        const cm = this.cm;\n        const mm = this.mm;\n        const degreeNumberH = this.degreeNumberH;\n        const degreeNumberV = this.degreeNumberV;\n        const width = this.width;\n        const height = this.height;\n        const rotateCoordinates = RotateCoordinates(angle, cx, cy);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = 'rgba(0,0,0,.08)';\n        const path = this.generatorOuterBorder(cx, cy, angle);\n        ctx.fill(path, 'evenodd');\n        ctx.restore();\n        ctx.save();\n        ctx.strokeStyle = 'black';\n        ctx.font = \"3mm serif\";\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'top';\n        ctx.beginPath();\n        const cmLen = 0.5 * cm;\n        const x = cx - width / 2;\n        const y = cy - height / 2;\n        const mmLen = cmLen * 0.6;\n        const halfCmLen = cmLen * 0.8;\n        for (let i = 0; i <= degreeNumberH; i++) {\n            const currentX = x + marginC + i * cm;\n            ctx.moveTo(...rotateCoordinates(currentX, y));\n            ctx.lineTo(...rotateCoordinates(currentX, y + cmLen));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(currentX, y + cmLen + mm));\n            ctx.rotate(angle * Math.PI / 180);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumberH) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmX = currentX + j * mm;\n                    ctx.moveTo(...rotateCoordinates(currentMmX, y));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + halfCmLen));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(currentMmX, y + mmLen));\n                    }\n                }\n            }\n        }\n        for (let i = 0; i <= degreeNumberV; i++) {\n            const currentY = y + marginC + i * cm;\n            ctx.moveTo(...rotateCoordinates(x, currentY));\n            ctx.lineTo(...rotateCoordinates(x + cmLen, currentY));\n            ctx.save();\n            ctx.translate(...rotateCoordinates(x + cmLen + mm, currentY));\n            ctx.rotate(angle * Math.PI / 180 - Math.PI / 2);\n            ctx.fillText(String(i), 0, 0);\n            ctx.restore();\n            if (i < degreeNumberV) {\n                for (let j = 1; j < 10; j++) {\n                    const currentMmY = currentY + j * mm;\n                    ctx.moveTo(...rotateCoordinates(x, currentMmY));\n                    if (j === 5) {\n                        ctx.lineTo(...rotateCoordinates(x + halfCmLen, currentMmY));\n                    }\n                    else {\n                        ctx.lineTo(...rotateCoordinates(x + mmLen, currentMmY));\n                    }\n                }\n            }\n        }\n        ctx.stroke();\n        ctx.restore();\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.ctx.isPointInPath(this.path, x, y, fillRule);\n    }\n}\n//# sourceMappingURL=Triangle.js.map","import { ShapeType } from '../enum';\nimport { generateCanvas } from '../utils';\nimport Ruler from './shape/Ruler';\nimport Compass from './shape/Compass';\nimport Compass360 from './shape/Compass360';\nimport Triangle from './shape/Triangle';\nexport default class ToolShape {\n    w;\n    h;\n    voice;\n    canvas;\n    ctx;\n    getNearestDistanceAndPointVoice;\n    outlineCtx;\n    outlineImageData;\n    outline;\n    outlineMap;\n    longestDistance = 30;\n    // 像素点采集宽度\n    gatherAreaWidth = 10;\n    prevPoint = null;\n    _toolShapeType = ShapeType.RULER;\n    strokeStyle;\n    cm = 0;\n    mm = 0;\n    width = 0;\n    height = 0;\n    marginH = 0;\n    degreeNumber = 20;\n    ruler;\n    compass;\n    compass360;\n    rightAngleTriangle;\n    isoscelesTriangle;\n    constructor(w, h, voice, container, getPageCoords) {\n        this.w = w;\n        this.h = h;\n        this.voice = voice;\n        this.canvas = generateCanvas(w, h);\n        this.ctx = this.canvas.getContext('2d');\n        this.cm = 96 / 2.54;\n        this.mm = this.cm / 10;\n        this.getNearestDistanceAndPointVoice = voice;\n        this.ruler = new Ruler(this.ctx, this.cm, this.mm);\n        this.compass = new Compass(this.ctx, this.cm, this.mm);\n        this.compass360 = new Compass360(this.ctx, this.cm, this.mm, container, getPageCoords, this);\n        this.rightAngleTriangle = new Triangle(this.ctx, this.cm, this.mm, 9, 5, this.cm * 3, this.cm * 1);\n        this.isoscelesTriangle = new Triangle(this.ctx, this.cm, this.mm, 6, 6, this.cm * 2, this.cm * 2);\n    }\n    set toolShapeCenterX(x) {\n        this.shape.toolShapeCenterX = x;\n        this.reset();\n    }\n    get toolShapeCenterX() {\n        return this.shape.toolShapeCenterX;\n    }\n    set toolShapeCenterY(y) {\n        this.shape.toolShapeCenterY = y;\n        this.reset();\n    }\n    get toolShapeCenterY() {\n        return this.shape.toolShapeCenterY;\n    }\n    set angle(angle) {\n        this.shape.angle = angle;\n        this.reset();\n    }\n    get angle() {\n        return this.shape.angle;\n    }\n    set toolShapeType(toolShapeType) {\n        this._toolShapeType = toolShapeType;\n        this.reset();\n    }\n    get toolShapeType() {\n        return this._toolShapeType;\n    }\n    get shape() {\n        let shape;\n        switch (this.toolShapeType) {\n            case ShapeType.RULER:\n                shape = this.ruler;\n                break;\n            case ShapeType.COMPASS:\n                shape = this.compass;\n                break;\n            case ShapeType.COMPASS360:\n                shape = this.compass360;\n                break;\n            case ShapeType.RIGHT_ANGLE_TRIANGLE:\n                shape = this.rightAngleTriangle;\n                break;\n            case ShapeType.SOSCELESL_TRIANGLE:\n                shape = this.isoscelesTriangle;\n                break;\n            default: shape = this.ruler;\n        }\n        return shape;\n    }\n    reset() {\n        this.outline = null;\n        this.prevPoint = null;\n        this.draw();\n    }\n    getGathers(x1, y1, x2, y2, gatherAreaWidth) {\n        const topLeftX = Math.min(x1, x2) - gatherAreaWidth / 2;\n        const topLeftY = Math.min(y1, y2) - gatherAreaWidth / 2;\n        const bottomRightX = Math.max(x1, x2) + gatherAreaWidth / 2;\n        const bottomRightY = Math.max(y1, y2) + gatherAreaWidth / 2;\n        const gathers = [];\n        for (let x = topLeftX; x <= bottomRightX; x++) {\n            for (let y = topLeftY; y <= bottomRightY; y++) {\n                gathers.push([x, y]);\n            }\n        }\n        return gathers;\n    }\n    getNearestDistanceAndPoint(x, y, getNearestDistanceAndPointVoice, strokeStyle) {\n        if (!this.outline || getNearestDistanceAndPointVoice !== this.getNearestDistanceAndPointVoice || this.strokeStyle !== strokeStyle) {\n            this.getNearestDistanceAndPointVoice = getNearestDistanceAndPointVoice;\n            this.strokeStyle = strokeStyle;\n            this.outlineCtx = this.getOutlineCtx(this.getNearestDistanceAndPointVoice, strokeStyle);\n            this.outlineImageData = this.outlineCtx.getImageData(0, 0, this.w, this.h);\n            this.outline = this.getOutline(this.outlineImageData);\n            this.outlineMap = this.getOutlineMap(this.outline);\n        }\n        const outline = this.outline;\n        const len = outline.length;\n        let prevPoint = this.prevPoint;\n        const gatherAreaWidth = this.gatherAreaWidth;\n        if (!prevPoint) {\n            let nearestDistance = Number.MAX_SAFE_INTEGER;\n            for (let i = 0; i < len; i++) {\n                const [x0, y0] = outline[i];\n                const distance = ((x - x0) ** 2 + (y - y0) ** 2) ** 0.5;\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    prevPoint = [x0, y0];\n                }\n            }\n            this.prevPoint = prevPoint;\n            return { conformingToDistance: nearestDistance <= this.longestDistance, drawPoints: [] };\n        }\n        else {\n            const innerAreaPoints = [];\n            for (let i = 0; i < len; i++) {\n                const [x0, y0] = outline[i];\n                const gatherDistance = ((prevPoint[0] - x0) ** 2 + (prevPoint[1] - y0) ** 2) ** 0.5;\n                if (gatherDistance <= gatherAreaWidth) {\n                    innerAreaPoints.push(outline[i]);\n                }\n            }\n            let nearestDistance = Number.MAX_SAFE_INTEGER;\n            let gatherPoint = null;\n            for (let i = 0; i < innerAreaPoints.length; i++) {\n                const [x0, y0] = innerAreaPoints[i];\n                const distance = ((x - x0) ** 2 + (y - y0) ** 2) ** 0.5;\n                if (distance < nearestDistance) {\n                    nearestDistance = distance;\n                    gatherPoint = [x0, y0];\n                }\n            }\n            let gathers = [];\n            if (gatherPoint) {\n                gathers = this.getGathers(prevPoint[0], prevPoint[1], gatherPoint[0], gatherPoint[1], gatherAreaWidth);\n            }\n            const drawPoints = [];\n            const gathersLen = gathers.length;\n            for (let i = 0; i < gathersLen; i++) {\n                const p = gathers[i];\n                const imageData = this.outlineMap?.[p[0]]?.[p[1]];\n                if (imageData) {\n                    const data = imageData;\n                    drawPoints.push({ x: p[0], y: p[1], fillStyle: `rgba(${data[0]},${data[1]},${data[2]},${data[3] / 255})` });\n                }\n            }\n            this.prevPoint = gatherPoint;\n            return { conformingToDistance: true, drawPoints };\n        }\n    }\n    getOutlineCtx(outlineVoice, strokeStyle) {\n        return this.shape.getOutlineCtx(this.toolShapeCenterX, this.toolShapeCenterY, this.angle, outlineVoice, strokeStyle);\n    }\n    getOutline(imageData) {\n        const data = imageData.data;\n        const len = data.length;\n        const outline = [];\n        let row = 0;\n        let column = -1;\n        for (let i = 0; i < len; i += 4) {\n            column++;\n            if (data[i + 3]) {\n                outline.push([column, row, data.slice(i, i + 4)]);\n            }\n            if (column === this.w - 1) {\n                row++;\n                column = -1;\n            }\n        }\n        return outline;\n    }\n    getOutlineMap(outline) {\n        const map = {};\n        const len = outline.length;\n        for (let i = 0; i < len; i++) {\n            const [x, y, uints] = outline[i];\n            if (!map[x]) {\n                map[x] = {};\n            }\n            map[x][y] = uints;\n        }\n        return map;\n    }\n    isPointInPath(x, y, fillRule) {\n        return this.shape.isPointInPath(x, y, fillRule);\n    }\n    draw() {\n        const ctx = this.ctx;\n        ctx.clearRect(0, 0, this.w, this.h);\n        this.shape.draw();\n    }\n}\n//# sourceMappingURL=ToolShape.js.map","import { BGPattern } from \"../enum\";\nimport { generateCanvas } from '../utils';\nexport default class Background {\n    width;\n    height;\n    gridGap;\n    gridFillStyle;\n    gridPaperGap;\n    gridPaperStrokeStyle;\n    quadrillePaperVerticalMargin;\n    quadrillePaperGap;\n    quadrillePaperStrokeStyles;\n    gridPattern;\n    gridPaperPattern;\n    quadrillePaperPattern;\n    bgPattern;\n    canvas;\n    ctx;\n    coordX;\n    coordY;\n    constructor(width, height, gridGap, gridFillStyle, gridPaperGap, gridPaperStrokeStyle, quadrillePaperVerticalMargin, quadrillePaperGap, quadrillePaperStrokeStyles) {\n        this.width = width;\n        this.height = height;\n        this.gridGap = gridGap;\n        this.gridFillStyle = gridFillStyle;\n        this.gridPaperGap = gridPaperGap;\n        this.gridPaperStrokeStyle = gridPaperStrokeStyle;\n        this.quadrillePaperVerticalMargin = quadrillePaperVerticalMargin;\n        this.quadrillePaperGap = quadrillePaperGap;\n        this.quadrillePaperStrokeStyles = quadrillePaperStrokeStyles;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n        this.gridPattern = this.generateGridPattern();\n        this.gridPaperPattern = this.generateGridPaperPattern();\n        this.quadrillePaperPattern = this.generateQuadrillePaperPattern();\n    }\n    draw(coordX, coordY, bgPattern) {\n        if (coordX !== this.coordX || coordY !== this.coordY || bgPattern !== this.bgPattern) {\n            this.coordX = coordX;\n            this.coordY = coordY;\n            this.bgPattern = bgPattern;\n            const ctx = this.ctx;\n            ctx.clearRect(0, 0, this.width + this.gridGap * 2, this.height + this.gridGap * 2);\n            ctx.save();\n            ctx.beginPath();\n            ctx.translate(coordX, coordY);\n            if (this.bgPattern === BGPattern.GRID) {\n                ctx.fillStyle = this.gridPattern;\n            }\n            else if (this.bgPattern === BGPattern.GRID_PAPER) {\n                ctx.fillStyle = this.gridPaperPattern;\n            }\n            else if (this.bgPattern === BGPattern.QUADRILLE_PAPER) {\n                ctx.fillStyle = this.quadrillePaperPattern;\n            }\n            ctx.fillRect(0, 0, this.width + this.gridGap * 2, this.height + this.gridGap * 2);\n            ctx.restore();\n        }\n    }\n    generateGridPattern() {\n        const gap = this.gridGap;\n        const bgOffscreen = new OffscreenCanvas(gap * 2, gap * 2);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        ctx.fillStyle = this.gridFillStyle;\n        ctx.fillRect(0, 0, gap, gap);\n        ctx.fillRect(gap, gap, gap, gap);\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n    generateGridPaperPattern() {\n        const gap = this.gridPaperGap;\n        const bgOffscreen = new OffscreenCanvas(gap, gap);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        ctx.strokeStyle = this.gridPaperStrokeStyle;\n        ctx.strokeRect(0, 0, gap, gap);\n        ctx.setLineDash([2, 2]);\n        ctx.beginPath();\n        ctx.moveTo(gap / 2, 0);\n        ctx.lineTo(gap / 2, gap);\n        ctx.moveTo(0, gap / 2);\n        ctx.lineTo(gap, gap / 2);\n        ctx.stroke();\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n    generateQuadrillePaperPattern() {\n        const quadrillePaperVerticalMargin = this.quadrillePaperVerticalMargin;\n        const gap = this.quadrillePaperGap;\n        const quadrillePaperStrokeStyles = this.quadrillePaperStrokeStyles;\n        const height = quadrillePaperVerticalMargin * 2 + gap * 3;\n        const bgOffscreen = new OffscreenCanvas(this.width, height);\n        const ctx = bgOffscreen.getContext(\"2d\");\n        for (let i = 0; i < quadrillePaperStrokeStyles.length; i++) {\n            ctx.strokeStyle = quadrillePaperStrokeStyles[i];\n            ctx.beginPath();\n            ctx.moveTo(0, quadrillePaperVerticalMargin + gap * i);\n            ctx.lineTo(this.width, quadrillePaperVerticalMargin + gap * i);\n            ctx.stroke();\n        }\n        const pattern = ctx.createPattern(bgOffscreen, \"repeat\");\n        return pattern;\n    }\n}\n//# sourceMappingURL=Background.js.map","import { negativeRemainder } from \"../utils\";\nimport { generateCanvas } from '../utils';\nexport default class RuleAuxiliary {\n    width;\n    height;\n    ruleStrokeStyle;\n    ruleGap;\n    ruleUnitLen;\n    canvas;\n    ctx;\n    worldOffsetX;\n    worldOffsetY;\n    constructor(width, height, ruleStrokeStyle, ruleGap, ruleUnitLen) {\n        this.width = width;\n        this.height = height;\n        this.ruleStrokeStyle = ruleStrokeStyle;\n        this.ruleGap = ruleGap;\n        this.ruleUnitLen = ruleUnitLen;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n    }\n    draw(worldOffsetX, worldOffsetY) {\n        if (worldOffsetX !== this.worldOffsetX || worldOffsetY !== this.worldOffsetY) {\n            this.worldOffsetX = worldOffsetX;\n            this.worldOffsetY = worldOffsetY;\n            const ctx = this.ctx;\n            ctx.beginPath();\n            ctx.clearRect(0, 0, this.width, this.height);\n            ctx.strokeStyle = this.ruleStrokeStyle;\n            ctx.font = \"12px Arial\";\n            ctx.textAlign = \"center\";\n            ctx.fillStyle = this.ruleStrokeStyle;\n            const offsetX = negativeRemainder(this.worldOffsetX, (this.ruleGap * 10));\n            const offsetY = negativeRemainder(this.worldOffsetY, (this.ruleGap * 10));\n            const offsetXRule = (this.worldOffsetX - this.worldOffsetX % (this.ruleGap * 10)) / (this.ruleGap * 10) * 10;\n            const offsetYRule = (this.worldOffsetY - this.worldOffsetY % (this.ruleGap * 10)) / (this.ruleGap * 10) * 10;\n            let i = 0;\n            let j = 0;\n            let coordX = -offsetX;\n            let coordY = -offsetY;\n            const fontGap = 3;\n            while (coordX <= this.width) {\n                let len = this.ruleUnitLen;\n                if (!(i % 10)) {\n                    len = this.ruleUnitLen * 2.5;\n                }\n                else if (!(i % 5)) {\n                    len = this.ruleUnitLen * 1.5;\n                }\n                ctx.moveTo(coordX, 0);\n                ctx.lineTo(coordX, len);\n                ctx.moveTo(coordX, this.height);\n                ctx.lineTo(coordX, this.height - len);\n                if (!(i % 10)) {\n                    ctx.textBaseline = \"top\";\n                    ctx.fillText(String(i + offsetXRule), coordX, len + fontGap);\n                    ctx.textBaseline = \"bottom\";\n                    ctx.fillText(String(i + offsetXRule), coordX, this.height - len - fontGap);\n                }\n                coordX += this.ruleGap;\n                i++;\n            }\n            ctx.textBaseline = \"middle\";\n            while (coordY <= this.height) {\n                let len = this.ruleUnitLen;\n                if (!(j % 10)) {\n                    len = this.ruleUnitLen * 2.5;\n                }\n                else if (!(j % 5)) {\n                    len = this.ruleUnitLen * 1.5;\n                }\n                ctx.moveTo(0, coordY);\n                ctx.lineTo(len, coordY);\n                ctx.moveTo(this.width, coordY);\n                ctx.lineTo(this.width - len, coordY);\n                if (!(j % 10)) {\n                    ctx.textAlign = \"left\";\n                    ctx.fillText(String(j + offsetYRule), len + fontGap, coordY);\n                    ctx.textAlign = \"right\";\n                    ctx.fillText(String(j + offsetYRule), this.width - len - fontGap, coordY);\n                }\n                coordY += this.ruleGap;\n                j++;\n            }\n            ctx.stroke();\n        }\n    }\n}\n//# sourceMappingURL=RuleAuxiliary.js.map","import { generateCanvas } from '../utils';\nexport default class Border {\n    width;\n    height;\n    borderStyle;\n    borderWidth;\n    canvas;\n    ctx;\n    constructor(width, height, borderStyle, borderWidth) {\n        this.width = width;\n        this.height = height;\n        this.borderStyle = borderStyle;\n        this.borderWidth = borderWidth;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n        this.draw();\n    }\n    draw() {\n        const ctx = this.ctx;\n        ctx.strokeStyle = this.borderStyle;\n        ctx.lineWidth = this.borderWidth;\n        ctx.strokeRect(0, 0, this.width, this.height);\n    }\n}\n//# sourceMappingURL=Border.js.map","import { generateCanvas } from '../utils';\nexport default class Writing {\n    store = [];\n    canvas;\n    ctx;\n    scale = 1;\n    width;\n    height;\n    constructor(width, height) {\n        this.width = width * this.scale;\n        this.height = height * this.scale;\n        this.canvas = generateCanvas(this.width, this.height);\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\n        this.ctx.imageSmoothingEnabled = true;\n        this.ctx.imageSmoothingQuality = 'high';\n    }\n    refresh(worldOffsetX, worldOffsetY) {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        this.putImageData(worldOffsetX, worldOffsetY);\n    }\n    singlePointsWriting(points) {\n        const ctx = this.ctx;\n        const len = points.length;\n        for (let i = 0; i < len; i++) {\n            ctx.save();\n            ctx.beginPath();\n            const { x, y, fillStyle } = points[i];\n            ctx.fillStyle = fillStyle;\n            ctx.fillRect(x * this.scale, y * this.scale, 1, 1);\n            ctx.restore();\n        }\n    }\n    clear() {\n        this.store.length = 0;\n        this.doClean(0, 0, this.width, this.height);\n        this.pushImageData(0, 0);\n    }\n    doClean(x, y, width, height, determineIfThereHasContent = false) {\n        x = this.scale * x;\n        y = this.scale * y;\n        width = this.scale * width;\n        height = this.scale * height;\n        let hasContent = false;\n        if (determineIfThereHasContent) {\n            const imageData = this.ctx.getImageData(x, y, width, height);\n            const data = imageData.data;\n            const len = data.length;\n            for (let i = 0; i < len; i += 4) {\n                if (data[i + 3]) {\n                    hasContent = true;\n                    break;\n                }\n            }\n        }\n        this.ctx.clearRect(x, y, width, height);\n        return hasContent;\n    }\n    pushImageData(worldOffsetX, worldOffsetY) {\n        const imageData = this.ctx.getImageData(0, 0, this.width, this.height);\n        const store = this.store;\n        const len = store.length;\n        for (let i = len - 1; i >= 0; i--) {\n            const storeItem = store[i];\n            if (storeItem.worldOffsetX === worldOffsetX && storeItem.worldOffsetY === worldOffsetY) {\n                store.splice(i, 1);\n            }\n        }\n        store.push({\n            worldOffsetX,\n            worldOffsetY,\n            imageData\n        });\n    }\n    putImageData(worldOffsetX, worldOffsetY) {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        const displayData = new Uint8ClampedArray(total);\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            if (Math.abs(storeItemWorldOffsetX - worldOffsetX) >= width || Math.abs(storeItemWorldOffsetY - worldOffsetY) >= height) {\n                continue;\n            }\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - worldOffsetX + storeItemWorldOffsetX;\n                const displayRow = currentRow - worldOffsetY + storeItemWorldOffsetY;\n                if (displayCol >= 0\n                    &&\n                        displayRow >= 0\n                    &&\n                        displayCol < width\n                    &&\n                        displayRow < height) {\n                    const r = storeItemData[j];\n                    const g = storeItemData[j + 1];\n                    const b = storeItemData[j + 2];\n                    const a = storeItemData[j + 3];\n                    const displayJ = (displayCol + displayRow * width) * 4;\n                    displayData[displayJ] = r;\n                    displayData[displayJ + 1] = g;\n                    displayData[displayJ + 2] = b;\n                    displayData[displayJ + 3] = a;\n                }\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const displayImageData = new ImageData(displayData, width, height);\n        this.ctx.putImageData(displayImageData, 0, 0);\n    }\n    getWholeCanvas() {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        let minX;\n        let minY;\n        let maxX;\n        let maxY;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            if (minX === undefined || minX > storeItemWorldOffsetX) {\n                minX = storeItemWorldOffsetX;\n            }\n            if (minY === undefined || minY > storeItemWorldOffsetY) {\n                minY = storeItemWorldOffsetY;\n            }\n            if (maxX === undefined || maxX < storeItemWorldOffsetX) {\n                maxX = storeItemWorldOffsetX;\n            }\n            if (maxY === undefined || maxY < storeItemWorldOffsetY) {\n                maxY = storeItemWorldOffsetY;\n            }\n        }\n        const canvas = document.createElement('canvas');\n        if (minX === undefined || minY === undefined || maxX === undefined || maxY === undefined) {\n            canvas.width = 0;\n            canvas.height = 0;\n            return canvas;\n        }\n        maxX += width;\n        maxY += height;\n        const wholeWidth = (maxX - minX);\n        const wholeHeight = (maxY - minY);\n        const wholeTotal = wholeWidth * 4 * wholeHeight;\n        const displayData = new Uint8ClampedArray(wholeTotal);\n        let minPixelX = wholeWidth;\n        let minPixelY = wholeHeight;\n        let maxPixelX = 0;\n        let maxPixelY = 0;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - minX + storeItemWorldOffsetX;\n                const displayRow = currentRow - minY + storeItemWorldOffsetY;\n                const r = storeItemData[j];\n                const g = storeItemData[j + 1];\n                const b = storeItemData[j + 2];\n                const a = storeItemData[j + 3];\n                if (a !== 0) {\n                    if (displayCol < minPixelX) {\n                        minPixelX = displayCol;\n                    }\n                    if (displayRow < minPixelY) {\n                        minPixelY = displayRow;\n                    }\n                    if (displayCol > maxPixelX) {\n                        maxPixelX = displayCol;\n                    }\n                    if (displayRow > maxPixelY) {\n                        maxPixelY = displayRow;\n                    }\n                }\n                const displayJ = (displayCol + displayRow * wholeWidth) * 4;\n                displayData[displayJ] = r;\n                displayData[displayJ + 1] = g;\n                displayData[displayJ + 2] = b;\n                displayData[displayJ + 3] = a;\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const displayImageData = new ImageData(displayData, wholeWidth, wholeHeight);\n        const targetWidth = maxPixelX - minPixelX;\n        const targetHeight = maxPixelY - minPixelY;\n        canvas.width = targetWidth;\n        canvas.height = targetHeight;\n        const ctx = canvas.getContext('2d');\n        ctx.putImageData(displayImageData, -minPixelX, -minPixelY);\n        return canvas;\n    }\n    getPaperCanvas() {\n        const width = this.width;\n        const height = this.height;\n        const colLen = width * 4;\n        const rowLen = height;\n        const total = colLen * rowLen;\n        const store = this.store;\n        const storeLen = store.length;\n        const minX = 0;\n        const minY = 0;\n        const maxX = width;\n        let maxY = 0;\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            if (maxY === undefined || maxY < storeItemWorldOffsetY) {\n                maxY = storeItemWorldOffsetY;\n            }\n        }\n        maxY += height;\n        let maxPixelY = 0;\n        const canvas = document.createElement('canvas');\n        const wholeWidth = (maxX - minX);\n        const wholeHeight = (maxY - minY);\n        const wholeTotal = wholeWidth * 4 * wholeHeight;\n        const displayData = new Uint8ClampedArray(wholeTotal);\n        for (let i = 0; i < storeLen; i++) {\n            const storeItem = store[i];\n            const storeItemWorldOffsetX = storeItem.worldOffsetX;\n            const storeItemWorldOffsetY = storeItem.worldOffsetY;\n            const storeItemData = storeItem.imageData.data;\n            let currentCol = 0;\n            let currentRow = 0;\n            for (let j = 0; j < total;) {\n                const displayCol = currentCol - minX + storeItemWorldOffsetX;\n                const displayRow = currentRow - minY + storeItemWorldOffsetY;\n                if (displayCol >= minX\n                    &&\n                        displayRow >= minY\n                    &&\n                        displayCol < maxX\n                    &&\n                        displayRow < maxY) {\n                    const r = storeItemData[j];\n                    const g = storeItemData[j + 1];\n                    const b = storeItemData[j + 2];\n                    const a = storeItemData[j + 3];\n                    if (a !== 0) {\n                        if (displayRow > maxPixelY) {\n                            maxPixelY = displayRow;\n                        }\n                    }\n                    const displayJ = (displayCol + displayRow * wholeWidth) * 4;\n                    displayData[displayJ] = r;\n                    displayData[displayJ + 1] = g;\n                    displayData[displayJ + 2] = b;\n                    displayData[displayJ + 3] = a;\n                }\n                j += 4;\n                if (j % colLen) {\n                    currentCol++;\n                }\n                else {\n                    currentCol = 0;\n                    currentRow += 1;\n                }\n            }\n        }\n        const targetHeight = (Math.floor(maxPixelY / height) + 1) * height;\n        const displayImageData = new ImageData(displayData, maxX, maxY);\n        canvas.width = maxX;\n        canvas.height = targetHeight;\n        const ctx = canvas.getContext('2d');\n        ctx.putImageData(displayImageData, 0, 0);\n        return canvas;\n    }\n}\n//# sourceMappingURL=Writing.js.map","import { generateCanvas } from '../utils';\nexport default class Eraser {\n    width;\n    height;\n    canvas;\n    ctx;\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.canvas = generateCanvas(width, height);\n        this.ctx = this.canvas.getContext('2d');\n    }\n    draw(cleanX, cleanY, cleanWidth, cleanHeight) {\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        this.ctx.save();\n        this.ctx.beginPath();\n        this.ctx.fillStyle = 'rgba(0,0,0,.1)';\n        this.ctx.strokeStyle = 'rgba(0,0,0,.15)';\n        this.ctx.rect(cleanX - cleanWidth / 2, cleanY - cleanHeight / 2, cleanWidth, cleanHeight);\n        this.ctx.fill();\n        this.ctx.stroke();\n        this.ctx.restore();\n        this.ctx.beginPath();\n    }\n}\n//# sourceMappingURL=Eraser.js.map","import { WriteModel } from '../enum';\nimport { generateCanvas } from '../utils';\nexport default class Eraser {\n    writing;\n    canvas;\n    ctx;\n    writeModel = WriteModel.WRITE;\n    width;\n    height;\n    voice;\n    color;\n    x = null;\n    y = null;\n    d = null;\n    prevX = null;\n    prevY = null;\n    prevD = null;\n    constructor(width, height, voice, writing) {\n        this.writing = writing;\n        this.width = width;\n        this.height = height;\n        this.voice = voice;\n        this.canvas = generateCanvas(this.width, this.height);\n        this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });\n    }\n    reset(color) {\n        this.color = color;\n    }\n    submit() {\n        this.x = null;\n        this.y = null;\n        this.d = null;\n        this.prevX = null;\n        this.prevY = null;\n        this.prevD = null;\n    }\n    draw(pointerType, { prevX, prevY, prevD, x, y, d }) {\n        const writingCtx = this.writing.ctx;\n        const endX = x;\n        const endY = y;\n        const endD = d;\n        const startX = prevX;\n        const startY = prevY;\n        const startD = prevD;\n        if (startX !== null && startY !== null && startD !== null) {\n            if (startX !== endX && startY !== endY) {\n                const threshold = 0.8;\n                const angle = Math.atan2(endY - startY, endX - startX);\n                const angle1 = angle - Math.PI / 2;\n                const angle2 = angle + Math.PI / 2;\n                const halfStartD = Math.max(startD / 2, threshold / 2);\n                const halfEndD = Math.max(endD / 2, threshold / 2);\n                const x1 = Math.cos(angle1) * halfStartD + startX;\n                const y1 = Math.sin(angle1) * halfStartD + startY;\n                const x2 = Math.cos(angle1) * halfEndD + endX;\n                const y2 = Math.sin(angle1) * halfEndD + endY;\n                const x3 = Math.cos(angle2) * halfEndD + endX;\n                const y3 = Math.sin(angle2) * halfEndD + endY;\n                const x4 = Math.cos(angle2) * halfStartD + startX;\n                const y4 = Math.sin(angle2) * halfStartD + startY;\n                writingCtx.save();\n                writingCtx.fillStyle = this.color;\n                writingCtx.strokeStyle = this.color;\n                writingCtx.beginPath();\n                writingCtx.moveTo(x1, y1);\n                writingCtx.lineTo(x2, y2);\n                writingCtx.arc(endX, endY, halfEndD, angle1, angle2);\n                writingCtx.lineTo(x3, y3);\n                writingCtx.lineTo(x4, y4);\n                writingCtx.arc(startX, startY, halfStartD, angle2, angle1);\n                writingCtx.closePath();\n                writingCtx.fill();\n                writingCtx.restore();\n            }\n        }\n    }\n    pushPoints({ x, y, pressure, pointerType }) {\n        let prevX = this.prevX;\n        let prevY = this.prevY;\n        const prevD = this.d;\n        if (this.x === null || (x !== this.x && y !== this.y)) {\n            prevX = this.x;\n            prevY = this.y;\n            this.prevX = prevX;\n            this.prevY = prevY;\n        }\n        this.x = x;\n        this.y = y;\n        if (pointerType) {\n            const minPressure = 0.1;\n            const maxPressure = 0.9;\n            pressure = Math.min(Math.max(minPressure, pressure), maxPressure);\n            const d = this.voice * (.5 + 1.5 * (pressure - minPressure) / (maxPressure - minPressure));\n            this.d = d;\n            this.draw(pointerType, {\n                prevX,\n                prevY,\n                prevD,\n                x,\n                y,\n                d\n            });\n        }\n        else {\n            this.d = this.voice;\n            this.draw(pointerType, {\n                prevX,\n                prevY,\n                prevD,\n                x,\n                y,\n                d: this.d\n            });\n        }\n    }\n}\n//# sourceMappingURL=BrushDrawing.js.map","import { Stack } from './stack';\nimport { WriteModel, BGPattern, ScrollDirection, ShapeType } from './enum';\nimport { debounce, getTripleTouchAngleAndCenter, rotateCoordinate, negativeRemainder } from './utils';\nimport ToolShape from './component/ToolShape';\nimport Background from './component/Background';\nimport RuleAuxiliary from './component/RuleAuxiliary';\nimport Border from './component/Border';\nimport Writing from './component/Writing';\nimport Eraser from './component/Eraser';\nimport BrushDrawing from './component/BrushDrawing';\nexport { WriteModel, BGPattern, ScrollDirection, ShapeType };\nfunction isTouchDevice() {\n    return 'ontouchstart' in self;\n}\n/**\n * 滚动范围\n */\nconst defaultScrollRange = [[null, null], [null, null]];\n/**\n * 滚动方向\n */\nconst defaultScrollDirection = ScrollDirection.ALL;\n/**\n * 背景格式\n */\nconst defaultBGPattern = BGPattern.GRID;\n/**\n * 是否启用全览模式\n */\n// const defaultEnableEagleEyeMode = false;\n/**\n * 绘画模式 书写模式 绘画模式\n */\nconst defaultWriteModel = WriteModel.WRITE;\n/**\n * 是否使用背景\n */\nconst defaultEnableBG = true;\n/**\n * 棋盘格子的间距\n */\nconst defaultGridGap = 100;\n/**\n * 田字格的尺寸\n */\nconst defaultGridPaperGap = 100;\n/**\n * 四线格纵向空白\n */\nconst defaultQuadrillePaperVerticalMargin = 40;\n/**\n * 四线格线的间距\n */\nconst defaultQuadrillePaperGap = 30;\n/**\n * 棋盘格子的填充色\n */\nconst defaultGridFillStyle = 'rgb(250,250,250)';\n/**\n * 田字格边框颜色\n */\nconst defaultGridPaperStrokeStyle = 'green';\n/**\n * 四线格四条线的颜色\n */\nconst defaultQuadrillePaperStrokeStyles = ['rgba(0,0,255,.5)', 'rgba(255,0,0,.5)', 'rgba(0,0,255,1)', 'rgba(0,0,255,.5)'];\n/**\n * 是否使用标尺\n */\nconst defaultRule = true;\n/**\n * 标尺的间距\n */\nconst defaultRuleGap = 10;\n/**\n * 标尺刻度的长度\n */\nconst defaultRuleUnitLen = 5;\n/**\n * 标尺的颜色\n */\nconst defaultRuleStrokeStyle = 'rgba(0,0,0,0.5)';\n/**\n * 笔尖的粗细\n */\nconst defaultVoice = 1;\n/**\n * 墨水颜色\n */\nconst defaultColor = 'rgb(0,0,0)';\n/**\n * 是否启用操作历史\n */\nconst defaultStack = true;\n/**\n * 橡皮擦除的宽度\n */\nconst defaultCleanWidth = 20;\n/**\n * 橡皮擦除的高度\n */\nconst defaultCleanHeight = 20;\n/**\n * 滚动的时候执行的次数\n */\nconst defaultMoveCountTotal = 20;\n/**\n * 是否锁定书写\n */\nconst defaultWriteLocked = false;\n/**\n * 是否锁定拖拽\n */\nconst defaultDragLocked = false;\n/**\n * 是否显示边框\n */\nconst defaultShowBorder = true;\n/**\n * 边框的颜色\n */\nconst defaultBorderStyle = '#333';\n/**\n * 边框的宽度\n */\nconst defaultBorderWidth = 2;\n/**\n * 是否使用尺子等工具\n */\nconst defaultUseShapeType = false;\nconst defaultOptions = {\n    scrollRange: defaultScrollRange,\n    scrollDirection: defaultScrollDirection,\n    bgPattern: defaultBGPattern,\n    writeModel: defaultWriteModel,\n    enableBG: defaultEnableBG,\n    gridGap: defaultGridGap,\n    gridPaperGap: defaultGridPaperGap,\n    quadrillePaperVerticalMargin: defaultQuadrillePaperVerticalMargin,\n    quadrillePaperGap: defaultQuadrillePaperGap,\n    gridFillStyle: defaultGridFillStyle,\n    gridPaperStrokeStyle: defaultGridPaperStrokeStyle,\n    quadrillePaperStrokeStyles: defaultQuadrillePaperStrokeStyles,\n    rule: defaultRule,\n    ruleGap: defaultRuleGap,\n    ruleUnitLen: defaultRuleUnitLen,\n    ruleStrokeStyle: defaultRuleStrokeStyle,\n    voice: defaultVoice,\n    color: defaultColor,\n    stack: defaultStack,\n    cleanWidth: defaultCleanWidth,\n    cleanHeight: defaultCleanHeight,\n    moveCountTotal: defaultMoveCountTotal,\n    writeLocked: defaultWriteLocked,\n    dragLocked: defaultDragLocked,\n    showBorder: defaultShowBorder,\n    borderStyle: defaultBorderStyle,\n    borderWidth: defaultBorderWidth,\n    useShapeType: defaultUseShapeType\n};\nexport default class Board {\n    container;\n    width;\n    height;\n    worldOffsetX = 0;\n    worldOffsetY = 0;\n    scrolling = false;\n    cleanState = false;\n    cleanX;\n    cleanY;\n    cleanPress = false;\n    stackObj;\n    moveT = false;\n    debounceBindOnChange;\n    toolShape;\n    activateToolShape = false;\n    background;\n    ruleAuxiliary;\n    border;\n    writing;\n    eraser;\n    eraserHasContent = false;\n    brushDrawing;\n    scrollRange;\n    scrollDirection;\n    bgPattern;\n    writeModel;\n    enableBG;\n    gridGap;\n    gridPaperGap;\n    quadrillePaperVerticalMargin;\n    quadrillePaperGap;\n    gridFillStyle;\n    gridPaperStrokeStyle;\n    quadrillePaperStrokeStyles;\n    rule;\n    ruleGap;\n    ruleUnitLen;\n    ruleStrokeStyle;\n    voice;\n    color;\n    cleanWidth;\n    cleanHeight;\n    stack;\n    moveCountTotal;\n    writeLocked;\n    dragLocked;\n    showBorder;\n    borderStyle;\n    borderWidth;\n    useShapeType;\n    containerOffset;\n    onChange;\n    constructor(container, options = defaultOptions) {\n        this.container = container;\n        this.scrollRange = options.scrollRange ?? defaultScrollRange;\n        this.scrollDirection = options.scrollDirection ?? defaultScrollDirection;\n        this.bgPattern = options.bgPattern ?? defaultBGPattern;\n        this.writeModel = options.writeModel ?? defaultWriteModel;\n        this.enableBG = options.enableBG ?? defaultEnableBG;\n        this.gridGap = options.gridGap ?? defaultGridGap;\n        this.gridPaperGap = options.gridPaperGap ?? defaultGridPaperGap;\n        this.quadrillePaperVerticalMargin = options.quadrillePaperVerticalMargin ?? defaultQuadrillePaperVerticalMargin;\n        this.quadrillePaperGap = options.quadrillePaperGap ?? defaultQuadrillePaperGap;\n        this.gridFillStyle = options.gridFillStyle ?? defaultGridFillStyle;\n        this.gridPaperStrokeStyle = options.gridPaperStrokeStyle ?? defaultGridPaperStrokeStyle;\n        this.quadrillePaperStrokeStyles = options.quadrillePaperStrokeStyles ?? defaultQuadrillePaperStrokeStyles;\n        this.rule = options.rule ?? defaultRule;\n        this.ruleGap = options.ruleGap ?? defaultRuleGap;\n        this.ruleUnitLen = options.ruleUnitLen ?? defaultRuleUnitLen;\n        this.ruleStrokeStyle = options.ruleStrokeStyle ?? defaultRuleStrokeStyle;\n        this.voice = options.voice ?? defaultVoice;\n        this.color = options.color ?? defaultColor;\n        this.stack = options.stack ?? defaultStack;\n        this.cleanWidth = options.cleanWidth ?? defaultCleanWidth;\n        this.cleanHeight = options.cleanHeight ?? defaultCleanHeight;\n        this.moveCountTotal = options.moveCountTotal ?? defaultMoveCountTotal;\n        this.writeLocked = options.writeLocked ?? defaultWriteLocked;\n        this.dragLocked = options.dragLocked ?? defaultDragLocked;\n        this.showBorder = options.showBorder ?? defaultShowBorder;\n        this.borderStyle = options.borderStyle ?? defaultBorderStyle;\n        this.borderWidth = options.borderWidth ?? defaultBorderWidth;\n        this.useShapeType = options.useShapeType ?? defaultUseShapeType;\n        this.containerOffset = options.containerOffset ?? (() => {\n            const scrollingElement = document.scrollingElement;\n            const rect = this.container.getBoundingClientRect();\n            return {\n                x: rect.x + scrollingElement.scrollLeft,\n                y: rect.y + scrollingElement.scrollTop\n            };\n        });\n        this.onChange = options.onChange;\n        this.debounceBindOnChange = debounce(this.triggerOnChange, 500);\n        const rect = container.getBoundingClientRect();\n        this.width = rect.width;\n        this.height = rect.height;\n        if (this.stack) {\n            this.stackObj = new Stack(this.width, this.height);\n            this.stackObj.restoreState = (store) => {\n                const storeLen = store.length;\n                const lastStoreItem = store[storeLen - 1];\n                const prevWorldOffsetX = this.worldOffsetX;\n                const prevWorldOffsetY = this.worldOffsetY;\n                const targetWorldOffsetX = lastStoreItem.worldOffsetX;\n                const targetWorldOffsetY = lastStoreItem.worldOffsetY;\n                const offsetX = targetWorldOffsetX - prevWorldOffsetX;\n                const offsetY = targetWorldOffsetY - prevWorldOffsetY;\n                if (!offsetX && !offsetY) {\n                    this.worldOffsetX = lastStoreItem.worldOffsetX;\n                    this.worldOffsetY = lastStoreItem.worldOffsetY;\n                    this.writing.store = store;\n                    this.draw();\n                }\n                else {\n                    const preOffsetX = offsetX / this.moveCountTotal;\n                    const preOffsetY = offsetY / this.moveCountTotal;\n                    this.writing.store = store;\n                    this.moveT = true;\n                    this.doMove(preOffsetX, preOffsetY);\n                }\n            };\n        }\n        this.background = new Background(this.width, this.height, this.gridGap, this.gridFillStyle, this.gridPaperGap, this.gridPaperStrokeStyle, this.quadrillePaperVerticalMargin, this.quadrillePaperGap, this.quadrillePaperStrokeStyles);\n        this.container.append(this.background.canvas);\n        this.ruleAuxiliary = new RuleAuxiliary(this.width, this.height, this.ruleStrokeStyle, this.ruleGap, this.ruleUnitLen);\n        this.container.append(this.ruleAuxiliary.canvas);\n        this.border = new Border(this.width, this.height, this.borderStyle, this.borderWidth);\n        this.container.append(this.border.canvas);\n        this.writing = new Writing(this.width, this.height);\n        this.container.append(this.writing.canvas);\n        this.toolShape = new ToolShape(this.width, this.height, this.voice, container, this.getPageCoords);\n        this.container.append(this.toolShape.canvas);\n        this.eraser = new Eraser(this.width, this.height);\n        this.container.append(this.eraser.canvas);\n        this.brushDrawing = new BrushDrawing(this.width, this.height, this.voice, this.writing);\n        this.container.append(this.brushDrawing.canvas);\n        this.loadEvent();\n        this.draw();\n    }\n    setVoice(voice = 1) {\n        this.voice = voice;\n        this.brushDrawing.voice = voice;\n        this.brushDrawing.d = voice;\n    }\n    showBG() {\n        this.enableBG = true;\n        this.draw();\n    }\n    hideBG() {\n        this.enableBG = false;\n        this.draw();\n    }\n    showRule() {\n        this.rule = true;\n        this.draw();\n    }\n    hideRule() {\n        this.rule = false;\n        this.draw();\n    }\n    showToolShape() {\n        this.useShapeType = true;\n        this.drawToolShape();\n    }\n    hideToolShape() {\n        this.useShapeType = false;\n        this.drawToolShape();\n    }\n    setToolShapeType(shapeType) {\n        this.toolShape.toolShapeType = shapeType;\n        this.drawToolShape();\n    }\n    adjustOffset() {\n        const [[minX, maxX], [minY, maxY]] = this.scrollRange;\n        if (typeof minX === 'number') {\n            this.worldOffsetX = Math.max(minX, this.worldOffsetX);\n        }\n        if (typeof maxX === 'number') {\n            this.worldOffsetX = Math.min(maxX, this.worldOffsetX);\n        }\n        if (typeof minY === 'number') {\n            this.worldOffsetY = Math.max(minY, this.worldOffsetY);\n        }\n        if (typeof maxY === 'number') {\n            this.worldOffsetY = Math.min(maxY, this.worldOffsetY);\n        }\n        this.worldOffsetX = Math.round(this.worldOffsetX);\n        this.worldOffsetY = Math.round(this.worldOffsetY);\n    }\n    doMove(preOffsetX, preOffsetY, i = 0) {\n        if (this.scrollDirection === ScrollDirection.ALL) {\n            this.worldOffsetX += preOffsetX;\n            this.worldOffsetY += preOffsetY;\n        }\n        else if (this.scrollDirection === ScrollDirection.X) {\n            this.worldOffsetX += preOffsetX;\n        }\n        else if (this.scrollDirection === ScrollDirection.Y) {\n            this.worldOffsetY += preOffsetY;\n        }\n        this.adjustOffset();\n        this.draw();\n        self.requestAnimationFrame(() => {\n            if (this.moveT && i < this.moveCountTotal) {\n                this.doMove(preOffsetX, preOffsetY, ++i);\n            }\n            else {\n                this.moveT = false;\n            }\n        });\n    }\n    scrollBy(x = 0, y = 0) {\n        if (!this.dragLocked) {\n            const preOffsetX = x / this.moveCountTotal;\n            const preOffsetY = y / this.moveCountTotal;\n            this.moveT = true;\n            this.doMove(preOffsetX, preOffsetY);\n        }\n    }\n    clear() {\n        this.worldOffsetX = 0;\n        this.worldOffsetY = 0;\n        this.writing.clear();\n        this.draw();\n        this.stackObj.saveState([...this.writing.store]);\n    }\n    triggerOnChange() {\n        window.requestIdleCallback(() => {\n            if (this.onChange) {\n                const canvas = this.exportAsCanvas();\n                this.onChange(canvas);\n            }\n        });\n    }\n    exportAsCanvas() {\n        return this.writing.getWholeCanvas();\n    }\n    exportAsPaperCanvas() {\n        const imageCanvas = this.writing.getPaperCanvas();\n        const canvas = document.createElement('canvas');\n        canvas.width = imageCanvas.width;\n        canvas.height = imageCanvas.height;\n        const ctx = canvas.getContext('2d');\n        if (this.enableBG) {\n            this.loadBackground(ctx);\n        }\n        ctx.drawImage(imageCanvas, 0, 0);\n        return canvas;\n    }\n    undo() {\n        this.stackObj.undo();\n    }\n    redo() {\n        this.stackObj.redo();\n    }\n    clean() {\n        this.cleanState = true;\n    }\n    unclean() {\n        this.cleanState = false;\n    }\n    draw() {\n        this.loadBackground();\n        this.loadRule();\n        this.writing.refresh(this.worldOffsetX, this.worldOffsetY);\n        this.drawEraser();\n        this.drawToolShape();\n        this.debounceBindOnChange();\n    }\n    doPushPoints(x, y, event) {\n        if (event.pointerType === 'pen') {\n        }\n        this.brushDrawing.pushPoints({ x, y, pressure: event.pressure, pointerType: event.pointerType });\n    }\n    loadEvent() {\n        let hasMoved = false;\n        let hasWrited = false;\n        let isDoubleTouch = false;\n        let isToolShapeDoubleTouch = false;\n        let rotationCenter;\n        let turnStartAngle = 0;\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let dragStartTime = 0;\n        let dragEndX = 0;\n        let dragEndY = 0;\n        let dragEndTime = 0;\n        let isSingleTouch = false;\n        const handleWriteStart = (coords, event) => {\n            const x = coords.pageX;\n            const y = coords.pageY;\n            this.brushDrawing.reset(this.color);\n            hasMoved = false;\n            hasWrited = false;\n            let conformingToDistance = false;\n            if (this.useShapeType) {\n                const distanceAndPoint = this.toolShape.getNearestDistanceAndPoint(coords.pageX, coords.pageY, this.voice, this.color);\n                conformingToDistance = distanceAndPoint.conformingToDistance;\n            }\n            if (!this.cleanState && conformingToDistance) {\n                this.activateToolShape = true;\n            }\n            else {\n                if (!this.cleanState && this.useShapeType && this.toolShape.isPointInPath(coords.pageX, coords.pageY, 'evenodd')) {\n                    isSingleTouch = false;\n                }\n                else if (!this.cleanState && !this.useShapeType) {\n                    this.doPushPoints(x, y, event);\n                }\n                this.activateToolShape = false;\n            }\n            if (this.cleanState) {\n                this.cleanX = x;\n                this.cleanY = y;\n                this.cleanPress = true;\n                this.drawEraser();\n            }\n        };\n        const handleTouchStart = (event) => {\n            this.moveT = false;\n            this.scrolling = false;\n            const touches = event.touches;\n            const coords = this.getPageCoords(touches);\n            if (touches.length === 2) {\n                isDoubleTouch = true;\n                isSingleTouch = false;\n                if (this.dragLocked) {\n                    return;\n                }\n                dragEndX = coords.pageX;\n                dragEndY = coords.pageY;\n                dragEndTime = performance.now();\n                if (this.cleanState) {\n                    this.cleanPress = false;\n                    this.draw();\n                }\n                let isPointInPath = false;\n                if (this.useShapeType && this.toolShape.isPointInPath(coords.pageX, coords.pageY, 'nonzero')) {\n                    isPointInPath = true;\n                }\n                if (isPointInPath) {\n                    isToolShapeDoubleTouch = true;\n                    rotationCenter = { x: coords.pageX, y: coords.pageY };\n                    turnStartAngle = Math.atan2(touches[1].pageY - touches[0].pageY, touches[1].pageX - touches[0].pageX) / Math.PI * 180;\n                    if (turnStartAngle < 0) {\n                        turnStartAngle += 360;\n                    }\n                }\n                else {\n                    isToolShapeDoubleTouch = false;\n                }\n            }\n            else if (touches.length === 1 && !this.writeLocked) {\n                isSingleTouch = true;\n            }\n            else {\n                isSingleTouch = false;\n            }\n        };\n        const handlePointerdown = (event) => {\n            isSingleTouch = true;\n            event.preventDefault();\n            if (!this.writeLocked) {\n                setTimeout(() => {\n                    if (isSingleTouch) {\n                        const { pageX, pageY } = event;\n                        const coords = this.getPageCoords([{ pageX, pageY }]);\n                        handleWriteStart(coords, event);\n                    }\n                });\n            }\n        };\n        const doInsertPointByToolShape = (nearestPoints) => {\n            this.writing.singlePointsWriting(nearestPoints);\n        };\n        const handleWriteMove = (coords, event) => {\n            const x = coords.pageX;\n            const y = coords.pageY;\n            hasMoved = true;\n            hasWrited = true;\n            if (this.cleanState) {\n                this.cleanX = x;\n                this.cleanY = y;\n                this.doClean(x, y);\n                this.drawEraser();\n            }\n            else {\n                if (this.useShapeType && this.activateToolShape) {\n                    const lineWidth = this.voice;\n                    const { drawPoints } = this.toolShape.getNearestDistanceAndPoint(coords.pageX, coords.pageY, lineWidth, this.color);\n                    doInsertPointByToolShape(drawPoints);\n                }\n                else {\n                    this.doPushPoints(x, y, event);\n                }\n            }\n        };\n        const handlePointermove = (event) => {\n            setTimeout(() => {\n                if (isSingleTouch) {\n                    const { pageX, pageY } = event;\n                    const coords = this.getPageCoords([{ pageX, pageY }]);\n                    handleWriteMove(coords, event);\n                }\n            });\n        };\n        const handleTouchMove = (event) => {\n            const touches = event.touches;\n            if (isDoubleTouch) {\n                if (this.dragLocked) {\n                    return;\n                }\n                dragStartX = dragEndX;\n                dragStartY = dragEndY;\n                dragStartTime = dragEndTime;\n                const coords = this.getPageCoords(touches);\n                dragEndX = coords.pageX;\n                dragEndY = coords.pageY;\n                dragEndTime = performance.now();\n                if (this.useShapeType && isToolShapeDoubleTouch) {\n                    const deltaX = dragEndX - dragStartX;\n                    const deltaY = dragEndY - dragStartY;\n                    this.toolShape.toolShapeCenterX += deltaX;\n                    this.toolShape.toolShapeCenterY += deltaY;\n                    if (event.touches.length === 2) {\n                        let { angle } = getTripleTouchAngleAndCenter(event);\n                        if (angle < 0) {\n                            angle += 360;\n                        }\n                        let deltaAngle = angle - turnStartAngle;\n                        turnStartAngle = angle;\n                        const [newX, newY] = rotateCoordinate(rotationCenter.x, rotationCenter.y, deltaAngle, this.toolShape.toolShapeCenterX, this.toolShape.toolShapeCenterY);\n                        this.toolShape.toolShapeCenterX = newX;\n                        this.toolShape.toolShapeCenterY = newY;\n                        this.toolShape.angle += deltaAngle;\n                        this.draw();\n                    }\n                }\n                else {\n                    let deltaX = 0;\n                    let deltaY = 0;\n                    if (this.scrollDirection === ScrollDirection.ALL) {\n                        deltaX = dragEndX - dragStartX;\n                        deltaY = dragEndY - dragStartY;\n                    }\n                    else if (this.scrollDirection === ScrollDirection.X) {\n                        deltaX = dragEndX - dragStartX;\n                    }\n                    else if (this.scrollDirection === ScrollDirection.Y) {\n                        deltaY = dragEndY - dragStartY;\n                    }\n                    this.worldOffsetX -= deltaX;\n                    this.worldOffsetY -= deltaY;\n                    this.adjustOffset();\n                    this.draw();\n                }\n            }\n        };\n        const scrollDecay = (speedX, speedY) => {\n            this.scrolling = true;\n            const minSpeed = 0.1;\n            let t = 0;\n            const _scrollDecay = (speedX, speedY) => {\n                if (Math.abs(speedX) > minSpeed || Math.abs(speedY) > minSpeed) {\n                    this.worldOffsetX -= speedX;\n                    this.worldOffsetY -= speedY;\n                    this.adjustOffset();\n                    this.draw();\n                    const ratio = Math.max((99 - 0.01 * t++), 50) / 100;\n                    speedX = ratio * speedX;\n                    speedY = ratio * speedY;\n                    self.requestAnimationFrame(() => {\n                        if (this.scrolling) {\n                            _scrollDecay(speedX, speedY);\n                        }\n                    });\n                }\n                else {\n                    this.scrolling = false;\n                }\n            };\n            _scrollDecay(speedX, speedY);\n        };\n        const handleWriteEnd = (coords) => {\n            if (isDoubleTouch) {\n                if (this.dragLocked) {\n                    return;\n                }\n                const deltaX = dragEndX - dragStartX;\n                const deltaY = dragEndY - dragStartY;\n                const deltaTime = dragEndTime - dragStartTime;\n                let speedX = 0;\n                let speedY = 0;\n                if (this.scrollDirection === ScrollDirection.ALL) {\n                    speedX = deltaX / deltaTime;\n                    speedY = deltaY / deltaTime;\n                }\n                else if (this.scrollDirection === ScrollDirection.X) {\n                    speedX = deltaX / deltaTime;\n                }\n                else if (this.scrollDirection === ScrollDirection.Y) {\n                    speedY = deltaY / deltaTime;\n                }\n                if (!isToolShapeDoubleTouch) {\n                    scrollDecay(speedX, speedY);\n                }\n            }\n        };\n        const handleTouchEnd = (event) => {\n            const touches = event.changedTouches;\n            const coords = this.getPageCoords(touches);\n            handleWriteEnd(coords);\n        };\n        const handlePointerup = (event) => {\n            this.brushDrawing.submit();\n            if (isSingleTouch) {\n                if (!this.cleanState || this.eraserHasContent) {\n                    this.eraserHasContent = false;\n                    this.writing.pushImageData(this.worldOffsetX, this.worldOffsetY);\n                    if (this.stack && hasWrited) {\n                        this.stackObj.saveState(this.writing.store);\n                    }\n                }\n            }\n            if (this.cleanState) {\n                this.cleanPress = false;\n                this.draw();\n            }\n            isDoubleTouch = false;\n            isSingleTouch = false;\n            this.toolShape.prevPoint = null;\n        };\n        const container = this.container;\n        if (isTouchDevice()) {\n            container.addEventListener(\"touchstart\", handleTouchStart, { passive: true });\n            container.addEventListener(\"touchmove\", handleTouchMove, { passive: true });\n            container.addEventListener(\"touchend\", handleTouchEnd, { passive: true });\n        }\n        container.addEventListener(\"pointerdown\", handlePointerdown);\n        self.addEventListener(\"pointermove\", handlePointermove);\n        self.addEventListener(\"pointerup\", handlePointerup);\n    }\n    getPageCoords = (touches) => {\n        const { x: containerX, y: containerY } = this.containerOffset();\n        const length = touches.length;\n        let totalX = 0;\n        let totalY = 0;\n        for (let i = 0; i < length; i++) {\n            const touch = touches[i];\n            totalX += touch.pageX - containerX;\n            totalY += touch.pageY - containerY;\n        }\n        totalX /= length;\n        totalY /= length;\n        return { pageX: totalX, pageY: totalY };\n    };\n    drawEraser() {\n        if (this.cleanState && this.cleanPress) {\n            this.eraser.draw(this.cleanX, this.cleanY, this.cleanWidth, this.cleanHeight);\n        }\n        this.eraser.canvas.style.opacity = (this.cleanState && this.cleanPress) ? '1' : '0';\n    }\n    doClean(writeEndX, writeEndY) {\n        const hasContent = this.writing.doClean(writeEndX - this.cleanWidth / 2, writeEndY - this.cleanHeight / 2, this.cleanWidth, this.cleanHeight, true);\n        if (hasContent) {\n            this.eraserHasContent = true;\n        }\n    }\n    loadBackground(ctx = null) {\n        let coordX = 0;\n        let coordY = 0;\n        let background;\n        if (!ctx) {\n            const offsetX = negativeRemainder(this.worldOffsetX, this.gridGap * 2);\n            const offsetY = negativeRemainder(this.worldOffsetY, this.gridGap * 2);\n            coordX = -offsetX;\n            coordY = -offsetY;\n            background = this.background;\n        }\n        else {\n            const canvas = ctx.canvas;\n            const { width, height } = canvas;\n            background = new Background(width, height, this.gridGap, this.gridFillStyle, this.gridPaperGap, this.gridPaperStrokeStyle, this.quadrillePaperVerticalMargin, this.quadrillePaperGap, this.quadrillePaperStrokeStyles);\n        }\n        if (this.enableBG) {\n            background.draw(coordX, coordY, this.bgPattern);\n            if (ctx) {\n                ctx.drawImage(background.canvas, 0, 0);\n            }\n        }\n        background.canvas.style.opacity = this.enableBG ? '1' : '0';\n    }\n    loadRule() {\n        if (this.rule) {\n            this.ruleAuxiliary.draw(this.worldOffsetX, this.worldOffsetY);\n        }\n        this.ruleAuxiliary.canvas.style.opacity = this.rule ? '1' : '0';\n    }\n    drawToolShape() {\n        this.toolShape.canvas.style.opacity = this.useShapeType ? '1' : '0';\n        if (this.useShapeType) {\n            this.toolShape.draw();\n        }\n    }\n}\nexport { Board };\n//# sourceMappingURL=index.js.map"],"names":["Stack","width","height","undoStack","redoStack","constructor","this","restoreState","saveState","store","push","length","undo","lastState","pop","previousState","data","Uint8ClampedArray","worldOffsetX","worldOffsetY","imageData","ImageData","doRestoreState","redo","nextState","WriteModel","BGPattern","ScrollDirection","ShapeType","RotateCoordinates","angle","x0","y0","angleInRadians","Math","PI","cosAngle","cos","sinAngle","sin","x","y","x1","y1","rotateAngle","angle0","calculateRotatedPoint","rx","ry","r","_angle","angleRad","_angleRad","negativeRemainder","a","b","generateCanvas","canvas","document","createElement","Object","assign","style","left","top","position","exports","Ruler","ctx","cm","mm","path","marginH","degreeNumber","toolShapeCenterX","toolShapeCenterY","getOutlineCtx","_x","_y","outlineVoice","strokeStyle","c","OffscreenCanvas","getContext","generatorOuterBorder","lineWidth","stroke","_cx","_cy","voice","rotateCoordinates","pathStr","join","offestX","beginWaveX","beginWaveY","endWaveX","waveUnit","waveUnitY","waveY","currentWaveUnit","Path2D","draw","cx","cy","clearRect","save","beginPath","fillStyle","fill","restore","font","textAlign","textBaseline","cmLen","textPos","mmLen","halfCmLen","i","currentX","moveTo","lineTo","translate","rotate","fillText","String","j","currentMmX","isPointInPath","fillRule","Compass$1","middleR","smallR","middleGap","startAngle","endAngle","innerStartAngle","innerEndAngle","middleInsideR","middleOutsideR","innerCx","innerCy","arc","closePath","drawDegree","smallUnitL","unitL","bigUnitL","ruleFontSize","fontGap","showText","showSmall","showMiddle","textOnInner","reverse","unitS","startX","startY","endX","endY","textX","Number","textY","toString","drawContent","drawPosition","Compass","container","getPageCoords","toolShape","outsideR","insideR","pointerW","firstPointerAngle","secondPointerAngle","pointer1","pointer2","loadEvent","calculateRotationAngle","dragStartX","dragStartY","dragEndX","dragEndY","aX","aY","bX","bY","cosTheta","sqrt","theta","acos","doTurn","movePointer1","movePointer2","turnPoinerStart","coords","event","pageX","pageY","stopImmediatePropagation","turnPointerMove","deltaAngle","isNaN","reset","addEventListener","preventDefault","self","passive","drawBorder","drawPointer","globalCompositeOperation","offscreen1","c2","drawImage","fillRect","generatorPointer","pointerAngle","showBig","total","drawFixedPoint","isPointInStroke","Triangle","degreeNumberH","degreeNumberV","marginV","marginC","gap","smallX","smallY","smallWidth","smallHeight","currentY","currentMmY","ToolShape","w","h","getNearestDistanceAndPointVoice","outlineCtx","outlineImageData","outline","outlineMap","longestDistance","gatherAreaWidth","prevPoint","_toolShapeType","RULER","ruler","compass","compass360","rightAngleTriangle","isoscelesTriangle","Compass360","shape","toolShapeType","COMPASS","COMPASS360","RIGHT_ANGLE_TRIANGLE","SOSCELESL_TRIANGLE","getGathers","x2","y2","topLeftX","min","topLeftY","bottomRightX","max","bottomRightY","gathers","getNearestDistanceAndPoint","getImageData","getOutline","getOutlineMap","len","innerAreaPoints","nearestDistance","MAX_SAFE_INTEGER","gatherPoint","distance","drawPoints","gathersLen","p","conformingToDistance","row","column","slice","map","uints","Background","gridGap","gridFillStyle","gridPaperGap","gridPaperStrokeStyle","quadrillePaperVerticalMargin","quadrillePaperGap","quadrillePaperStrokeStyles","gridPattern","gridPaperPattern","quadrillePaperPattern","bgPattern","coordX","coordY","generateGridPattern","generateGridPaperPattern","generateQuadrillePaperPattern","GRID","GRID_PAPER","QUADRILLE_PAPER","bgOffscreen","createPattern","strokeRect","setLineDash","RuleAuxiliary","ruleStrokeStyle","ruleGap","ruleUnitLen","offsetX","offsetY","offsetXRule","offsetYRule","Border","borderStyle","borderWidth","Writing","scale","willReadFrequently","imageSmoothingEnabled","imageSmoothingQuality","refresh","putImageData","singlePointsWriting","points","clear","doClean","pushImageData","determineIfThereHasContent","hasContent","storeItem","splice","colLen","storeLen","displayData","storeItemWorldOffsetX","storeItemWorldOffsetY","storeItemData","abs","currentCol","currentRow","displayCol","displayRow","g","displayJ","displayImageData","getWholeCanvas","minX","minY","maxX","maxY","undefined","wholeWidth","wholeHeight","minPixelX","minPixelY","maxPixelX","maxPixelY","targetWidth","targetHeight","getPaperCanvas","floor","Eraser$1","cleanX","cleanY","cleanWidth","cleanHeight","rect","Eraser","writing","writeModel","WRITE","color","d","prevX","prevY","prevD","submit","pointerType","writingCtx","endD","startD","threshold","atan2","angle1","angle2","halfStartD","halfEndD","x3","y3","x4","y4","pushPoints","pressure","minPressure","maxPressure","defaultScrollRange","defaultScrollDirection","ALL","defaultBGPattern","defaultWriteModel","defaultGridFillStyle","defaultGridPaperStrokeStyle","defaultQuadrillePaperStrokeStyles","defaultRuleStrokeStyle","defaultColor","defaultBorderStyle","defaultOptions","scrollRange","scrollDirection","enableBG","rule","stack","moveCountTotal","writeLocked","dragLocked","showBorder","useShapeType","Board","scrolling","cleanState","cleanPress","stackObj","moveT","debounceBindOnChange","activateToolShape","background","ruleAuxiliary","border","eraser","eraserHasContent","brushDrawing","containerOffset","onChange","options","scrollingElement","getBoundingClientRect","scrollLeft","scrollTop","func","delay","timer","args","clearTimeout","setTimeout","apply","debounce","triggerOnChange","lastStoreItem","prevWorldOffsetX","prevWorldOffsetY","preOffsetX","preOffsetY","doMove","append","BrushDrawing","setVoice","showBG","hideBG","showRule","hideRule","showToolShape","drawToolShape","hideToolShape","setToolShapeType","shapeType","adjustOffset","round","X","Y","requestAnimationFrame","scrollBy","window","requestIdleCallback","exportAsCanvas","exportAsPaperCanvas","imageCanvas","loadBackground","clean","unclean","loadRule","drawEraser","doPushPoints","rotationCenter","hasWrited","isDoubleTouch","isToolShapeDoubleTouch","turnStartAngle","dragStartTime","dragEndTime","isSingleTouch","handleWriteStart","handleTouchStart","touches","performance","now","doInsertPointByToolShape","nearestPoints","handleWriteMove","handleTouchMove","deltaX","deltaY","touch1","touch2","center","getTripleTouchAngleAndCenter","newX","newY","originX","originY","radians","rotateCoordinate","scrollDecay","speedX","speedY","t","_scrollDecay","ratio","handleWriteEnd","deltaTime","handleTouchEnd","changedTouches","containerX","containerY","totalX","totalY","touch","opacity","writeEndX","writeEndY"],"mappings":"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"}